<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VanLiuZhi</title>
  
  <subtitle>有梦想的人不睡觉</subtitle>
  <link href="/learn_programing/atom.xml" rel="self"/>
  
  <link href="http://www.liuzhidream.com/"/>
  <updated>2019-01-09T15:48:34.220Z</updated>
  <id>http://www.liuzhidream.com/</id>
  
  <author>
    <name>Liu Zhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git-command</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Git/git-command/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Git/git-command/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:48:34.220Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><a id="more"></a><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>使用GitHub，给出的地址我们一般用ssh。使用ssh需要https，如果不支持只能使用http，但是每次都要输口令。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch \<name></name></li><li>切换分支：git checkout \<name></name></li><li>创建+切换分支：git checkout -b \<name></name></li><li>合并某分支到当前分支：git merge \<name></name></li><li>删除分支：git branch -d \<name></name></li></ul><p>主要理解分支，克隆远程仓库，将本地和远程仓库关联，搭建git服务器</p><h2 id="git-pull-命令"><a href="#git-pull-命令" class="headerlink" title="git pull 命令"></a>git pull 命令</h2><p>作用：取回远程主机某个分支的更新，再与本地的指定分支合并</p><p>格式：git pull  &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p><ol><li>如果与当前分支合并，则可省略本地分支名git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 相当于：git fetch &lt;远程主机名&gt; &lt;远分支名&gt; git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</li><li>如果当前分支与远程分支存在追踪关系 git pull &lt;远程主机名&gt;</li><li>如果当前分支只有一个追踪关系 git pull</li><li>手动建立追踪关系 git branch –set-upstream master origin/next</li><li>清理远程已删除本地还存在的分支 git fetch –prune origin 或者 git fetch -p 或者 git pull -p</li></ol><h2 id="如何上传GitHub"><a href="#如何上传GitHub" class="headerlink" title="如何上传GitHub"></a>如何上传GitHub</h2><ol><li>在用户目录下 .ssh</li><li>ssh-keygen -t rsa -C “<a href="mailto:1441765847@qq.com" target="_blank" rel="noopener">1441765847@qq.com</a>“ </li><li>把 id_rsa.pub  添加到GitHub的ssh上</li><li>git init  把当前目录变为仓库</li><li>git add  把文件添加进仓库  git commit 把文件提交到仓库  </li><li>git add –all 当我们在一个不是空目录下init需要把所有文件添加到仓库的时候使用</li></ol><h2 id="文件的标记解释："><a href="#文件的标记解释：" class="headerlink" title="文件的标记解释："></a>文件的标记解释：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A: 你本地新增的文件（服务器上没有）.</span><br><span class="line"></span><br><span class="line">C: 文件的一个新拷贝.</span><br><span class="line"></span><br><span class="line">D: 你本地删除的文件（服务器上还在）.</span><br><span class="line"></span><br><span class="line">M: 文件的内容或者mode被修改了.</span><br><span class="line"></span><br><span class="line">R: 文件名被修改了。</span><br><span class="line"></span><br><span class="line">T: 文件的类型被修改了。</span><br><span class="line"></span><br><span class="line">U: 文件没有被合并(你需要完成合并才能进行提交)。</span><br><span class="line"></span><br><span class="line">X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br><span class="line"> --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h2 id="git的hook-钩子"><a href="#git的hook-钩子" class="headerlink" title="git的hook(钩子)"></a>git的hook(钩子)</h2><p>为了防止一些不规范的代码 <code>commit</code> 并 <code>push</code> 到远端，我们可以在  <code>git</code> 命令执行前用一些钩子来检测并阻止。<br>在node中，安装需要的模块：<code>husky</code>, <code>pre-commit</code> 配置package.json在提交代码前执行自定义的脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git/hooks</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>该目录提供了git的各个钩子的脚步案例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>element-UI</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/element-UI/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/element-UI/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:07.949Z</updated>
    
    <content type="html"><![CDATA[<p>饿了么前端团队出品的Vue UI框架</p><a id="more"></a><h2 id="from-rules"><a href="#from-rules" class="headerlink" title="from rules"></a>from rules</h2><p>from rules 是表单组件中用于在表单验证规则的属性，把rules绑定给一个对象，对象的属性即为需要做验证的字段，属性值为验证规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rules: &#123;</span><br><span class="line">type: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'type is required'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;],</span><br><span class="line">timestamp: [&#123; <span class="attr">type</span>: <span class="string">'date'</span>, <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'timestamp is required'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对表单的type字段做规则验证，该字段是必须的。</p><h2 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h2><p>关于 Loading  拥有指令调用，服务调用（在需要的地方手动触发），指令的话就是 v-loading=’true’<br>即可。可以通过修饰符把效果的遮蔽罩覆盖到DOM的body上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;饿了么前端团队出品的Vue UI框架&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="farmework" scheme="http://www.liuzhidream.com/tags/farmework/"/>
    
      <category term="Vue" scheme="http://www.liuzhidream.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/ECMAScript/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/ECMAScript/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:44:57.505Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等</p><a id="more"></a><h2 id="扩展运算符（-spread-）"><a href="#扩展运算符（-spread-）" class="headerlink" title="扩展运算符（ spread ）"></a>扩展运算符（ spread ）</h2><p>是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">  <span class="string">'name'</span>: <span class="string">'little bear'</span>,</span><br><span class="line">  <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">'sayHello'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.Person + <span class="string">'我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁!'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.sayHello()</span><br></pre></td></tr></table></figure><p>基础语法</p><ul><li>(参数1, 参数2, …, 参数N) =&gt; {函数声明}</li><li>(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）</li></ul><p>相当于：(参数1, 参数2, …, 参数N) =&gt;{ return表达式}</p><ol><li>当只有一个参数时，圆括号是可选的：</li></ol><ul><li>(单一参数) =&gt; {函数声明}</li><li>单一参数 =&gt; {函数声明}</li></ul><ol start="2"><li>没有参数的函数应该写成一对圆括号。</li></ol><ul><li>() =&gt; {函数声明}</li></ul><p>在上面的代码里面，谁调用，this指向谁，所以this指向的是setInterval, 就是window（因为setInterval）是window就注入的函数。 所以在setInterval 上一行，我们可以var self = this此时的this是sayHello 由Person来调用，这样才能得到我们想要的结果。</p><p>箭头函数最大特点： 不绑定this  不绑定arguments</p><p>es6箭头函数，这个是原来定义函数的缩写。let 和原来的 var 类似，var是声明变量，它所处的位置决定了变量的作用域，比如在函数里面就是函数的作用于，在外部就是全局作用域。let也是这样，但是它的位置决定的是最接近的块的作用域，作用域比var更细，除了函数全局外，如果你用在for，if里面，那么在整个函数里面是不可见的。所以可以用let声明作用域更细的变量。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>理解继承的机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数我们称为构造函数，js通过对构造函数使用new 关键字创建实例（构造函数相当于Class），这样我们就从原型对象生产了一个实例对象。</p><ol><li>共有属性：</li></ol><ul><li>这样创建的实例没有共有属性，于是通过为构造函数设置prototype属性，来让从这个构造函数创建的实例都有共有属性。</li><li>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</li></ul><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p><p>这个prototype是大家共同引用的，修改它会影响实例。</p><ol start="2"><li>constructor：</li></ol><p>通过构造函数创建的实例，访问这个属性就可以知道实例的构造函数是谁。</p><p><code>cat1 instanceof Cat</code> 判断实例cat1是否是通过构造函数Cat来的，类似python的isinstance。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6.1 isPrototypeOf()</span><br><span class="line"></span><br><span class="line">这个方法用来判断，某个proptotype对象和某个实例之间的关系。</span><br><span class="line"></span><br><span class="line">　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line"></span><br><span class="line">　　alert(Cat.prototype.isPrototypeOf(cat2)); //true</span><br><span class="line"></span><br><span class="line">6.2 hasOwnProperty()</span><br><span class="line"></span><br><span class="line">每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</span><br><span class="line"></span><br><span class="line">　　alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line"></span><br><span class="line">　　alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prototype constructor</span><br><span class="line">__proto__</span><br></pre></td></tr></table></figure><ol start="3"><li>普通对象</li></ol><ul><li>最普通的对象：有<strong>proto</strong>属性（指向其原型链），没有prototype属性。</li><li>原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)。</li></ul><ol start="4"><li>函数对象：</li></ol><ul><li>凡是通过new Function()创建的都是函数对象。</li><li>拥有<strong>proto</strong>、prototype属性（指向原型对象）。</li><li>Function、Object、Array、Date、String、自定义函数。</li></ul><p>特例： Function.prototype(是原型对象，却是函数对象，下面会有解释)</p><ol start="4"><li>如何判断是什么对象 typeof 对象</li></ol><p>其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><h2 id="早绑定和晚绑定"><a href="#早绑定和晚绑定" class="headerlink" title="早绑定和晚绑定"></a>早绑定和晚绑定</h2><p>所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。</p><p>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</p><p>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p><h2 id="文件导入"><a href="#文件导入" class="headerlink" title="文件导入"></a>文件导入</h2><p>export default 和 export 区别：</p><ol><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</li><li>在一个文件或模块中，export、import可以有多个，export default仅有一个</li><li><p>通过export方式导出，在导入时要加{ }，export default则不需要</p></li><li><p>export</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> str = <span class="string">"blablabla~"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">sth</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> sth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; str, log &#125; <span class="keyword">from</span> <span class="string">'a'</span>; <span class="comment">//也可以分开写两次，导入的时候带花括号</span></span><br></pre></td></tr></table></figure><ol start="2"><li>export default</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"blablabla~"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str;</span><br></pre></td></tr></table></figure><p>对应的导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> str <span class="keyword">from</span> <span class="string">'a'</span>; <span class="comment">//导入的时候没有花括号</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p><code>Object.assign({}, row)</code> 拷贝对象</p><h2 id="import和require的区别"><a href="#import和require的区别" class="headerlink" title="import和require的区别"></a>import和require的区别</h2><p>node编程中最重要的思想就是模块化，import和require都是被模块化所使用。</p><ol><li>遵循规范</li></ol><ul><li>require 是 AMD规范引入方式</li><li>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li></ul><ol start="2"><li>调用时间</li></ol><ul><li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li><li>import是编译时调用，所以必须放在文件开头</li></ul><ol start="3"><li>本质</li></ol><ul><li>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</li><li>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</li></ul><p>引用同级文件 <code>a.js</code>，<code>b.js</code> 都在一起，应该 <code>import  ./b</code> 不要直接 <code>import b</code></p><p>1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）<br>2，等同于在自组件中：<br>   子组件内部处理click事件然后向外发送click事件：$emit(“click”.fn)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/jQuery/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/jQuery/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:17.342Z</updated>
    
    <content type="html"><![CDATA[<p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><a id="more"></a><h2 id="jQuery-方法"><a href="#jQuery-方法" class="headerlink" title="jQuery 方法"></a>jQuery 方法</h2><p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><h2 id="each"><a href="#each" class="headerlink" title="each( )"></a>each( )</h2><p>如果是去迭代数组 类似 Inpute标签组成的 a:1,b:2：</p><p>使用 <code>$.each(对象，function（index,value）{   });</code> 这样可以拿到数组的键和值</p><p>如果是迭代元素 类似p标签的集合：</p><p>使用 <code>$(&quot;p&quot;).eache(function(index){  });</code> 在函数中，使用this得到当前迭代的元素  </p><h2 id="is"><a href="#is" class="headerlink" title="is()"></a>is()</h2><p>is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。</p><h2 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h2><p>解析一个字符串，并返回一个浮点数，参数必须且是一个字符</p><p>该函数先去判断第一个字符串是否是数字，不是，函数返回 NaN，是，继续执行。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p><p>NaN 属性是JS的Number对象，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。比如月份用数字5代表5月份，var number=5; number.NaN,number现在就不是数字了。</p><ul><li>isNaN()  该一个要检测的参数（必须）看是不是NaN，是就返回True 其它值返回False。</li><li>parseInt() 函数可解析一个字符串，并返回一个整数。</li><li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。即索引值。</li><li>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</li></ul><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>text（）用来设置或返回值，val()返回value的值</p><p>attr() 方法设置或返回被选元素的属性值。该方法不同的参数会有不同的效果</p><p>attr(“id”,123)   选择器得到的JQuery对象的attr方法，将对象的id 改变为 “123”（没有id直接添加一个id）</p><p>appendto() append()</p><p>append() 方法在被选元素的结尾（仍然在内部）插入指定内容。<br>提示：append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容的位置和选择器。<br>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p标签原来的内容 &lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">$(&quot;p&quot;).append(&quot; &lt;b&gt;Hello world!&lt;/b&gt;&quot;);   </span><br><span class="line">执行方法后  This is a paragraph. Hello world!</span><br><span class="line"></span><br><span class="line">$(&quot;&lt;b&gt; Hello World!&lt;/b&gt;&quot;).appendTo(&quot;p&quot;);</span><br><span class="line">p标签原内容和执行结果同上。</span><br></pre></td></tr></table></figure><p>find（）方法 由给定表达式去匹配满足条件的后代元素，返回jquery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b=$(<span class="string">"#id"</span>).find(<span class="string">'[name=id]'</span>);</span><br></pre></td></tr></table></figure><p>window.location.href=”url”  当前页面打开URL</p><p>当点击元素时，会发生 click 事件。</p><p>当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click。</p><p>click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数。</p><p>on 为元素绑定事件，比如click事件，然后加个函数，这个元素点击后就会去执行这个函数。</p><h2 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h2><p>jquery渲染页面方法，<code>$.html()</code> 对dom执行html方法，会将dom的内容给替换了，比如 <code>&lt;div class=123&gt;&lt;/div&gt;</code>  对这个dom执行方法<code>html(&lt;p&gt;123&lt;/p&gt;)</code> 结果是<code>&lt;div class=123&gt;&lt;p&gt;123&lt;/p&gt;&lt;/div&gt;</code></p><h2 id="元素切换"><a href="#元素切换" class="headerlink" title="元素切换"></a>元素切换</h2><p>sildeup sildedown，show hide 元素切换隐藏</p><h2 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h2><ul><li>siblings：<code>dom.siblings(.class).addClass()</code> 对选择对象执行遍历，找到所有class类，并给他们添加样式。</li></ul><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll()"></a>scroll()</h2><p>dom调用，可以在滚动条滚动的时候触发，只要有滚动就触发。这里注意如果逻辑涉及到滚动的数值判断，使用比较不要使用相等，因为滚动很快，相关的判断不一定每次执行到。</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>直接写在dom上，相当于 <code>style : dom.css(&#39;color&#39;, &#39;red&#39;)</code></p><p>hasClass()   addClass()   removClass()   对dom类的控制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>node</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/node/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/node/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:22.818Z</updated>
    
    <content type="html"><![CDATA[<p>服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端</p><a id="more"></a><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack把多种静态资源转换成一个静态文件</p><h3 id="的含义"><a href="#的含义" class="headerlink" title="@ 的含义"></a>@ 的含义</h3><p>在webpack的配置中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在需要导入组件的时候使用 <code>import A from &#39;@/components/a.vue&#39;</code> 就是给复杂了引用路径做个别名。</p><h3 id="修改编译路径"><a href="#修改编译路径" class="headerlink" title="修改编译路径"></a>修改编译路径</h3><p>编译路径修改（由于存在编译出来的文件相互依赖的，而你只导入其中几个，依赖就出问题了，为了不修改后端代码，修改通用编译路径是不错的解决方案）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">assetsRoot: path.resolve(__dirname, <span class="string">'../static/dist'</span>),</span><br><span class="line">assetsSubDirectory: <span class="string">''</span>,</span><br><span class="line">assetsPublicPath: <span class="string">'/static/dist/'</span>,</span><br><span class="line">productionSourceMap: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>一个转码器，将es6转es5，这个东西何用？node.js直接执行es6代码还存在问题，听说最新版本可以了。所以用es6来写js，这样可以利用它的新特性，然后转码，这样node.js就可以运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/categories/node-js/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>npm</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/npm/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/npm/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:27.745Z</updated>
    
    <content type="html"><![CDATA[<p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><a id="more"></a><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，实在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><h2 id="全局和局部"><a href="#全局和局部" class="headerlink" title="全局和局部"></a>全局和局部</h2><p>一般在全局安装的是工具，比如webpack，这样这些工具在构建项目或者执行项目的命令的时候由于是全局任何地方都能使用，而局部就是装模块的，这些模块可能因为依赖关系，你最好不要在全局装模块，如果你的项目引用全局模块，多个项目的时候，可能依赖不一样，这样你去更新全局模块的时候就可能由于依赖的问题影响其它项目了。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>npm list -g –depth 0</td><td style="text-align:center">查看全局安装包 </td></tr><tr><td>npm install packagename -g</td><td style="text-align:center">全局安装</td></tr><tr><td>npm uninstall package -g</td><td style="text-align:center">全局卸载</td></tr><tr><td>npm install pg –save</td><td style="text-align:center">项目依赖安装</td></tr><tr><td>npm install pg –save-dev</td><td style="text-align:center">项目非依赖安装</td></tr><tr><td>npm view jquery versions</td><td style="text-align:center">查看模块版本号，这里举例的是jQuery</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/categories/node-js/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>nvm</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/nvm/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/nvm/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:46:27.223Z</updated>
    
    <content type="html"><![CDATA[<p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><a id="more"></a><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Mac 下安装使用github提供的脚本安装，安装完成添加对应shell的配置</p><p>nvm 使用brew安装会有一些小问题 <a href="https://www.imooc.com/article/14617" target="_blank" rel="noopener">正确的安装和使用nvm(mac)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span></span><br><span class="line"><span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p>github 地址 <a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">https://github.com/creationix/nvm/blob/master/README.md</a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>nvm install stable</td><td style="text-align:center">安装最新稳定版            </td></tr><tr><td>nvm install \<version></version></td><td style="text-align:center">安装指定版本，可模糊安。如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4   </td></tr><tr><td>nvm uninstall \<version></version></td><td style="text-align:center">删除已安装的指定版本，语法与install类似  </td></tr><tr><td>nvm ls</td><td style="text-align:center">列出所有安装的版本</td></tr><tr><td>nvm ls-remote</td><td style="text-align:center">列出所有远程服务器的版本（官方node version list）</td></tr><tr><td>nvm current</td><td style="text-align:center">显示当前的版本</td></tr><tr><td>nvm alias \<name> \<version></version></name></td><td style="text-align:center">给不同的版本号添加别名</td></tr><tr><td>nvm unalias \<name></name></td><td style="text-align:center">删除已定义的别名</td></tr><tr><td>nvm reinstall-packages \<version></version></td><td style="text-align:center">在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/categories/node-js/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="node.js" scheme="http://www.liuzhidream.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptUtil</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScriptUtil/JavaScriptUtil/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScriptUtil/JavaScriptUtil/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:42.461Z</updated>
    
    <content type="html"><![CDATA[<p>常见的JavaScript 相关设计</p><a id="more"></a><h2 id="自定义遮蔽罩"><a href="#自定义遮蔽罩" class="headerlink" title="自定义遮蔽罩"></a>自定义遮蔽罩</h2><p>使用了jQuery-WeUI，需要根据情况做调整</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自定义遮罩层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bg"</span> <span class="attr">class</span>=<span class="string">"weui-mask weui-mask--visible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"display: none;opacity: 1;visibility: visible;z-index: 100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简单示例 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>html 最简遮罩层<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showDiv</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'popDiv'</span>).style.display = <span class="string">'block'</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'bg'</span>).style.display = <span class="string">'block'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">closeDiv</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'popDiv'</span>).style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'bg'</span>).style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"popDiv"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"z-index:99;display:none;position:absolute;margin-top: 20%;margin-left: 40%;background-color: #FFF;"</span>&gt;</span>html</span><br><span class="line">    最简遮罩层<span class="tag">&lt;<span class="name">br</span>/&gt;</span>html 最简遮罩层<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:closeDiv()"</span>&gt;</span>关闭遮罩层<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"display:none;background-color: #ccc;width: 100%;position:absolute;height: 100%;opacity: 0.5;z-index: 1;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"padding-top: 10%;padding-left:40%;z-index:1;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"Submit"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"打开遮罩层"</span> <span class="attr">onclick</span>=<span class="string">"javascript:showDiv()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的JavaScript 相关设计&lt;/p&gt;
    
    </summary>
    
      <category term="util" scheme="http://www.liuzhidream.com/categories/util/"/>
    
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="util" scheme="http://www.liuzhidream.com/tags/util/"/>
    
  </entry>
  
  <entry>
    <title>linux-command</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Linux/linux-command/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Linux/linux-command/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:48:43.961Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 命令与工具</p><a id="more"></a><h2 id="chsh-修改用户使用的shell"><a href="#chsh-修改用户使用的shell" class="headerlink" title="chsh 修改用户使用的shell"></a>chsh 修改用户使用的shell</h2><p>查看 <code>cat /etc/shells</code> 文件，显示当前系统支持的shell，使用 <code>chsh -s /bin/zsh</code> 修改。该命令最终的效果会修改 <code>/etc/passwd</code> 文件。</p><h2 id="env-printenv-查看环境变量"><a href="#env-printenv-查看环境变量" class="headerlink" title="env printenv 查看环境变量"></a>env printenv 查看环境变量</h2><p>理解全局环境变量和局部环境变量，全局变量包括系统设置的和用户自己添加的，系统变量一般是全大写字母，通过printenv命令可以查看变量值 <code>printenv HOME</code>。</p><h2 id="scp-拷贝命令"><a href="#scp-拷贝命令" class="headerlink" title="scp 拷贝命令"></a>scp 拷贝命令</h2><p>scp命令 （主机和服务器相互拷贝数据，该命令要求开启scp服务。</p><p>从服务器到本地 <code>scp root@ip:拷贝路径 本地路径</code></p><p>从本地到服务器 <code>scp 本地路径 root@ip:拷贝路径</code></p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>内容查找命令，配合其它命令一起使用</p><h2 id="find-查找命令"><a href="#find-查找命令" class="headerlink" title="find 查找命令"></a>find 查找命令</h2><p>查找命令，列出符合条件的文件路径。 find / -name *</p><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>查看系统运行情况，启动时间，登陆时间等。最后的三个数字代表系统最近1分钟，5分钟，15分钟负载情况。</p><pre><code>liuzhi@localhost  ~  uptime23:03  up 13:47, 3 users, load averages: 1.04 1.25 1.37</code></pre><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof 是 linux 下的一个非常实用的系统级的监控、诊断工具。<br>它的意思是 <code>List Open Files</code>，很容易你就记住了它是 <code>“ls + of”</code> 的组合。<br>它可以用来列出被各种进程打开的文件信息，记住：linux 下 “一切皆文件”，<br>包括但不限于 pipes, sockets, directories, devices, 等等。<br>因此，使用 lsof，你可以获取任何被打开文件的各种信息。</p><p>监控进程：<code>lsof -p 2854</code> 查看指定进程打开的文件。</p><p>监控网络：<code>lsof -i:8080</code> 查看端口被哪些进程使用。</p><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>wget url 下载文件</p><h2 id="tar-解压"><a href="#tar-解压" class="headerlink" title="tar 解压"></a>tar 解压</h2><p>关于解压，如果是网络的包，文件后缀tar.gz</p><p>解压命令 tar zxf filename</p><p>zip类型，需要安装解压工具 unzip</p><p>unzip filename 先创建好目标目录，在里面解压，或者指定目录</p><h2 id="screen-工具"><a href="#screen-工具" class="headerlink" title="screen 工具"></a>screen 工具</h2><p>需要下载</p><p>screen -r name</p><p>screen -S name  最好用大写的S</p><p>screen C d  关闭当前会话并结束进程</p><p>screen -ls</p><p>会话会有状态，dead 状态利用screen -wipe 清除</p><p>Detached 为没有人登陆，Attached为有人，有时候没有人也会是这个状态，一般是出问题了screen -D  -r ＜session-id&gt; 先踢掉前一用户，再登陆。</p><p>screen -X -S session_id quit</p><h2 id="查看发行版本信息"><a href="#查看发行版本信息" class="headerlink" title="查看发行版本信息"></a>查看发行版本信息</h2><p><code>cat /etc/issue</code> 或 <code>cat /etc/redhat-release</code>（Linux查看版本当前操作系统发行版信息）</p><h2 id="查看内核信息"><a href="#查看内核信息" class="headerlink" title="查看内核信息"></a>查看内核信息</h2><p><code>uname -a</code>（Linux查看版本当前操作系统内核信息）</p><h2 id="查看操作系统版本信息"><a href="#查看操作系统版本信息" class="headerlink" title="查看操作系统版本信息"></a>查看操作系统版本信息</h2><p><code>cat /proc/version</code>（Linux查看当前操作系统版本信息）</p><h2 id="mkdir-p"><a href="#mkdir-p" class="headerlink" title="mkdir -p"></a>mkdir -p</h2><p>mkdir 用于创建文件夹，如果包含子目录，需要使用 -p ，这样就可以创建多层级的目录</p><p>例子：mkdir -p ~/web-develop/projects/data</p><h2 id="mv-移动、重命名"><a href="#mv-移动、重命名" class="headerlink" title="mv 移动、重命名"></a>mv 移动、重命名</h2><p>mv [options] 源文件或目录 目标文件或目录</p><h2 id="Debian-删除软件"><a href="#Debian-删除软件" class="headerlink" title="Debian 删除软件"></a>Debian 删除软件</h2><p>基于Debian的Linux发行版使用apt-get管理软件包</p><ul><li>apt-get remove 会删除软件包而保留软件的配置文件</li><li>apt-get purge 会同时清除软件包和软件的配置文件</li></ul><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><p><code>netstat -an | grep 3306</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 命令与工具&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>linux-shell</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Linux/linux-shell/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Linux/linux-shell/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:49:07.650Z</updated>
    
    <content type="html"><![CDATA[<p>linux shell学习笔记</p><a id="more"></a><h2 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h2><p>登录shell的时候，默认情况下bash会在几个文件中查找命令，这些文件称为启动文件或环境文件。<br>这就是我们经常设置的把某个程序的目录加到环境变量，如果你跟风，用了什么 <code>item2</code> 这样的第三方shell，并对系统做了一些修改，那么原来安装的软件默认设置的环境变量就没有了，需要把他们迁移到新的shell中。</p><pre><code>bash检查的启动文件，取决于你启动shell的方式：- 登录时作为默认登陆shell- 作为非登录shell的交互式shell- 作为运行脚本的非交互shell虽然都是进入了shell，但是它们的环境变量有区别。</code></pre><h2 id="登录shell"><a href="#登录shell" class="headerlink" title="登录shell"></a>登录shell</h2><p>这种shell就是你登陆后启动的shell。</p><p>常见启动文件：</p><ul><li>/etc/profile</li><li>$HOME/.bash_profile&nbsp;&nbsp; $HOME/.bashrc</li><li>$HOME/.bash_login&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $HOME/.profile</li></ul><p>上述是 <code>bash shell</code> 的启动文件。如果你使用了一些第三方安装了 <code>zsh</code> 应该可以在~目录找到 <code>.zshrc</code>。<br><br><code>/etc/profile</code> 是系统环境变量，剩余的是用户的，每个用户都可以编辑这些文件添加自己的环境变量。<br>这些环境变量在启动 <code>bash shell</code> 的时候生效。</p><p>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略:</p><ul><li>$HOME/.bash_profile  </li><li>$HOME/.bash_login</li><li>$HOME/.profile</li></ul><p>注意，这个列表中并没有 <code>$HOME/.bashrc文件</code>。这是因为该文件通常通过其他文件运行的，比如在有些Linux系统中 <code>./bash_profile</code> 文件会去找有没有 <code>.bashrc</code>，有的话先执行它。</p><h2 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h2><p>就是通过命令行启动shell，比如 <code>/bin/sh 如果安装zsh /bin/zsh</code> 这种情况不会访问系统变量。</p><h2 id="非交互式shell"><a href="#非交互式shell" class="headerlink" title="非交互式shell"></a>非交互式shell</h2><p>最后一种shell是非交互式shell。系统执行shell脚本时用的就是这种shell。不同的地方在于它<br>没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。<strong>非交互，理解继承，如果你要编写脚本要知道这是什么情况</strong></p><p>为了处理这种情况，<code>bash shell</code> 提供了 <code>BASH_ENV</code> 环境变量。当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。</p><p>在CentOS Linux发行版中，这个环境变量在默认情况下并未设置。如果变量未设置，printenv命令只会返回CLI提示符:<br>$ printenv BASH_ENV $</p><p>Ubuntu发行版中，变量BASH_ENV也没有被设置。记住，如果变量未设置，echo 命令会显示一个空行，然后返回CLI提示符:<br>$ echo $BASH_ENV</p><p>那如果BASH_ENV变量没有设置，shell脚本到哪里去获得它们的环境变量呢?别忘了有些shell脚本是通过启动一个子shell来执行的。子shell可以继承父shell导出过的变量。举例来说，如果父shell是登录shell，在/etc/profile、/etc/profile.d/*.sh和$HOME/.bashrc文件中<br>设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。 </p><pre><code>要记住，由父shell设置但并未导出的变量都是局部变量。子shell无法继承局部变量。对于那些不启动子shell的脚本，变量已经存在于当前shell中了。所以就算没有设置BASH_ENV，也可以使用当前shell的局部变量和全局变量。</code></pre><h2 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h2><p>现在你已经了解了各种shell进程以及对应的环境文件，找出永久性环境变量就容易多了。也可以利用这些文件创建自己的永久性全局变量或局部变量。<br>对全局环境变量来说(Linux系统中所有用户都需要使用的变量)，可能更倾向于将新的或修改过的变量设置放在 <code>/etc/profile</code> 文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。</p><p>最好是在 <code>/etc/profile.d</code> 目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变 量设置放在这个文件中。<br>在大多数发行版中，存储个人用户永久性 <code>bash shell</code> 变量的地方是 <code>$HOME/.bashrc</code> 文件。这一点适用于所有类型的shell进程。但如果设置了BASH_ENV变量，那么记住，除非它指向的是 $HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。<br>图形化界面组成部分(如GUI客户端)的环境变量可能需要在另外一些配置文件中设置，这和设置 <code>bash shell</code> 环境变量的地方不一样。<br>你可以把自己的alias设置放在 <code>$HOME/.bashrc</code> 启动文件中，使其效果永久化。</p><p>:sunny:<strong>总结：</strong><br><br>全局环境变量可以在对其作出定义的父进程所创建的子进程中使用。局部环境变量只能在定义它们的进程中使用。<br>Linux系统使用全局环境变量和局部环境变量存储系统环境信息。可以通过shell的命令行界面或者在shell脚本中访问这些信息。<code>bash shell</code> 沿用了最初 <code>Unix Bourne shell</code> 定义的那些系统环境变量，也支持很多新的环境变量。PATH环境变量定义了 <code>bash shell</code> 在查找可执行命令时的搜索目录。可以修改PATH环境变量来添加自己的搜索目录(甚至是当前目录符号)，以方便程序的运行。也可以创建自用的全局和局部环境变量。一旦创建了环境变量，它在整个shell会话过程中就都是可用的。</p><p><code>bash shell</code> 会在启动时执行几个启动文件。这些启动文件包含了环境变量的定义，可用于为每个bash会话设置标准环境变量。每次登录Linux系统，<code>bash shell</code>  都会访问/etc/profile启动文件以及3个针对每个用户的本地启动文件 <strong>:$HOME/.bash_profile、$HOME/.bash_login和$HOME/.profile。</strong> 用户可以在这些文件中定制自己想要的环境变量和启动脚本。<br>最后，我们还讨论了环境变量数组。这些环境变量可在单个变量中包含多个值。你可以通过指定索引值来访问其中的单个值，或是通过环境变量数组名来引用所有的值。</p><pre><code>重点：永久环境变量，用户环境变量，配置顺序也很重要，直接使用符号链接和配置环境变量</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux shell学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>linux-question</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Linux/question/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Linux/question/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:50:03.075Z</updated>
    
    <content type="html"><![CDATA[<p>Linux遇到的问题</p><a id="more"></a><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>export LC_CTYPE=en_US.UTF-8 在 user目录下面，.bashrc 文件加入这一行，执行 <code>source .bashrc</code></p><p>解决svn 编码错误问题。或者直接执行 LC_CTYPE=en_US.UTF-8（对本次登陆有效）</p><p>lsb_release -a  查看版本信息</p><p>本地仓库关联远程仓库：通过GitHub创建的仓库，通常会有一个README.md，在本地初始化一个目录为git  当我们想把这个目录和远程GitHub仓库关联起来的时候，实际上是合并两个分支，所以如果两个仓库有同名文件就会发生冲突，最好不要有同名文件，以确保合并分支成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux遇到的问题&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>vim</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Linux/vim/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Linux/vim/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:50:50.185Z</updated>
    
    <content type="html"><![CDATA[<p>vim使用</p><a id="more"></a><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim使用&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Locust测试工具</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Locust/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Locust/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:59:17.049Z</updated>
    
    <content type="html"><![CDATA[<p>locust 是一个简单易用的测试工具。</p><p>官方文档：<a href="https://docs.locust.io/en/stable/what-is-locust.html" target="_blank" rel="noopener">https://docs.locust.io/en/stable/what-is-locust.html</a></p><a id="more"></a><h2 id="文件描述符限制"><a href="#文件描述符限制" class="headerlink" title="文件描述符限制"></a>文件描述符限制</h2><p>如果做高并发测试，操作系统会限制一个进程能够创建的文件描述符上限制，因为每个tcp连接都需要用到一个socket句柄。</p><p><code>ulimit -n 可以查看系统允许当前用户打开的文件数限制</code> <br> <code>ulimit -n 65535 可以修改限制，本次有效果</code></p><p>根据官方文档描述来看，模拟用户数超过能打开的文件数，会出现错误。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>安装locust后，通过编写脚本，然后启动服务，此时通过浏览器端，就可以进行测试了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/10/7 下午10:46</span></span><br><span class="line"><span class="comment"># @Author  : liuzhi</span></span><br><span class="line"><span class="comment"># @File    : locustfile.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBehavior</span><span class="params">(TaskSet)</span>:</span></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/sleep"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">woek</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client.get(<span class="string">"/work"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span><span class="params">(HttpLocust)</span>:</span></span><br><span class="line">    task_set = UserBehavior</span><br><span class="line">    min_wait = <span class="number">0</span>  <span class="comment"># 单位 ms 请求等待的最小时间</span></span><br><span class="line">    max_wait = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试server</span></span><br><span class="line"><span class="comment"># locust --host=http://localhost:8888</span></span><br></pre></td></tr></table></figure></p><p>上述代码主要有两个类，UserBehavior类两个任务就是模拟当前用户的行为，sleep和work代表本次请求的用户将执行sleep和work操作，可以设置随机或同顺序，或者执行的比重。<br><code>locust --host=http://localhost:8888</code>命令启动locust，8888代表测试服务的端口。</p><h2 id="UI界面描述"><a href="#UI界面描述" class="headerlink" title="UI界面描述"></a>UI界面描述</h2><ul><li>Type：请求类型；</li><li>Name：请求路径；</li><li>requests：当前请求的数量；</li><li>fails：当前请求失败的数量；</li><li>Median：中间值，单位毫秒，一般服务器响应时间低于该值，而另一半高于该值；</li><li>Average：所有请求的平均响应时间，毫秒；</li><li>Min：请求的最小的服务器响应时间，毫秒；</li><li>Max：请求的最大服务器响应时间，毫秒；</li><li>Content Size：单个请求的大小，单位字节；10.reqs/sec：每秒钟请求的个数。</li><li>RPS: 服务器每秒能处理的请求数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;locust 是一个简单易用的测试工具。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://docs.locust.io/en/stable/what-is-locust.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.locust.io/en/stable/what-is-locust.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
      <category term="web" scheme="http://www.liuzhidream.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>HomeBrew</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Mac/HomeBrew/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Mac/HomeBrew/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:50:57.433Z</updated>
    
    <content type="html"><![CDATA[<p>用mac电脑，你需要学会HomeBrew</p><a id="more"></a><h2 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h2><p>mac 平台的包管理工具，官网地址<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令</span><br><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>记得先安装Xcode，保证安装脚步需要的环境都是可行的。</p><p>常用命令</p><table><thead><tr><th>Command</th><th style="text-align:center">Description                    </th></tr></thead><tbody><tr><td>brew info [name]</td><td style="text-align:center">查看已安装包都信息       </td></tr><tr><td>brew search [name]</td><td style="text-align:center">搜索包                 </td></tr><tr><td>brew install remove rm [name]</td><td style="text-align:center">安装包                 </td></tr><tr><td>brew uninstall [name]</td><td style="text-align:center">卸载包                 </td></tr><tr><td>brew list</td><td style="text-align:center">查看已安装的包列表       </td></tr><tr><td>brew cleanup</td><td style="text-align:center">删除文件残留            </td></tr><tr><td>brew cleanup [name]</td></tr><tr><td>brew deps [name]</td><td style="text-align:center">查看包的依赖            </td></tr><tr><td>brew outdated</td><td style="text-align:center">查看需要更新的包         </td></tr><tr><td>brew update</td><td style="text-align:center">更新包</td></tr><tr><td>brew home [name]</td><td style="text-align:center">用浏览器打开，查看包的网页信息</td></tr><tr><td>brew options [name]</td><td style="text-align:center">查看包的安装选项</td></tr><tr><td>brew services list</td><td style="text-align:center">查看homebrew安装的服务情况</td></tr><tr><td>brew services start</td><td style="text-align:center">启动服务，后面跟服务名称</td></tr><tr><td>brew services stop</td><td style="text-align:center">停止服务，后面跟服务名称</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用mac电脑，你需要学会HomeBrew&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="http://www.liuzhidream.com/categories/mac/"/>
    
    
      <category term="util" scheme="http://www.liuzhidream.com/tags/util/"/>
    
      <category term="mac" scheme="http://www.liuzhidream.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>MongoEngine</title>
    <link href="http://www.liuzhidream.com/2018/10/22/MongoDB/MongoEngine/"/>
    <id>http://www.liuzhidream.com/2018/10/22/MongoDB/MongoEngine/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.696Z</updated>
    
    <content type="html"><![CDATA[<p>文档<a href="http://docs.mongoengine.org/index.html" target="_blank" rel="noopener">http://docs.mongoengine.org/index.html</a><br>MongoEngine是Python操作MongoDB的ORM封装，可以看到很多ORM框架的影子，比如Django的ORM。底层调用了pymongo。</p><p>基本用法都是创建Document的class，得到class的instance，然后去操作instance。</p><p>MongoDB数据库是文档型的，在一个集合中，每一个文档都可以是不同的结构，不过使用了ORM，查询写入都会受到ORM的限制，当然你应该规范文档的结构。</p><p>ORM提供的功能比较有限，基础操作满足不了的，查pymongo，框架底层是基于pymongo。</p><a id="more"></a><h1 id="Document-instances"><a href="#Document-instances" class="headerlink" title="Document instances"></a>Document instances</h1><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>实例方法，用来做save前操作。</p><h2 id="Cascading-Saves"><a href="#Cascading-Saves" class="headerlink" title="Cascading Saves"></a>Cascading Saves</h2><p>If your document contains ReferenceField or GenericReferenceField objects, then by default the save() method will not save any changes to those objects.<br>如果文档包含ReferenceField或者GenericReferenceField字段，save方法不会保存他们的修改，需要在save(cascade=True)设置，save方法描述：</p><blockquote><p>:param cascade: Sets the flag for cascading saves.  You can set a default by setting “cascade” in the document <strong>meta</strong><br>暂时没有做过测试。</p></blockquote><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>执行delete，需要有id字段。</p><h2 id="Document-IDs"><a href="#Document-IDs" class="headerlink" title="Document IDs"></a>Document IDs</h2><p>文档要保存了才能访问id，通过情况不需要声明id字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; page = Page(title=&quot;Test Page&quot;)</span><br><span class="line">&gt;&gt;&gt; page.id</span><br><span class="line">&gt;&gt;&gt; page.save()</span><br><span class="line">&gt;&gt;&gt; page.id</span><br><span class="line">ObjectId(&apos;123456789abcdef000000000&apos;)</span><br></pre></td></tr></table></figure></p><p>通过设置字段的关键字来创建id，这里把email作为id，事实上id是主键的别名，pk == id 是等价的<br>? 修改了默认主键，是不是就不存在唯一表示了，既没有了ObjectId(‘123456789abcdef000000000’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class User(Document):</span><br><span class="line">...     email = StringField(primary_key=True)</span><br><span class="line">...     name = StringField()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; bob = User(email=&apos;bob@example.com&apos;, name=&apos;Bob&apos;)</span><br><span class="line">&gt;&gt;&gt; bob.save()</span><br><span class="line">&gt;&gt;&gt; bob.id == bob.email == &apos;bob@example.com&apos;</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><h1 id="Querying-the-database"><a href="#Querying-the-database" class="headerlink" title="Querying the database"></a>Querying the database</h1><p>QuerySetManager QuerySet 的概念在MongoEngine中也是适用的。<br>查询集使用本地缓存，如果想返回新的结果，使用no_cache方法。</p><h2 id="Filtering-queries"><a href="#Filtering-queries" class="headerlink" title="Filtering queries"></a>Filtering queries</h2><p>user = User.objects(name=’liu zhi’)</p><h2 id="Query-operators"><a href="#Query-operators" class="headerlink" title="Query operators"></a>Query operators</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ne – not equal to 不等于</span><br><span class="line">lt – less than 小于</span><br><span class="line">lte – less than or equal to 小于等于</span><br><span class="line">gt – greater than 大于</span><br><span class="line">gte – greater than or equal to 大于等于</span><br><span class="line">not – negate a standard check, may be used before other operators (e.g. Q(age__not__mod=5)) 否定其它条件，比如查询所有age不在[20, 30]中的 age__not__in=[20, 30]</span><br><span class="line">in – value is in list (a list of values should be provided)</span><br><span class="line">nin – value is not in list (a list of values should be provided)</span><br><span class="line">mod – value % x == y, where x and y are two provided values</span><br><span class="line">all – every item in list of values provided is in array</span><br><span class="line">size – the size of the array is</span><br><span class="line">exists – value for field exists</span><br></pre></td></tr></table></figure><h3 id="String-queries"><a href="#String-queries" class="headerlink" title="String queries"></a>String queries</h3><p>The following operators are available as shortcuts to querying with regular expressions:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exact – string field exactly matches value</span><br><span class="line">iexact – string field exactly matches value (case insensitive)</span><br><span class="line">contains – string field contains value</span><br><span class="line">icontains – string field contains value (case insensitive)</span><br><span class="line">startswith – string field starts with value</span><br><span class="line">istartswith – string field starts with value (case insensitive)</span><br><span class="line">endswith – string field ends with value</span><br><span class="line">iendswith – string field ends with value (case insensitive)</span><br><span class="line">match – performs an $elemMatch so you can match an entire document within an array</span><br></pre></td></tr></table></figure><h3 id="Geo-queries-特定字段扩展的查询"><a href="#Geo-queries-特定字段扩展的查询" class="headerlink" title="Geo queries(特定字段扩展的查询)"></a>Geo queries(特定字段扩展的查询)</h3><p>PointField, LineStringField and PolygonField字段增加了特殊的查询方法，详情看文档。</p><h3 id="Querying-lists-查询list字段的扩展"><a href="#Querying-lists-查询list字段的扩展" class="headerlink" title="Querying lists(查询list字段的扩展)"></a>Querying lists(查询list字段的扩展)</h3><h3 id="Raw-queries-pymongo查询"><a href="#Raw-queries-pymongo查询" class="headerlink" title="Raw queries(pymongo查询)"></a>Raw queries(pymongo查询)</h3><p>使用pyMongo的原生查询，document.objects(<strong>raw</strong>={‘name’: ‘liuzhi’})</p><h3 id="Limiting-and-skipping-results"><a href="#Limiting-and-skipping-results" class="headerlink" title="Limiting and skipping results"></a>Limiting and skipping results</h3><p>使用切片实现原生db.document.find().limit().skip()，get，first方法，get是检索唯一结果，如果有多个结果匹配，会触发MultipleObjectsReturned异常。get_or_create()已经弃用，最好不要使用，由于没有事务的原因，它不是安全的。</p><h3 id="Default-Document-queries-扩展模型管理器"><a href="#Default-Document-queries-扩展模型管理器" class="headerlink" title="Default Document queries(扩展模型管理器)"></a>Default Document queries(扩展模型管理器)</h3><p>相当于对objects重写，使用特定的装饰器，方法名字可以自定义，这样可以做到使用原始的查询原始数据，使用自定义，查询自定义数据，比如自定义的只查询状态是正常的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class BlogPost(Document):</span><br><span class="line">    title = StringField()</span><br><span class="line">    date = DateTimeField()</span><br><span class="line"></span><br><span class="line">    @queryset_manager</span><br><span class="line">    def objects(doc_cls, queryset):</span><br><span class="line">        # This may actually also be done by defining a default ordering for</span><br><span class="line">        # the document, but this illustrates the use of manager methods</span><br><span class="line">        return queryset.order_by(&apos;-date&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="Custom-QuerySets-封装查询集方法"><a href="#Custom-QuerySets-封装查询集方法" class="headerlink" title="Custom QuerySets(封装查询集方法)"></a>Custom QuerySets(封装查询集方法)</h3><p>把某些特定查询条件组合，通过新的方法获取查询集，可以给多个文档模型使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AwesomerQuerySet(QuerySet):</span><br><span class="line"></span><br><span class="line">    def get_awesome(self):</span><br><span class="line">        return self.filter(awesome=True)</span><br><span class="line"></span><br><span class="line">class Page(Document):</span><br><span class="line">    meta = &#123;&apos;queryset_class&apos;: AwesomerQuerySet&#125;</span><br><span class="line"></span><br><span class="line"># To call:</span><br><span class="line">Page.objects.get_awesome()</span><br></pre></td></tr></table></figure></p><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p>MongoDB的聚合方法<br>objects 方法</p><ul><li>count() 返回QuerySet() 数目</li><li>sun(‘quantitu’) 求和</li><li>average() 求平均</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文档&lt;a href=&quot;http://docs.mongoengine.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.mongoengine.org/index.html&lt;/a&gt;&lt;br&gt;MongoEngine是Python操作MongoDB的ORM封装，可以看到很多ORM框架的影子，比如Django的ORM。底层调用了pymongo。&lt;/p&gt;
&lt;p&gt;基本用法都是创建Document的class，得到class的instance，然后去操作instance。&lt;/p&gt;
&lt;p&gt;MongoDB数据库是文档型的，在一个集合中，每一个文档都可以是不同的结构，不过使用了ORM，查询写入都会受到ORM的限制，当然你应该规范文档的结构。&lt;/p&gt;
&lt;p&gt;ORM提供的功能比较有限，基础操作满足不了的，查pymongo，框架底层是基于pymongo。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://www.liuzhidream.com/2018/10/22/MongoDB/MongoDB/"/>
    <id>http://www.liuzhidream.com/2018/10/22/MongoDB/MongoDB/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><a id="more"></a><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/mongodb/MongoDB.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="ObjectID字段"><a href="#ObjectID字段" class="headerlink" title="ObjectID字段"></a>ObjectID字段</h2><p><code>ObjectId</code>构成我们使用<code>MySQL</code>等关系型数据库时，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，<code>MongoDB</code>采用了一个称之为<code>ObjectId</code>的类型来做主键。<code>ObjectId</code>是一个12字节的<code>BSON</code>类型字符串。按照字节顺序，依次代表：</p><ul><li>4字节：UNIX时间戳</li><li>3字节：表示运行MongoDB的机器</li><li>2字节：表示生成此_id的进程</li><li>3字节：由一个随机数开始的计数器生成的值</li></ul><p><code>MongoDB</code>对<code>ObjectId</code>对象提供了<code>getTimestamp()</code>方法来获取<code>ObjectId</code>的时间。</p><p>这里不使用自增长<code>id</code>主要是因为<code>MongoDB</code>是分布式数据库，在并发插入的时候需要维护全局的唯一ID，传统的像MySQL是单机版的，使用自增长ID可以了，处理多条数据插入加锁就行了，虽然MySQL也可以部署集群，但是这种情况ID就没用了，需要自定义全局唯一字段。</p><p><code>ObjectID</code>是字段类型，通常来说它是按照默认规则来生产的，文档中的其它字段也可以使用这种字段类型。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li>查询全部：<code>db.document.find({})</code></li><li>查询字段是对象的：<code>db.document.find({&#39;id_card.idcard_type&#39;: &#39;身份证&#39;})</code></li></ul><h3 id="projection"><a href="#projection" class="headerlink" title="projection"></a>projection</h3><p>该参数指明要显示的字段或者要隐藏的字段</p><ul><li><code>db.document.find({}, {&#39;name&#39;:1})</code>  返回结果只显示name字段</li><li><code>db.document.find({}, {&#39;name&#39;:0})</code>  返回结果把name字段隐藏了，其它展示出来</li></ul><h2 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h2><p>见文档</p><h2 id="数据库引用"><a href="#数据库引用" class="headerlink" title="数据库引用"></a>数据库引用</h2><p>分为手动引用和DBRefs，手动引用就是自己建立关系，然后查多次或关联查询。</p><p>使用方法：</p><ul><li>$ref：集合名称</li><li>$id：引用的id</li><li>$db:数据库名称，可选参数</li></ul><p>产品document中引用attr_data，attr_data是产品属性document</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line">p = Point(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line">x, y = p</span><br><span class="line">print(x, y)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;   </span><br><span class="line">    <span class="string">"_id"</span>:ObjectId(<span class="string">"53402597d852426020000002"</span>),</span><br><span class="line">    <span class="string">"product_name"</span>: <span class="string">"卫龙辣条"</span>,</span><br><span class="line">    <span class="string">"attr_data"</span>: &#123;</span><br><span class="line">        <span class="string">"$ref"</span>: <span class="string">"product_attr"</span>,</span><br><span class="line">        <span class="string">"$id"</span>: ObjectId(<span class="string">"534009e4d852427820000002"</span>),</span><br><span class="line">        <span class="string">"$db"</span>: <span class="string">"testdata"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>product_attr document</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span> : ObjectId(<span class="string">"534009e4d852427820000002"</span>),</span><br><span class="line">   <span class="attr">"size"</span>: <span class="string">"大"</span>,</span><br><span class="line">   <span class="attr">"weight"</span>: <span class="string">"100g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var product = db.products.findOne(&#123;<span class="string">"product_name"</span>:<span class="string">"卫龙辣条"</span>&#125;)</span><br><span class="line">var dbRef = product.attr_data</span><br><span class="line">db[dbRef.<span class="variable">$ref</span>].findOne(&#123;<span class="string">"_id"</span>:(dbRef.<span class="variable">$id</span>)&#125;)</span><br><span class="line">结果：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_id"</span> : ObjectId(<span class="string">"534009e4d852427820000002"</span>),</span><br><span class="line">   <span class="string">"size"</span>: <span class="string">"大"</span>,</span><br><span class="line">   <span class="string">"weight"</span>: <span class="string">"100g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>mongodb不支持事务，所以，在你的项目中应用时，要注意这点。无论什么设计，都不要要求mongodb保证数据的完整性。</p><p>但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。</p><p>所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。</p><h3 id="findAndModify方法"><a href="#findAndModify方法" class="headerlink" title="findAndModify方法"></a>findAndModify方法</h3><p>该方法将查询一些结果，如果查询到，执行更新。这些语句都是写在一个查询中的，并且使用对应的原子操作方法，让整个findAndModify实现原子性操作。<br>如果分开操作，就是先查询，再修改，在这两个操作之间，如果有人购买了产品，导致库存不足，那么修改操作就会导致数据库数据一致性问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">book = &#123;</span><br><span class="line">          _id: 123456789,</span><br><span class="line">          title: &quot;MongoDB: The Definitive Guide&quot;,</span><br><span class="line">          author: [ &quot;Kristina Chodorow&quot;, &quot;Mike Dirolf&quot; ],</span><br><span class="line">          published_date: ISODate(&quot;2010-09-24&quot;),</span><br><span class="line">          pages: 216,</span><br><span class="line">          language: &quot;English&quot;,</span><br><span class="line">          publisher_id: &quot;oreilly&quot;,</span><br><span class="line">          available: 3,</span><br><span class="line">          checkout: [ &#123; by: &quot;joe&quot;, date: ISODate(&quot;2012-10-15&quot;) &#125; ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>对于上述的book模型，available是我们的判别标志，当它大于0的时候，说明是可以操作的(比如借书)，这部分就是查询，查询成功了，就可以去执行要更新的操作。<br>db.document.findAndModify({<br>    query: {},<br>    update: {}<br>})<br>更新操作应该使用原子操作命令</p><p> $set:用来指定一个键并更新键值，若键不存在并创建。</p><p>{ $set : { field : value } }<br>  $unset:用来删除一个键</p><p>{ $unset : { field : 1} }<br>  $inc:可以对文档的某个值为数字型的键进行增减操作 </p><p>{ $inc : { field : value } }<br>  $push：把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数据类型加进去。</p><p>{ $push : { field : value } }<br>  $pushAll:同$push,只是一次可以追加到多个值到一个数组字段内。</p><p>{ $pushAll : { field : value_array } }<br>  $pull:从数组field内删除一个等于value值</p><p>{ $pull : { field : _value } }<br>  $addToSet：增加一个值到数组内，而且只有当这个值不在数组内才增加。<br>  $pop：删除数组的第一个或最后一个元素<br>{ $pop : { field : 1 } }<br>  $rename：修改字段名称<br>{ $rename : { old_field_name : new_field_name } }<br>  $bit：位操作，integer类型<br>{$bit : { field : {and : 5}}}<br>  偏移操作符</p><blockquote><p>t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 3 }, { “by” : “jane”, “votes” : 7 } ] }</p></blockquote><blockquote><p>t.update( {‘comments.by’:’joe’}, {$inc:{‘comments.$.votes’:1}}, false, true )</p></blockquote><blockquote><p>t.find() { “_id” : ObjectId(“4b97e62bf1d8c7152c9ccb74”), “title” : “ABC”, “comments” : [ { “by” : “joe”, “votes” : 4 }, { “by” : “jane”, “votes” : 7 } ] }</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MongoDB通过索引加快查询速度，索引运行在内存中，数据库的操作也需要对索引进行操作，索引超过内存的情况，将会删除一些索引。最好只对大数据文档创建索引。</p><p>索引不能被以下的查询使用：</p><ul><li>正则表达式及非操作符，如 $nin, $not, 等</li><li>算术运算符，如 $mod, 等</li><li>$where 子句</li></ul><p>所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。</p><h3 id="最大范围"><a href="#最大范围" class="headerlink" title="最大范围"></a>最大范围</h3><ul><li>集合中索引不能超过64个</li><li>索引名的长度不能超过128个字符</li><li>一个复合索引最多可以有31个字段</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>MySQL install-problem</title>
    <link href="http://www.liuzhidream.com/2018/10/22/MySql/install-problem/"/>
    <id>http://www.liuzhidream.com/2018/10/22/MySql/install-problem/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>安装MySQL遇到的问题</p><a id="more"></a><h1 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h1><p>安装软件总会遇到很多问题，很多问题仅在当时情况下出现，其实解决的思路都是大致的，多看报错和官方文档。</p><h2 id="mysql-sock-无法被创建"><a href="#mysql-sock-无法被创建" class="headerlink" title="mysql.sock 无法被创建"></a>mysql.sock 无法被创建</h2><p>mysql 的链接需要借助这个套接字，如果不小心删除了，会导致服务无法运行</p><p>mac mysql 8.0.12安装教程</p><p>本次中Mac上使用非root账户来安装mysql，终于装好了。主要原因在于8.0版本配置（说是没有配置，但还说有，通过brew安装的可以在 /usr/local/etc 目录下找到配置文件，linux包管理软件安装的东西一般都在这个目录）没有配置东西，用的是默认的，这导致要创建链接的socket的时候没有指定目录使用了默认的 /tmp，没有执行/tmp的权限或者是用户所属等问题导致创建失败（并不是很建议去操作这个文件，有些人直接运行成功了，可能和个人的系统有很大关系）。无法创建mysql服务</p><p>大概解决思路<br>mysql安装会在data目录下生成很多东西，如果没有或生成的不对，可以把目录删除了，通过启动服务来生成（我就说这么干的），然后配置了socket的客户端和服务端的路径，路径指向data即可（以为mysql的data是有执行权限的），这样服务就启动成功了，然后安装brew指导，创建root用户。<br>配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">socket=/usr/local/lnmp/mysql/data/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line">socket=/usr/local/lnmp/mysql/data/mysql.sock</span><br></pre></td></tr></table></figure></p><p>两个都要指定</p><p>mysql.sock 无法创建，问题可能是多方面的，在data目录下，会生成 .err后缀的文件，可以在里面查看错误信息，然后结合经验来解决问题。  还有就是data目录下数据不对，这个目录应该有很多文件的，但是我一直没有，我通过删除，再执行服务成功生成了，感觉并不是很正确的解决思路。</p><p>mysqld –help –verbose | less<br>这个目录可以列出mysql的一些信息，包括配置文件可能的路径，一些已经配置的参数。</p><p>最后，使用编译源代码的方式，估计是最后的活路。</p><h2 id="报错：MySQL-Illegal-mix-of-collations-for-operation-‘like’"><a href="#报错：MySQL-Illegal-mix-of-collations-for-operation-‘like’" class="headerlink" title="报错：MySQL Illegal mix of collations for operation ‘like’"></a>报错：MySQL Illegal mix of collations for operation ‘like’</h2><p>MySQL Illegal mix of collations for operation ‘like’</p><p>在 MySQL 5.5 以上, 若字段类型 Type 是 time,date,datetime </p><p>在 select时如果使用 like ‘%中文%’ 会出现 Illegal mix of collations for operation ‘like’</p><p>在编程时要对每个字段进行查找，在执行时可能就会出现时间字段 like ‘%中文%’ 这种语法，在旧版的 MySQL 是不会出现错误的。</p><p>升到 MySQL 5.5 以上, 必需改成 like binary ‘%中文%’ 即可避免出现错误。</p><p>在python代码中，解决方案为使用cast(fields, CHAR)转换类型后再做like.(高mysql版本中使用like的使用，非字符类型和字符类型混合在filter条件中做like，就会导致这个问题)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装MySQL遇到的问题&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Iterm2</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Mac/Iterm2/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Mac/Iterm2/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:51:00.995Z</updated>
    
    <content type="html"><![CDATA[<p>不错的终端软件</p><a id="more"></a><h2 id="移动一个单词"><a href="#移动一个单词" class="headerlink" title="移动一个单词"></a>移动一个单词</h2><p>在Profile – keys下，找到如同的原配置信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/Mac/iterm2_key_1.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><br>其实这是已有的功能，不过Mac默认的快捷键被占用了，修改成我们习惯的。<br>分别修改option+←和option+→的映射，选择Action为“Send Escape Sequence”，然后输入“b”和“f”即可。</p><h2 id="配置远程ssh登陆"><a href="#配置远程ssh登陆" class="headerlink" title="配置远程ssh登陆"></a>配置远程ssh登陆</h2><p>使用脚本传参数的方式登陆，先准备脚本，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> timeout 30</span><br><span class="line">spawn ssh -p [lindex <span class="variable">$argv</span> 0] [lindex <span class="variable">$argv</span> 1]@[lindex <span class="variable">$argv</span> 2]</span><br><span class="line">expect &#123;</span><br><span class="line">        <span class="string">"(yes/no)?"</span></span><br><span class="line">        &#123;send <span class="string">"yes\n"</span>;exp_continue&#125;</span><br><span class="line">        <span class="string">"password:"</span></span><br><span class="line">        &#123;send <span class="string">"[lindex <span class="variable">$argv</span> 3]\n"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p>在本地创建这么一个文件 <code>*.sh</code><br>然后去配置iterm2，如下图，用绝对路径指向这个文件，后面加上参数。 端口，用户，IP，password。<br>举例：<br><code>/Users/liuzhi/Documents/LinuxServer/liuzhiTX.sh 22 root 123.207.***.202 12345</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/Mac/iterm2_ssh.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th style="text-align:left">Command</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td style="text-align:left">垂直分屏</td><td style="text-align:left">command + d </td></tr><tr><td style="text-align:left">水平分屏</td><td style="text-align:left">command + shift + d </td></tr><tr><td style="text-align:left">切换屏幕</td><td style="text-align:left">command + option + 方向键 command + [ 或 command + ] </td></tr><tr><td style="text-align:left">查看历史命令</td><td style="text-align:left">command + ; </td></tr><tr><td style="text-align:left">查看剪贴板历史</td><td style="text-align:left">command + shift + h </td></tr><tr><td style="text-align:left">新建标签</td><td style="text-align:left">command + t </td></tr><tr><td style="text-align:left">关闭标签</td><td style="text-align:left">command + w </td></tr><tr><td style="text-align:left">切换标签</td><td style="text-align:left">command + 数字 command + 左右方向键 </td></tr><tr><td style="text-align:left">切换全屏</td><td style="text-align:left">command + enter </td></tr><tr><td style="text-align:left">查找</td><td style="text-align:left">command + f </td></tr><tr><td style="text-align:left">清除当前行</td><td style="text-align:left">ctrl + u </td></tr><tr><td style="text-align:left">到行首</td><td style="text-align:left">ctrl + a </td></tr><tr><td style="text-align:left">到行尾</td><td style="text-align:left">ctrl + e </td></tr><tr><td style="text-align:left">前进后退</td><td style="text-align:left">ctrl + f/b (相当于左右方向键) </td></tr><tr><td style="text-align:left">上一条命令</td><td style="text-align:left">ctrl + p </td></tr><tr><td style="text-align:left">搜索命令历史</td><td style="text-align:left">ctrl + r </td></tr><tr><td style="text-align:left">删除当前光标的字符</td><td style="text-align:left">ctrl + d </td></tr><tr><td style="text-align:left">删除光标之前的字符</td><td style="text-align:left">ctrl + h </td></tr><tr><td style="text-align:left">删除光标之前的单词</td><td style="text-align:left">ctrl + w </td></tr><tr><td style="text-align:left">删除到文本末尾</td><td style="text-align:left">ctrl + k </td></tr><tr><td style="text-align:left">交换光标处文本</td><td style="text-align:left">ctrl + t </td></tr><tr><td style="text-align:left">清屏1</td><td style="text-align:left">command + r </td></tr><tr><td style="text-align:left">清屏2</td><td style="text-align:left">ctrl + l </td></tr><tr><td style="text-align:left">⌘ + f</td><td style="text-align:left">所查找的内容会被自动复制 </td></tr><tr><td style="text-align:left">⌘ + r</td><td style="text-align:left">clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 </td></tr><tr><td style="text-align:left">ctrl + u</td><td style="text-align:left">清空当前行，无论光标在什么位置 </td></tr><tr><td style="text-align:left">输入开头命令后 按 ⌘ +</td><td style="text-align:left">会自动列出输入过的命令 </td></tr><tr><td style="text-align:left">⌘ + shift + h</td><td style="text-align:left">会列出剪切板历史 </td></tr></tbody></table><p>复制：</p><p>选中即复制：iterm2有2种好用的选中即复制模式。</p><p>一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。</p><p>另一种是无鼠标模式，command+f，弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab（实测好像没用），则自动将查找内容的左边选中并复制。</p><p>输入command+shift+h，iterm2将自动列出剪切板的历史记录，这个历史要使用过无鼠标模式才行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不错的终端软件&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="http://www.liuzhidream.com/categories/mac/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="util" scheme="http://www.liuzhidream.com/tags/util/"/>
    
      <category term="mac" scheme="http://www.liuzhidream.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>sqlAlchemy-query</title>
    <link href="http://www.liuzhidream.com/2018/10/22/MySql/sqlAlchemy-query/"/>
    <id>http://www.liuzhidream.com/2018/10/22/MySql/sqlAlchemy-query/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 的 Python 版 ORM</p><a id="more"></a><h1 id="sqlAlchemy-查询操作"><a href="#sqlAlchemy-查询操作" class="headerlink" title="sqlAlchemy 查询操作"></a>sqlAlchemy 查询操作</h1><p>notin_<br>in_<br>or_</p><h2 id="批量插入（非orm方式）"><a href="#批量插入（非orm方式）" class="headerlink" title="批量插入（非orm方式）"></a>批量插入（非orm方式）</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MemberCouponRecord 为要操作的表名</span></span><br><span class="line">db.session.execute(</span><br><span class="line">    MemberCouponRecord.__table__.insert(),</span><br><span class="line">    [&#123;<span class="string">'coupon_id'</span>: <span class="string">'NO0001'</span>, <span class="string">'member_id'</span>: <span class="number">0002</span>, <span class="string">'update_time'</span>: get_current_time(), <span class="string">'create_by'</span>: get_op_user_name()&#125; <span class="keyword">for</span> item <span class="keyword">in</span> item_data]</span><br><span class="line">)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 的 Python 版 ORM&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>计算机知识补充</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Other/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Other/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:01:06.090Z</updated>
    
    <content type="html"><![CDATA[<p>计算机知识补充</p><a id="more"></a><h2 id="为什么不要用记事本来写代码？"><a href="#为什么不要用记事本来写代码？" class="headerlink" title="为什么不要用记事本来写代码？"></a>为什么不要用记事本来写代码？</h2><p>可能有人会怪windows怎么那么傻，一个\n不就可以了，为什么要用\r\n呢，给我们造成了多大的麻烦。其实这也不能怪windows。使用\r\n的历史可以追溯到遥远的19世纪。 那时候发明的打字机主要结构是一个实心圆筒+排列成菊花状的字模。纸张被牢牢地固定在圆筒的表面上。当我们按下一个字母的时候，机械装置引动字模”飞”向纸张，同时圆筒前的色带升起，用力地印下去，于是纸张上面就出现一个字了。印完之后，机械装置自动地让圆筒向左移动一个字母格子，方便打印下一个字符。打完一行之后，左手边上有一个摇杆，摇一下，圆筒就可以滚动一个行距，这是换行。不过，因为打字的时候圆筒总会不断地向左移动，所以打字员还需要用力地把圆筒推回右边，这就是传说中的回车了。在计算机里常见的换行操作在打字机里需要换行+回车两个操作。自然，计算机里不用这么麻烦，不过windows喜欢看起来更兼容一点。于是换行就成了\r\n了。</p><h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><p>“猴子补丁”就是指，在函数或对象已经定义之后，再去改变它们的行为。</p><h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><p>Scale Out（也就是Scale horizontally）横向扩展，向外扩展</p><p>Scale Up（也就是Scale vertically）纵向扩展，向上扩展</p><p>无论是Scale Out，Scale Up，Scale In，实际上就是一种架构的概念，这些概念用在存储上可以，用在数据库上，网络上一样可以。</p><p>简单比喻下Scale out和Scale up，帮助我们理解：</p><ul><li>Scale Out，比如：我们向原有的web、邮件系统添加一个新机器。</li><li>Scale UP，比如：我们向原有的机器添加CPU、内存。</li></ul><h2 id="斜杠与反斜杠"><a href="#斜杠与反斜杠" class="headerlink" title="斜杠与反斜杠"></a>斜杠与反斜杠</h2><p>“\”与“/”斜杠与反斜杠，只要知道，在windows路径里面用反斜杠，其它一般都是斜杠</p><p>\ 转义，Python中加 r 不转义 r ‘\t’ 结果是 \t</p><h2 id="秒的定义"><a href="#秒的定义" class="headerlink" title="秒的定义"></a>秒的定义</h2><p>国际单位制词头经常与秒结合以做更细微的划分，例如ms（毫秒，千分之一秒）、μs（微秒，百万分之一秒）和ns（纳秒，十亿分之一秒）。虽然国际单位制词头虽然也可以用于扩增时间，例如Ks（千秒）、Ms（百万秒）和Gs（十亿秒），但实际上很少这样子使用，大家都还是习惯用60进制的分、时和24进制的日做为秒的扩充。</p><h2 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h2><p>csv文件，使用逗号分隔，这种格式的文本可以导到excel</p><h2 id="名词缩写"><a href="#名词缩写" class="headerlink" title="名词缩写"></a>名词缩写</h2><p>进程间通信（Inter Process Communication，IPC）</p><p>POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）这个标准制定了一些通用的东西，方便大家在实现的时候做到通用性，那么移植就不会有太大的问题了</p><p>SMP：对称多处理结构，一个计算机上使用多个CPU，而内存，总线是共享的</p><p>conditional requests : 条件请求，可以改变请求的资源</p><p>Cross Origin Resource Sharing（CORS）跨域资源共享</p><p>fd(file descriptor) 文件描述符</p><p>oom (out of memory) 内存溢出 <code>oom killer</code> 这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM！</p><h2 id="utf-8-和-unicode"><a href="#utf-8-和-unicode" class="headerlink" title="utf-8 和 unicode"></a>utf-8 和 unicode</h2><p>必须知道的是，utf-8是unicode的一种实现方式，比如utf-16也是。互联网多采用utf-8，之所以出现unicode的多种实现，是因为为了表数多字符的二进制，需要使用多个字节，这带来的存储的不便利（比如在Unicode中英文用一个字节就行了，汉字会占用2个或3个等，如果大家都统一成4字节，倒是存储解析都可以了，但是大大浪费了空间，utf-8这种实现就是一种灵活的可变字节数的编码，如果符号只用一个字节，那么存储就是一个，需要多个就多个。如何解析呢？利用第一个字节的前几位表示这个符合占用几个字节，这样解析的时候就知道这次是拿几个字节出来解码成对应的符号，大大利用了空间。）<br>编码过程：2条。1）单字节首位是0，其它7位是Unicode码。2）多字节，对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符  严     </span><br><span class="line">Unicode   100    111000   100101</span><br><span class="line">utf-8     111  0 (0100) 10 (111000) 10 (100101)    通过括号和空格分割，可以看道字符是如何从Unicode到utf-8的。</span><br></pre></td></tr></table></figure><p>关于字节序：Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p><p>如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。</p><h2 id="事件句柄"><a href="#事件句柄" class="headerlink" title="事件句柄"></a>事件句柄</h2><p>事件句柄又称为事件处理函数。它需要被赋值，比如将一个函数赋值给事件句柄。<br>当特定事件发生的时候，就去检查事件句柄有没有被赋值，如果有，则执行事件<br>句柄（执行该函数）</p><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><p>函数的名称及其参数类型组合在一起，就定义了一个唯一的特性，称为函数签名。（不包括返回类型）</p><p>在编写包含函数调用的语句时，编译器就会使用该调用创建一个函数签名。再把它与函数原型/或定义中可用的函数签名集比较。如果找到匹配的函数名，就建立所调用的函数。(c++的解释)</p><p>函数签名对象，表示调用函数的方式，即定义了函数的输入和输出。在Python中，可以使用标准库inspect的一些方法或类，来操作或创建函数签名。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>多个相同函数名，不同的参数个数或者类型的形式叫做函数的重载。</p><h2 id="arp-a"><a href="#arp-a" class="headerlink" title="arp -a"></a>arp -a</h2><p>这个Windows命令中有一个类型的概念</p><p>类型：动态的是说过一定时间如果这个mac地址没有用到过，就会被删掉；静态的会被永久保留</p><h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机知识补充&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://www.liuzhidream.com/categories/other/"/>
    
    
      <category term="learn" scheme="http://www.liuzhidream.com/tags/learn/"/>
    
      <category term="other" scheme="http://www.liuzhidream.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>yaml</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Other/yaml/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Other/yaml/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:01:17.162Z</updated>
    
    <content type="html"><![CDATA[<p>yaml 语言</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>YAML 支持的数据结构有三种</p><p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p><p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p><p>纯量（scalars）：单个的、不可再分的值</p><h2 id="python-操作"><a href="#python-操作" class="headerlink" title="python 操作"></a>python 操作</h2><p>load  和 dump 方法<br>load 加载 yaml 文件   dump将数据写入yaml文件</p><p>先创建一个文件对象 ，并加载 <code>stream = file(&#39;example.yaml&#39;,&#39;r&#39;) dicts = yaml.load(stream)</code> 这个时候，我们就可以去取值了</p><p>举例：<br>yaml文件为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">www.baidu.com</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">www.taobao.com</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">vlcoa.inruan.com</span></span><br></pre></td></tr></table></figure><p>这个属于数组，取值时用索引就可以了 <code>print dicts[&#39;url&#39;][1]</code> 结果是 <code>www.taobao.com</code></p><p>yaml文件为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="attr">        top1:</span></span><br><span class="line">            <span class="string">python</span></span><br><span class="line"><span class="attr">        top2:</span></span><br><span class="line">               <span class="string">java</span></span><br></pre></td></tr></table></figure><p>属于对象，language是一个字典 <code>print dicts[&#39;language&#39;][&#39;top1&#39;]</code> 结果 <code>python</code></p><p>比较简单的配置文件：</p><pre><code>settime: 5     </code></pre><p>load后，<code>dicts[settime]</code>，就可以取到5了，冒号后面一点要有空格，使用数组就可以使用索引去取值，而且dicts到的是列表，可以去迭代参数，必须要用  ‘-‘ 加空格的形式，不能使用Tab键来缩进，一定要用空格。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yaml 语言&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="http://www.liuzhidream.com/categories/other/"/>
    
    
      <category term="other" scheme="http://www.liuzhidream.com/tags/other/"/>
    
      <category term="yaml" scheme="http://www.liuzhidream.com/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Python-socket</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Python-socket/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Python-socket/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:03:47.434Z</updated>
    
    <content type="html"><![CDATA[<p>python网络编程笔记</p><a id="more"></a><h2 id="EAGAIN"><a href="#EAGAIN" class="headerlink" title="EAGAIN"></a>EAGAIN</h2><p>当客户通过Socket提供的send函数发送大的数据包时，就可能返回一个EAGAIN的错误。该错误产生的原因是由于 send 函数中的size变量大小超过了tcp_sendspace的值。tcp_sendspace定义了应用在调用send之前能够在kernel中缓存的数据量。当应用程序在socket中设置了O_NDELAY或者O_NONBLOCK属性后，如果发送缓存被占满，send就会返回EAGAIN的错误。 </p><h2 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h2><p>accept()是在一个套接口接受的一个连接。accept（）是c语言中网络编程的重要的函数，本函数从s的等待连接队列中抽取第一个连接，创建一个与s同类的新的套接口并返回句柄</p><h2 id="socket-listen-backlog"><a href="#socket-listen-backlog" class="headerlink" title="socket.listen(backlog)"></a>socket.listen(backlog)</h2><p>开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p><p>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5<br>这个值不能无限大，因为要在内核中维护连接队列。</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>close方法可以释放一个连接的资源，但是不是立即释放，如果想立即释放，那么在close之前使用shutdown方法shut_rd() ——-关闭接受消息通道shut_wr()——–关闭发送消息通道shut_rdwr()——-连个通道都关闭使用：在close()之前加上shutdown(num)即可  </p><p>[shut_rd(), shut_wr(), shut_rdwr()分别代表num 为0  1  2 ]（但是测试过close()关闭，发现如果关闭后，那么accept()得到的connection就马上不能用了[提示不能在非套接字上]）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python网络编程笔记&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PythonUtil</title>
    <link href="http://www.liuzhidream.com/2018/10/22/PythonUtil/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/PythonUtil/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:06:05.888Z</updated>
    
    <content type="html"><![CDATA[<p>python 偷懒小工具，通过编写脚本实现日常功能</p><a id="more"></a><h2 id="markdown-table-语法生成"><a href="#markdown-table-语法生成" class="headerlink" title="markdown table 语法生成"></a>markdown table 语法生成</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">markdown 的table语法格式 自动生成代码，错误的地方需要手动处理一下，中文因为字符占位问题，无法做到统一格式化</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">op_str = <span class="string">'''</span></span><br><span class="line"><span class="string">v-bind ：动态绑定数据。简写为“:” 。=&gt; 以后的:class="&#123;red:boolean&#125;"</span></span><br><span class="line"><span class="string">v-on ：绑定时间监听器。简写为“@”，例：@click="xxx"；</span></span><br><span class="line"><span class="string">v-text ：更新数据，会覆盖已有结构。类似&#123;&#123; msg &#125;&#125; ；</span></span><br><span class="line"><span class="string">v-show ：根据值的真假，切换元素的display属性；</span></span><br><span class="line"><span class="string">v-if ：根据值的真假，切换元素会被销毁、重建； =&gt; 在dom中已消失</span></span><br><span class="line"><span class="string">v-else-if ：多条件判断，为真则渲染；</span></span><br><span class="line"><span class="string">v-else ：条件都不符合时渲染；</span></span><br><span class="line"><span class="string">v-for ：基于源数据多次渲染元素或模块；</span></span><br><span class="line"><span class="string">v-model ：在表单控件元素（input等）上创建双向数据绑定（数据源）；</span></span><br><span class="line"><span class="string">v-pre ：跳过元素和子元素的编译过程；</span></span><br><span class="line"><span class="string">v-once ：只渲染一次，随后数据更新也不重新渲染；</span></span><br><span class="line"><span class="string">v-cloak ：隐藏未编译的Mustache语法，在css中设置[v-cloak]&#123;display:none;&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">_op_str = op_str.split(<span class="string">'\n'</span>)</span><br><span class="line">_op_str.pop()</span><br><span class="line">out_str = <span class="string">''</span></span><br><span class="line">max_str_len = len(<span class="string">'v-else-if'</span>)  <span class="comment"># pop(key[, default])</span></span><br><span class="line">space = <span class="string">' '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> _op_str:</span><br><span class="line">    tmp = item.split(<span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">if</span> tmp[<span class="number">0</span>] == <span class="string">''</span>:</span><br><span class="line">        tmp_str = <span class="string">"| Command&#123;space&#125; | Description \n"</span>.format(space=space * (max_str_len - len(<span class="string">'Command'</span>)))</span><br><span class="line">        tmp_str += <span class="string">"| &#123;a&#125; | :&#123;b&#125;: \n"</span>.format(a=<span class="string">'-'</span> * max_str_len, b=<span class="string">'-'</span> * (max_str_len - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp_str = <span class="string">"| &#123;a&#125;&#123;space&#125; | &#123;b&#125; \n"</span>.format(a=tmp[<span class="number">0</span>], b=<span class="string">''</span>.join(tmp[<span class="number">1</span>:]), space=space * (max_str_len - len(tmp[<span class="number">0</span>])))</span><br><span class="line">    out_str += tmp_str</span><br><span class="line"></span><br><span class="line">print(out_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(len('Inheritor'))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 偷懒小工具，通过编写脚本实现日常功能&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python常用方法</title>
    <link href="http://www.liuzhidream.com/2018/10/22/PythonUtil/common_tool/"/>
    <id>http://www.liuzhidream.com/2018/10/22/PythonUtil/common_tool/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:05:12.194Z</updated>
    
    <content type="html"><![CDATA[<p>记录python常用方法</p><a id="more"></a><h2 id="获取文件所在目录"><a href="#获取文件所在目录" class="headerlink" title="获取文件所在目录"></a>获取文件所在目录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">print(path)</span><br></pre></td></tr></table></figure><h2 id="dict扩展"><a href="#dict扩展" class="headerlink" title="dict扩展"></a>dict扩展</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrDict</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    不继承dict，实现一个dict，实例化使用关键字参数的形式：AttrDict(a=1, b=2)</span></span><br><span class="line"><span class="string">    __getitem__，__setitem__，__delitem__称为容器方法，就是_dict['a']这种操作的</span></span><br><span class="line"><span class="string">    拦截，而__getattribute__（访问属性先执行这个，然后执行__getattr__），</span></span><br><span class="line"><span class="string">    __setattr__这种才是属性拦截，通过把关键字参数赋值给__dict__，实现了可以通过</span></span><br><span class="line"><span class="string">    _dict.a 或 _dict['a'] 的形式访问字典键值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__setattr__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__delattr__(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">attr_dict = AttrDict(a=<span class="number">2</span>, b=<span class="number">3</span>)</span><br><span class="line">print(attr_dict[<span class="string">'a'</span>])</span><br><span class="line">print(attr_dict.a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(attr_dict.get('a')) 报错的，这是字典的方法，这个类没有继承字典</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrDict2</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    继承dict，扩展链式操作</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'init a dict'</span>)</span><br><span class="line">        <span class="comment"># dict.__init__(self, *args, **kwargs) # 同下super的效果</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 继承dict的对象，对象的实例就是一个字典，print(_dict)可以看到，既然如此，把这个</span></span><br><span class="line">        <span class="comment"># 字典给到__dict__，那么对象的属性就有了</span></span><br><span class="line">        self.__dict__ = self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_dict = AttrDict2()</span><br><span class="line">_dict[<span class="string">'a'</span>] = <span class="number">33</span></span><br><span class="line">print(_dict)</span><br><span class="line">print(_dict.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果再次执行_dict['b'] = 44，已经不执行__init__方法了，但是self.__dict__ = self已经关联了，</span></span><br><span class="line"><span class="comment"># dict做为可变变量类型，同样更新了__dict__</span></span><br><span class="line">_dict[<span class="string">'b'</span>] = <span class="number">44</span></span><br><span class="line">print(_dict)</span><br><span class="line">print(_dict.__dict__)</span><br><span class="line">print(_dict.a, _dict.b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录python常用方法&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Core-python-programming 读书笔记</title>
    <link href="http://www.liuzhidream.com/2018/10/22/ReadBook/Core-python-programming/"/>
    <id>http://www.liuzhidream.com/2018/10/22/ReadBook/Core-python-programming/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:07:27.898Z</updated>
    
    <content type="html"><![CDATA[<p>Python 核心编程 读书笔记，节选部分内容</p><a id="more"></a><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>CGI：</p><p>对于静态资源（文件图片等，或者静态的HTML页面），利用web服务器就可以处理了（比如nginx），而动态资源（计算出来的数据）就要用CGI应用程序来处理。python可以用命令就在本地创建一个服务器，接着导入CGI模块，编写如何渲染页面的应用程序，就实现了CGI了。但是这种方式已经被淘汰了，一个弊端例如：</p><p>这种方式无法扩展，CGI 进程（类似 Python 解释器）针对每个请求进行创建，用完就抛弃。</p><p>如果应用程序接收数千个请求，创建大量的语言解释器进程很快就会导致服务器停机。<br>有两种方法可以解决这个问题，一是服务器集成，二是外部进程。因此CGI被框架或新的东西代替了。</p><p>web服务器一般用C写，而应用程序用各种语言都可以。</p><p>CGI是web服务器与应用程序（CGI程序）接口标准，两个直接信息传递的规程。这个规范运行web服务器执行外部程序，就是CGI程序，这样就实现了获取动态资源。这种方式每次来一个请求就要创建一个子进程，处理完成再结束这个子进程，就是fork-and-execute模式。后来又设计出了wsgi，成为web网关服务接口，也是在web服务器和应用程序之间提供一个通用的API标准。</p><p>好了，我们来做一个总结，CGI是标准，WSGI也是标准，我们用CGI标准实现一个应用程序，用于处理动态数据并返回渲染后的HTML页面（其中一种情况），可以用python来实现这个程序。一个请求来的时候，用CGI方式的话，就会创建一个CGI子进程（我们不要管是谁来创建这个子进程的），然后子进程调用CGI程序得到返回数据传给客户端。  WSGI也是一个标准，我们会实现一个服务，这个服务负责处理请求，并将请求分配到对应的应用程序上。看起来有点类似，这个处理请求和分配到应用程序上的基于WSGI标准的程序不用像CGI那样每次都要创建子进程。在django的默认处理里面，就有wsgi程序。</p><p>WSGI,实现这一标准的服务器，比如uWSGI, Gunicorn 。称为wsgi服务器，也就是server，这个服务器需要和一个实现WSGI规范的接口相配合，一般定义一个函application(environ,start_response)。</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><p>核心提示：搜索和匹配的比较</p><p>本章通篇会使用搜索和匹配两个术语。当严格讨论与字符串中模式相关的正则表达式时，我们会用术语“匹配”（matching），指的是术语“模式匹配”（pattern-matching）。在Python 术语中，主要有两种方法完成模式匹配：“搜索”（searching），即在字符串任意部分中搜索匹配的模式；而“匹配”（matching）是指判断一个字符串能否从起始处全部或者部分地匹配某个模式。搜索通过 search()函数或方法来实现，而匹配通过调用 match()函数或方法实现。总之，当涉及模式时，全部使用术语“匹配”；我们按照 Python 如何完成模式匹配的方式来区分“搜索”和“匹配”。</p><ol><li>如何写出灵活的re是关键，比如  .+  就可以匹配任意长度的字符串，再和其它元字符等配合，可以实现高效的组合</li><li>理解re表达式，结合模块的方法即可使用RE（可以概况为RE表达式和python语言）</li><li>理解返回的结果</li></ol><p>预编译：re.compile()</p><p>匹配  ： 一般指模式匹配。如何完成模式匹配？主要使用“搜索”和“匹配”两种方法实现</p><p>re的组成：通用文本，如hello。特殊符号和字符，称为元字符</p><p>元字符表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/ReadBook/py-code-re_1.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/ReadBook/py-code-re_2.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>择一匹配   “|”       re=’hello|world’</p><p>匹配任意单个字符串  “.”  re = ‘fa.b’  可以匹配a和b之间可以是任意字符（换行除外，修改编译标记可以解除这个限制）。可以使用多个点  ..   则匹配任意两个  .灵活用在文本的前面后面，中间。</p><p>数量词的贪婪模式与非贪婪模式</p><ul><li>贪婪     总是尝试匹配尽可能多的字符</li><li>非贪婪   总是尝试匹配尽可能少的字符</li></ul><p>正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab<em>“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab</em>?”，将找到”a”。</p><p>compile  标记参数：</p><ul><li>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）</li><li>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）</li><li>S(DOTALL): 点任意匹配模式，改变’.’的行为</li><li>L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li><li>U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li><li>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</li></ul><p>字符集 [abc]</p><p>限定范围和否定 [a-b] </p><p>常用符号</p><ul><li>*   o次或者多次</li><li>+   1次或者多次</li><li>？  0次或者一次</li></ul><p>o次就是允许没有，比如z?  分析它是一个通用文本   “？”  号将前面的通用文本进行一次或0次匹配。</p><p>比如zz, zx都是可以匹配到的，如此 *  + 也就理解了。</p><p>{0，1} 前一个正则匹配的次数0次或1次，使用符号为{}</p><p>注意：这些符号是对通用文本的扩充，比如原来的re=aa, 如果你想匹配8个a,好的做法是a{8}, 而不是写8个a.</p><p>表示字符集的特殊字符：\d 数字  \w字母（大小写） 他们的大写如  \D  表示不匹配，即非十进制数字。</p><p>分组：提取任何已经成功匹配的特定字符串或者子字符串</p><p>使用（）包裹re表达式，可以进行分组或匹配子组，注意这两个的区别：</p><ul><li>分组：被包裹的re表达式会是一个整体，一般在后面接上量词。每一个括号得到分组为组1，后面的分组累加 <code>(a(b))   组1  ab   组2   b</code></li><li>子组：上面得到的组1就是子组了，可以称为子组1</li></ul><p>扩展表示法：通常形式（?…） 尽管圆括号使用这些符号，但是只有（?P\<name>）表述一个分组匹配。所有其他的都没有创建一个分组。</name></p><p>边界匹配 ： 符号   \b  \B     \b是一个单词的边界匹配，  r’\ber’   能匹配   ‘a er’  不能匹配  ‘aer’<br>要匹配  ’aer‘  re=r’er\b’</p><p>闭合操作符是非贪婪的</p><p>语言</p><p>re可以先进行预编译，用得到的编译对象再去操作函数或方法，也可以用模块（re）直接调用方法，这个时候需要传入pattern参数，即一个re表达式。</p><p>理解搜索和匹配，匹配是从头开始，如果第一个字符串就不匹配，则匹配模式失败，如果用搜索模式，则会把被匹配对象从头到尾都匹配一编，中间有符合条件的就可以得到匹配结果。</p><p>findall() 该函数返回正则表达式模式全部的非重复情况，结果是一个列表，没有匹配就是空列表。</p><p>这个函数的结果就是一个列表了，它没有group等属性了。</p><p>finditer()和上面的类似，结果是一个迭代器。</p><p>sub()和 subn()搜索与替换  功能就是将字符串能匹配到的都替换成其它字符串，subn会返回替换计数。</p><p>split()分隔字符串：匹配成功的时候进行，号分割，返回的是分割后结果的列表。即一个字符串，左到右，满足条件就进行分割。</p><p>扩展表示：</p><p>在分组的时候重新起一个名字‘z’   re = r’ns(?P\<z>\d+)’   re.match(ns7).group(‘z’)    out:  7</z></p><p>数量词组合：+， *  这两个是贪婪的，可以在后面加上？ 变成非贪婪。</p><p>re = ‘.+c’    str=’abcabc’   out=’abcabc’   如果re=’.+?’  out=’abc’</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 核心编程 读书笔记，节选部分内容&lt;/p&gt;
    
    </summary>
    
      <category term="readbook" scheme="http://www.liuzhidream.com/categories/readbook/"/>
    
    
      <category term="readbook" scheme="http://www.liuzhidream.com/tags/readbook/"/>
    
  </entry>
  
  <entry>
    <title>javascript-definitive-guide 读书笔记</title>
    <link href="http://www.liuzhidream.com/2018/10/22/ReadBook/javascript-definitive-guide/"/>
    <id>http://www.liuzhidream.com/2018/10/22/ReadBook/javascript-definitive-guide/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:08:11.228Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 权威指南 读书笔记，节选部分内容</p><a id="more"></a><h2 id="关于分号"><a href="#关于分号" class="headerlink" title="关于分号"></a>关于分号</h2><p>关于分号，分号可以不要，如果你不要分号，语句会被解释器连起来。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = y + z</span><br><span class="line">(a+b).result()</span><br></pre></td></tr></table></figure><p>实际是 <code>var x = y + z(a+b).result()</code> 分号是语句的结束，你不加分号解释器会自己来处理，它处理不了的语句会自己加分号，等等一些规则，所以养成加分号是好习惯，避免前面的语句改了，没有分号语句被解释器组合了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 权威指南 读书笔记，节选部分内容&lt;/p&gt;
    
    </summary>
    
      <category term="readbook" scheme="http://www.liuzhidream.com/categories/readbook/"/>
    
    
      <category term="readbook" scheme="http://www.liuzhidream.com/tags/readbook/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Water/UseHexo/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Water/UseHexo/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>关于博客迁移，最开始是在有道上做笔记，学习记录，后来萌生了写类似博客网站的想法，于是用element-UI框架写了一个，整体的效果还不错，还有一个后台管理，使用Django作为web服务，每篇文章存储在数据库，但是想要的功能太多了，设计的功能也显得格格不入（完全按照自己的想法来），后来放弃了，转用了VuePress，后来又看到Hexo，还是迁移到Hexo吧。开始使用VuePress，也是因为作者说会在后续添加博客的功能，结果没有后续了，Hexo作为博客提供了很全面的功能</p><a id="more"></a><h1 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h1><p>关于博客迁移，最开始是在有道上做笔记，学习记录，后来萌生了写类似博客网站的想法，于是用element-UI框架写了一个，整体的效果还不错，还有一个后台管理，使用Django作为web服务，每篇文章存储在数据库，但是想要的功能太多了，设计的功能也显得格格不入（完全按照自己的想法来），后来放弃了，转用了VuePress，后来又看到Hexo，还是迁移到Hexo吧。开始使用VuePress，也是因为作者说会在后续添加博客的功能，结果没有后续了，Hexo作为博客提供了很全面的功能</p><h2 id="迁移脚本"><a href="#迁移脚本" class="headerlink" title="迁移脚本"></a>迁移脚本</h2><p>大概扫描了一下Hexo的官方，马上起了一个项目，发现这个文件结构和VuePress差的有点多啊，不怕，写个迁移脚本就行了，这样就把原来文件结构都取出来放到通用目录下，顺便生成一下Hexo的yaml-Front-matter，对README的文件做一下重命名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author:   LiuZhi</span></span><br><span class="line"><span class="string">@file:     hexo_change.py</span></span><br><span class="line"><span class="string">@time:     2019-10-22 23:48</span></span><br><span class="line"><span class="string">@contact:  vanliuzhi@qq.com</span></span><br><span class="line"><span class="string">@software: PyCharm</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/Users/liuzhi/PycharmProjects/test_code/zh/'</span></span><br><span class="line"></span><br><span class="line">op_list = os.listdir(path)</span><br><span class="line"></span><br><span class="line">write_data2 = <span class="string">'''</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">title: %s</span></span><br><span class="line"><span class="string">date: 2018-10-22 00:00:00</span></span><br><span class="line"><span class="string">updated: 2018-10-22 00:00:00</span></span><br><span class="line"><span class="string">tags:</span></span><br><span class="line"><span class="string">categories:</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(title)</span>:</span></span><br><span class="line">    a = write_data2 % title</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_absolute_path</span><span class="params">(dir_name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> path + dir_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dir_file</span><span class="params">(_dir, result)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _dir != <span class="string">'/Users/liuzhi/PycharmProjects/test_code/zh/.DS_Store'</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(_dir):</span><br><span class="line">            res = _dir + <span class="string">'/'</span> + item</span><br><span class="line">            result.append(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_file_path</span><span class="params">()</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    dir_list = map(get_absolute_path, op_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list(dir_list):</span><br><span class="line">        get_dir_file(i, result)</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_name</span><span class="params">(_dir, data)</span>:</span></span><br><span class="line">    _list = _dir.split(<span class="string">'/'</span>)</span><br><span class="line">    name = _list[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'README.md'</span>:</span><br><span class="line">        name = _list[<span class="number">-2</span>] + <span class="string">'.md'</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/liuzhi/PycharmProjects/test_code/result/'</span> + name, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(_dir)</span>:</span></span><br><span class="line">    _list = _dir.split(<span class="string">'/'</span>)</span><br><span class="line">    name = _list[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'README.md'</span>:</span><br><span class="line">        name = _list[<span class="number">-2</span>] + <span class="string">'.md'</span></span><br><span class="line">    <span class="keyword">return</span> name[:<span class="number">-3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hexo_change</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    实现在文件头写入，不能使用a+模式，需要截断成0字节</span></span><br><span class="line"><span class="string">    总体来说，要实现任意位置写入，只能是通过读取整个文件，然后将</span></span><br><span class="line"><span class="string">    需要写入的插入，然后把整个结果写入</span></span><br><span class="line"><span class="string">    :param file_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> loop_file_path():</span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'r+'</span>) <span class="keyword">as</span> _file:</span><br><span class="line">            old = _file.read()</span><br><span class="line">            _file.seek(<span class="number">0</span>)</span><br><span class="line">            _file.write(write_data(get_name(file_name)))</span><br><span class="line">            _file.write(old)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> loop_file_path():</span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'r+'</span>) <span class="keyword">as</span> _file:</span><br><span class="line">            old = _file.read()</span><br><span class="line">            save_name(file_name, old)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_content_to_file</span><span class="params">()</span>:</span></span><br><span class="line">    file = open(<span class="string">"a.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">    file_add = open(<span class="string">"a.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">    content = file.read()</span><br><span class="line">    content_add = file_add.read()</span><br><span class="line">    pos = content.find(<span class="string">"buildTypes"</span>)</span><br><span class="line">    <span class="keyword">if</span> pos != <span class="number">-1</span>:</span><br><span class="line">        content = content[:pos] + content_add + content[pos:]</span><br><span class="line">        file = open(<span class="string">"a.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">        file.write(content)</span><br><span class="line">        file.close()</span><br><span class="line">        file_add.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    cp_cmd = <span class="string">'cp -rf ~/JavaScriptProjects/my-notebook/docs/zh/ ~/PycharmProjects/test_code/zh'</span></span><br><span class="line">    rm_zh = <span class="string">'rm -rf ~/PycharmProjects/test_code/zh/'</span></span><br><span class="line">    mark_dir = <span class="string">'mkdir ~/PycharmProjects/test_code/zh'</span></span><br><span class="line">    cmd_list = [rm_zh, mark_dir, cp_cmd]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cmd_list:</span><br><span class="line">        os.system(i)</span><br><span class="line">    <span class="comment"># map(lambda x: os.system(x), cmd_list)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cp_new_file</span><span class="params">()</span>:</span></span><br><span class="line">    cp_cmd = <span class="string">'cp -rf ~/PycharmProjects/test_code/result/ /Users/liuzhi/JavaScriptProjects/hexo_blog/source/_posts'</span></span><br><span class="line">    os.system(cp_cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># init()</span></span><br><span class="line">    <span class="comment"># hexo_change()</span></span><br><span class="line">    cp_new_file()</span><br></pre></td></tr></table></figure><h2 id="采坑"><a href="#采坑" class="headerlink" title="采坑"></a>采坑</h2><p>浏览过一遍文档，如果不着急搞分享，评论什么的，上手会很快，开始我的图片资源也是没有问题了，直到我看了官方的<code>资源文件夹</code>功能，它提出了一个顾虑（我真的没感觉到会有这个问题，分类和主页的资源，怎么会有路径问题呢？难道是历史原因），推荐使用此功能，需要进行对应的配置，使用<code>{% asset_img example.jpg This is an example image %}</code>，坑就坑在这么用完全没效果，然后我Google，发现别人都是装插件的，查了我的package.json，没插件啊，官方这文档不负责啊。</p><p>然而坑还没结束，装了插件仍然没用，于是我去看了GitHub对插件的用法，需要使用Markdown语法，我真是哔了狗了，Hexo的文档英文也是明确说明不要使用Markdown语法，用插件语法，这完全没用啊，看了别人的用法也是用Markdown语法。</p><p>最后，经过我的测试，使用Markdown语法，配合插件可以使用相对路径，如果这样用，你的每篇博客不能创建独立的文件夹，只能放在_posts下，不知道是BUG还是什么问题，总之一点官方文档给的用法没有效果，插件的作者都没这么用，个人猜测框架扩展了插件后，使用插件语法应该是没问题的，Hexo支持这么多插件，然而在这个插件上出了问题估计是BUG了。</p><p>解决方案：使用Markdown语法，图片放在<code>_posts/images</code>下，由于这是绝对路径，部署和本地都是正常的，另外不一定要把文章放在_posts下，可以再创建一个父级目录，虽然编译后文章被分类了，但是原始项目这么搞就太混乱了，这让我觉得使用命令创建文章有点鸡肋了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于博客迁移，最开始是在有道上做笔记，学习记录，后来萌生了写类似博客网站的想法，于是用element-UI框架写了一个，整体的效果还不错，还有一个后台管理，使用Django作为web服务，每篇文章存储在数据库，但是想要的功能太多了，设计的功能也显得格格不入（完全按照自己的想法来），后来放弃了，转用了VuePress，后来又看到Hexo，还是迁移到Hexo吧。开始使用VuePress，也是因为作者说会在后续添加博客的功能，结果没有后续了，Hexo作为博客提供了很全面的功能&lt;/p&gt;
    
    </summary>
    
      <category term="water" scheme="http://www.liuzhidream.com/categories/water/"/>
    
    
      <category term="water" scheme="http://www.liuzhidream.com/tags/water/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Nginx/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Nginx/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。</p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx的配置, 一般就是配server模块，该模块的全局定义，location 定义了正则的解析（向服务器请求各种资源，nginx应该如何处理）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>RESTFulAPI</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/RESTFulAPI/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/RESTFulAPI/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>REST风格5个约束：客户端-服务端，无状态，缓存，统一接口，分层系统</p><ol><li><p>使用名词表示资源，动词通过HTTP方法来实现，比如删除资源使用DELETE方法。</p></li><li><p>关注请求头，比如请求头Accept要求返回application/xml，如果服务器只能放回json格式的，应该返回406错误。</p></li><li><p>使用正确的请求方法和状态码</p></li></ol><p>不能一味的使用POST和GET方法，HTTP方法表</p><table><thead><tr><th>Name</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td>OPTIONS</td><td style="text-align:left">用于获取资源支持的所以HTTP方法 </td></tr><tr><td>HRAD</td><td style="text-align:left">用于只获取请求某个资源返回的头信息 </td></tr><tr><td>GET</td><td style="text-align:left">用于从服务器获取某个资源的信息：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被请求的资源详细信息 </td></tr><tr><td>POST</td><td style="text-align:left">用于创建新资源：1.创建完成后，返回状态码201 Created 2.完成请求后，需要返回被创建的资源详细信息 </td></tr><tr><td>PUT</td><td style="text-align:left">用于完整的替换资源或者创建指定身份的资源：1.如果是创建了资源，则返回201 Created 2.如果是替换了资源，则返回200 OK </td></tr><tr><td>PATCH</td><td style="text-align:left">用于局部更新资源：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被修改的资源详细信息 3.完成请求后，需返回被修改的资源详细信息 </td></tr><tr><td>DELETE</td><td style="text-align:left">用于删除某个资源，完成请求后返回状态码204 No Content </td></tr></tbody></table><p>对输出结果不在封装：通过状态码来判断请求，不应该把信息写在响应体中</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/RabbitMQ/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/RabbitMQ/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>需要了解一个协议：AMQP协议，协议的流程由消息发布者，交换机，队列，到消息订阅者。交换机做路由分发，将收到的消息根据路由规则分发给绑定的队列。</p><ol><li><p>消息：消息实际包含两部分内容，1是有效载荷，就是要传输的数据，数据类型可以是纯文本或JSON。2是标签，它包含交换机的名字和可选的主题(topic)标记等，AMQP仅仅描述了标签，而RabbitMQ决定了把这个消息发给哪个消费者。</p></li><li><p>发布者：也就是生产者，创建消息并设置标签</p></li><li><p>消费者：消费者连接到代理服务器上，接受有效载荷，消费者不需要消息中的标签</p></li></ol><p>消息投递失败会重发，保证消息正确取出和执行，AMQP模块包含了消息确认的概念，在收到消费者的确认回执前，消息代理不会将消息从队列中删除。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机拿到消息后，将路由给队列，使用哪种路由算法是由交换机类型和被称作“绑定（queue_bind）”的规则决定的。</p><p>可配置的队列如下：</p><ol><li>直连交换机（direct exchange）</li></ol><p>根据消息携带的<code>路由键(routing key)</code>将消息投递给对应的队列。将一个队列绑定到某个交换机的同时赋予该绑定一个路由键，当一个携带者路由键为XXX的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为XXX的队列。直连交换机用来处理消息的单播路由。</p><ol start="2"><li>主题交换机（topic exchange）</li></ol><p>通过对消息的<code>路由键</code>和队列到交换机的<code>绑定模式</code>之间的匹配，将消息路由给一个或多个队列。主题交换机通常用来实现消息的<code>多播路由</code>。发送到主题交换机的消息的路由键，必须是一个由 “.” 分隔的词语列表，这些词语应该和对应的业务关联，词语的个数可以随意，但是不要超过255字节。绑定键支持通配符：“*” 用来表示一个单词；“#” 用来表示任意数量(零个或多个)单词。</p><ol start="3"><li>扇形交换机（fanout exchange）</li></ol><p>将消息路由给绑定到它身上的所有队列，且不理会绑定的路由键。用来做消息的<code>广播路由</code>。它允许你对单条消息做不同的处理，在开发中一个操作可能要多个连带工作，比如用户创建一篇新的日记，需要更新用户的创建日记数，清除相关缓存，给关注这个用户的其他用户推消息，日记进审核后台，日记进最新日记池等等。可以使用扇形交换机把一个消息分发给多个任务队列，执行不一样的工作。尤其是业务改变时，使用扇形交换机<code>直接为新的消费者添加声明</code>，并绑定进来就可以了，否则需要修改发送方的代码来添加接收方。所以，使用扇形交换机可以有效地<code>解耦</code>发送者和消费者。</p><ol start="4"><li>头交换机（headers exchange）</li></ol><p>允许匹配AMQP的头而非路由键，其实使用起来和直接交换机差不多，但是性能却差很多，一般用不到这种类型。</p><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>通过创建新的虚拟主机，实现隔离，不同的虚拟主机直接完全隔离，拥有自己的队列，绑定和交换机。就像创建了一个新用户，服务A做订单的，链接对应的虚拟主机，服务B做消息推送的，链接对应的虚拟主机。默认是虚拟主机是 <code>/</code>，使用guest做默认用户和密码，通过命令创建新的虚拟主机：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user dongwm 123456</span><br><span class="line">sudo rabbitmqctl add_vhost web_develop</span><br><span class="line">sudo rabbitmqctl set_permissions -p web_develop dongwm <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p><code>rabbitmqctl set_permissions</code> 是配置权限，三个对应的权限是：配置（队列和交换的创建和删除）、写（发布消息）、读（消费消息）的权限。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>sudo rabbitmqctl list_vhosts</li><li>sudo rabbitmqctl list_queue -p web_develop</li><li>sudo rabbitmqctl list_users</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Redis/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Redis/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><a id="more"></a><h2 id="Database-Number"><a href="#Database-Number" class="headerlink" title="Database Number"></a>Database Number</h2><p>Redis 使用 DB number 实现类似关系型数据库中 schema 的功能。不同 DB number 表示的数据库是隔离的，但是目前只能使用数字来表示一个数据库，Ubuntu 默认的配置文件配置了16个数据库，DB number 是从0开始的，并且默认连接0号数据库。</p><p><code>redis-cli -n &lt;dbnumber&gt;</code> 连接指定数据库</p><h2 id="在docker中使用Redis"><a href="#在docker中使用Redis" class="headerlink" title="在docker中使用Redis"></a>在docker中使用Redis</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。&lt;br&gt;Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>http-protocol</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/http-protocol/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/http-protocol/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><a id="more"></a><h2 id="http-action"><a href="#http-action" class="headerlink" title="http action"></a>http action</h2><p>HTTP协议中GET、POST和HEAD的介绍  2008-05-10 14:15 </p><table><thead><tr><th>Name</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">请求指定的页面信息，并返回实体主体。 </td></tr><tr><td>HEAD</td><td style="text-align:center">只请求页面的首部。 </td></tr><tr><td>POST</td><td style="text-align:center">请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。 </td></tr><tr><td>PUT</td><td style="text-align:center">从客户端向服务器传送的数据取代指定的文档的内容。 </td></tr><tr><td>DELETE</td><td style="text-align:center">请求服务器删除指定的页面。 </td></tr><tr><td>OPTIONS</td><td style="text-align:center">允许客户端查看服务器的性能。 </td></tr><tr><td>TRACE</td><td style="text-align:center">请求服务器在响应中的实体主体部分返回所得到的内容。 </td></tr><tr><td>PATCH</td><td style="text-align:center">实体中包含一个表，表中说明与该URI所表示的原内容的区别。 </td></tr><tr><td>MOVE</td><td style="text-align:center">请求服务器将指定的页面移至另一个网络地址。 </td></tr><tr><td>COPY</td><td style="text-align:center">请求服务器将指定的页面拷贝至另一个网络地址。 </td></tr><tr><td>LINK</td><td style="text-align:center">请求服务器建立链接关系。 </td></tr><tr><td>UNLINK</td><td style="text-align:center">断开链接关系。 </td></tr><tr><td>WRAPPED</td><td style="text-align:center">允许客户端发送经过封装的请求。 </td></tr><tr><td>Extension-mothed</td><td style="text-align:center">在不改动协议的前提下，可增加另外的方法。 </td></tr></tbody></table><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p>三次握手：A向B发起连接，B收到，回一个给A，A也收到，连接确定</p><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><p>完成三次握手，客户端与服务器开始传送数据。</p><p>建立连接是三次握手，释放连接是四次挥手（关闭连接）</p><ol><li>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</li><li>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</li><li>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</li><li>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table><thead><tr><th>Name</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>2xx</td><td style="text-align:center">成功 </td></tr><tr><td>3xx</td><td style="text-align:center">重定向 </td></tr><tr><td>4xx</td><td style="text-align:center">客户端问题</td></tr><tr><td>5xx</td><td style="text-align:center">服务端问题</td></tr></tbody></table><h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h2><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 </li></ol><p>建议：<br>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="http" scheme="http://www.liuzhidream.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>web相关</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/other/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/other/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>web相关学习笔记</p><a id="more"></a><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网关和路由器最大的区别是是否连接相似的网络。如果连接相似的网络，则称为路由器。而连接不相似的网络，称为网关。（个人认为这个关字可以从海关上来理解，出关，海关）</p><p>相似的网络和不相似的网络有两种不同的含义。</p><p>逻辑层面：</p><p>相似的网络：如果都是互联网上的两个网络，我们称为相似的网络。不相似的网络：如果一个是私网，一个是公网。我们称为不相似的网络。</p><p>物理层面：</p><p>相似的网络：都是以太网或者同一种介质的网络。<br>不相似的网络：一边是以太，一边是SDH或者ATM等</p><p>子网（Sub-net）出口路由器就叫网关了，后面还有很多中继路由器。所以网关一定是路由器，但路由器不一定用来做网关</p><p><code>TTL  Time to live</code> 域名解析在DNS服务器中存留时间        </p><p>实际指转发的最大跳数，主机发送ip包的时候，在网络中转发，转发一次该值减1，为了防止无限转发和循环而设置这个值。如果变成1还没到目标地址，即为超时。</p><p>内网映射</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web相关学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>ORID 焦点呈现法（Focused Conversation Method）</title>
    <link href="http://www.liuzhidream.com/2018/10/22/blog/ORID/"/>
    <id>http://www.liuzhidream.com/2018/10/22/blog/ORID/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:47:07.832Z</updated>
    
    <content type="html"><![CDATA[<p>ORID，即焦点呈现法（Focused Conversation Method），是一种通过催化师（主持人、引导讲师）引导来开展的结构化汇谈（会议、交谈）形式。该方法常被用作对事实进行分析和感觉某一工具和方法（O实践-客观事实、R感受-客观反射、I意义-事实分析，D行动-基于事实的下一步行动）。</p><a id="more"></a><h2 id="ORID"><a href="#ORID" class="headerlink" title="ORID"></a>ORID</h2><p>Objective 你对今天学的记得什么？</p><p>Reflective 一句话形容今天的情绪（今天的高峰、低峰）。</p><p>Interpretive 今天你学到了啥？重要的领悟是什么？</p><p>Decisional 一句话形容今天的工作，明天要继续哪些工作。</p><p>Objective：The Objective Level of Thinking：这个方法就是通过引导的方法，对团队成员都着眼于客观事实，引导师让大家先说看到了什么、听到了什么，一方面是比较容易让大家回答，参与，同时让大家从事实入手看问题。</p><p>Reflective：The Reflective Level of Thinking：引导师会问大家对此事情的感受是怎么的？比较适合让人们打开感性的一面？多用来描述心情，如“喜、怒、哀、乐”等。</p><p>Interpretive：The Interpretive Level of Thinking ：思考这件事带给我们的思考、意义、启发是什么？</p><p>Decisional：The Decisional Level of Thinking：给我们带来的行动是什么？未来我要怎么做？</p><p>焦点表述法（ORID）可以用于很多的场合，例如课堂提问学员引导，职场上级与下级的沟通，以及日常的写作都可以应用。</p><p>举例：在某件事中，你看到印象最深刻的一幕是什么？（O）你的第一感觉是什么？(R)对这件事，你是怎么想的？(I)能不能把这个经验用在未来的工作中？(D)</p><p>如：我今天上班途中突然遇到一条狗（O），我很害怕（R），为什么这里会有一条狗？因为这条路太偏僻(I)，明天我要选择其它人多的路(D)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ORID，即焦点呈现法（Focused Conversation Method），是一种通过催化师（主持人、引导讲师）引导来开展的结构化汇谈（会议、交谈）形式。该方法常被用作对事实进行分析和感觉某一工具和方法（O实践-客观事实、R感受-客观反射、I意义-事实分析，D行动-基于事实的下一步行动）。&lt;/p&gt;
    
    </summary>
    
      <category term="causerie" scheme="http://www.liuzhidream.com/categories/causerie/"/>
    
    
      <category term="causerie" scheme="http://www.liuzhidream.com/tags/causerie/"/>
    
  </entry>
  
  <entry>
    <title>利用Docker快速构建开发环境</title>
    <link href="http://www.liuzhidream.com/2018/10/22/blog/docker-dev/"/>
    <id>http://www.liuzhidream.com/2018/10/22/blog/docker-dev/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:47:07.832Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是很不错的容器技术，利用Docker可用快速构建一个开发环境，这样的好处在于一台新的电脑，只要安装了Docker软件，搭建环境就是几个命令的事，这样整个开发团队都会在同样的环境下进行，而且部署的时候，运维的同学只需要针对安全性做一些调整即可上线。</p><a id="more"></a><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>以Python语言为例，一个小团队的技术栈差不多会用到以下的东西：</p><ol><li>Python环境，包括各种需要的包</li><li>数据库，包括MySQL、MongoDB等</li><li>缓存服务，使用Redis等</li><li>任务队列，使用celery，RabbitMQ</li><li>Http服务器，Nginx</li><li>WSGI服务器，gunicorn，uwsgi</li></ol><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> author=<span class="string">"liuzhi&lt;1441765847.com&gt;"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 换源，Python镜像基于Debian，使用阿里的Debian源</span></span></span><br><span class="line"><span class="bash">RUN rm /etc/apt/sources.list</span></span><br><span class="line"><span class="bash">COPY sources.list /etc/apt/sources.list</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 运行命令，安装常用软件</span></span></span><br><span class="line"><span class="bash">RUN apt-get update \</span></span><br><span class="line"><span class="bash">    <span class="comment"># 修改时区</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime \</span></span><br><span class="line"><span class="bash">    <span class="comment"># &amp;&amp; apt-get install -y apt-utils \</span></span></span><br><span class="line"><span class="bash">    <span class="comment"># &amp;&amp; apt-get install -y wget \</span></span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y zsh \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chsh -s /bin/zsh root \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y git \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apt-get install -y vim </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装zsh的扩展</span></span></span><br><span class="line"><span class="bash">RUN sh -c <span class="string">"<span class="variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span>  || <span class="literal">true</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENV FLASK_ENV dev</span></span><br><span class="line"><span class="bash">ENV APP_DIR /code</span></span><br><span class="line"><span class="bash">WORKDIR /code/</span></span><br><span class="line"><span class="bash">EXPOSE 5000</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><p>记得在同级目录下装备源文件 <code>sources.list</code></p></li><li><p>有时候会提示需要安装 <code>apt-utils</code>，不过我这里是基于Debian的，这东西还装不上，没有apt-utils，安装不了第三方包，wget安装失败了，可用进入容器自行安装wget</p></li><li><p>RUN命令中通过 <code>&amp;&amp;</code> 连接命令，因为在Docker中，每一个指令都会构建一层，因此尽量将命令都放在一个RUN指令中，用 &amp;&amp; 来串联。还有命令后面的 <code>\</code> 符最后就不需要写了，不然和下面的命令连起来了，如果你使用Dockerfile静态语法检查工具，有错误提示的（xcode安装插件即可编写Dockerfile，错误的地方会有提示）</p></li><li><p>这里还安装了zsh的扩展，使用了 <code>||</code> ，不用直接安装镜像创建会失败，我猜测可能是这个命令后面没接上，不用 <code>||</code> 可以看到安装信息是成功了的，但是容器创建会失败，太具体的情况不知道了，安装了zsh，启动容器的时候记得通过 <code>/bin/zsh</code> 进入</p></li></ul><p>这里使用了官方的Python镜像，体积有点大，好处是装软件一般不会出问题了，作为开发用就不在精简体积上花时间了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是很不错的容器技术，利用Docker可用快速构建一个开发环境，这样的好处在于一台新的电脑，只要安装了Docker软件，搭建环境就是几个命令的事，这样整个开发团队都会在同样的环境下进行，而且部署的时候，运维的同学只需要针对安全性做一些调整即可上线。&lt;/p&gt;
    
    </summary>
    
      <category term="technology" scheme="http://www.liuzhidream.com/categories/technology/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="docker" scheme="http://www.liuzhidream.com/tags/docker/"/>
    
      <category term="technology" scheme="http://www.liuzhidream.com/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Algorithm/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Algorithm/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:56:18.358Z</updated>
    
    <content type="html"><![CDATA[<p>算法相关</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>有穷性(Finiteness)<br>算法的有穷性是指算法必须能在执行有限个步骤之后终止；</li><li>确切性(Definiteness)<br>算法的每一步骤必须有确切的定义；</li><li>输入项(Input)<br>一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</li><li>输出项(Output)<br>一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</li><li>可行性(Effectiveness)<br>算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。</li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><ol><li>先准备一个dict</li><li>循环数据</li><li>准备唯一键</li><li>如果唯一键没在dict中，生成新的dict2</li><li>并且 <code>dict[key] = dict2</code></li><li>如果在，<code>dict2 = dict[key]</code></li><li>然后修改dict2</li></ol><p>利用字典在原引用修改的特性，把数据进行聚合分组，每次循环都会根据唯一键从临时数据字典dict处取出要聚合到这个key对应的字典中，然后对其进行操作。</p><h2 id="找出数组中，只出现一次的两个数字"><a href="#找出数组中，只出现一次的两个数字" class="headerlink" title="找出数组中，只出现一次的两个数字"></a>找出数组中，只出现一次的两个数字</h2><p>list = [2, 4, 3, 6, 3, 2, 5, 5]</p><p>核心思路：</p><p>1、数组中全部数据异或操作后，依次对数组中的每个元素进行异或（相同位为0，不同为1）操作，得到0000 0010。</p><p>2、倒数第二位是1，说明我们要找的那两个只出现一次的数字，倒数第二位是不同的。(会出现不同，是因为这两个数不同，所以至少有一位是不同的)</p><p>3、下面根据每个数二进制倒数第二位是不是1来分成两组，倒数第二位为1的是{2, 3, 6, 3, 2}，倒数第二位为0的是{4, 5, 5}。</p><p>4、接下来对这两个数组分别进行异或操作，剩下的数字就是只出现一次的数字。</p><p>为什么分组可以实现：因为4，6是不同的两个数，它们二进制的至少某一位是不同的（记为N位），所以把这位是1的分在一起，试想所有的数在N位不同的是4或6中的一个，加上其它的数，其它的数都是成对的，所有其它的数也只会分成两组（其它的数N位同样只会是1或0），一组包含4和多个重复的数，一组包含6和多个重复的数，重复的数是可以消去的。</p><h2 id="A-B-问题"><a href="#A-B-问题" class="headerlink" title="A + B 问题"></a>A + B 问题</h2><p>给出两个整数 aa 和 bb , 求他们的和。</p><ul><li><p>样例<br>如果 a=1 并且 b=2，返回3。</p></li><li><p>挑战<br>显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）</p></li><li><p>说明<br>a和b都是 32位 整数么？</p><p>  是的</p></li><li><p>我可以使用位运算符么？</p><p>  当然可以</p></li></ul><p>思路：运用位运算模拟加法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param a: An integer</span></span><br><span class="line"><span class="string">    @param b: An integer</span></span><br><span class="line"><span class="string">    @return: The sum of a and b </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">aplusb</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> a == -b:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">                a, b = a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">                <span class="comment"># 每次去算进位的地方，进位的和a一直相加</span></span><br><span class="line">            <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>主要利用异或运算来完成 </p><ul><li>异或运算有一个别名叫做：不进位加法</li><li>那么a ^ b就是a和b相加之后，该进位的地方不进位的结果</li><li>然后下面考虑哪些地方要进位，自然是a和b里都是1的地方</li><li>a &amp; b就是a和b里都是1的那些位置，a &amp; b &lt;&lt; 1 就是进位</li><li>之后的结果。所以：a + b = (a ^ b) + (a &amp; b &lt;&lt; 1)</li><li>令a’ = a ^ b, b’ = (a &amp; b) &lt;&lt; 1</li><li>可以知道，这个过程是在模拟加法的运算过程，进位不可能</li><li>一直持续，所以b最终会变为0。因此重复做上述操作就可以</li><li>求得a + b的值。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    len_ = len(relist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len_ - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> relist[j] &gt; relist[j + <span class="number">1</span>]:</span><br><span class="line">                relist[j + <span class="number">1</span>], relist[j] = relist[j], relist[j + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(bubbleSort([1, 5, 2, 6, 9, 3]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort2</span><span class="params">(inlist)</span>:</span></span><br><span class="line">    len_ = len(inlist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len_ - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> inlist[j] &gt; inlist[j + <span class="number">1</span>]:</span><br><span class="line">                inlist[j + <span class="number">1</span>], inlist[j] = inlist[j], inlist[j + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> inlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(bubbleSort2([1, 5, 2, 6, 9, 3]))</span></span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        greater = [j <span class="keyword">for</span> j <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> j &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quickSort(less) + [pivot] + quickSort(greater)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快排 分片的思想+递归的思想，这是取了第一个为基准值，栈高为O(log(n)),栈长O(n),所以运行时间为栈高x栈长，也就是算法平均运算时间为O(nlog(n))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort2</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        piovt = array[<span class="number">0</span>]</span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&lt; piovt]</span><br><span class="line">        greater = [j <span class="keyword">for</span> j <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> j&gt;piovt]</span><br><span class="line">        <span class="keyword">return</span> quickSort2(less) + [piovt] + quickSort2(greater)</span><br><span class="line"></span><br><span class="line">print(quickSort2([<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><h2 id="范围内的质数"><a href="#范围内的质数" class="headerlink" title="范围内的质数"></a>范围内的质数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        <span class="keyword">if</span> compute(i):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(value)</span>:</span></span><br><span class="line">    flag = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, value - <span class="number">1</span>):</span><br><span class="line">        r = value % i</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">            flag = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">print(func())</span><br></pre></td></tr></table></figure><h2 id="二叉数遍历"><a href="#二叉数遍历" class="headerlink" title="二叉数遍历"></a>二叉数遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, left=None, right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for BinaryTree"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root == <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(self, this_Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> this_Node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(this_Node.data)</span><br><span class="line">        self.preOrder(this_Node.left)</span><br><span class="line">        self.preOrder(this_Node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, this_Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> this_Node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(this_Node.left)</span><br><span class="line"></span><br><span class="line">        print(this_Node.data)</span><br><span class="line">        self.inOrder(this_Node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postOrder</span><span class="params">(self, this_Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> this_Node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postOrder(this_Node.left)</span><br><span class="line">        self.postOrder(this_Node.right)</span><br><span class="line">        print(this_Node.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, this_Node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> this_Node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        _queue = []</span><br><span class="line">        _queue.append(this_Node)</span><br><span class="line">        <span class="keyword">while</span> _queue:</span><br><span class="line">            node = _queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(node.data)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="keyword">None</span>:</span><br><span class="line">                _queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="keyword">None</span>:</span><br><span class="line">                _queue.append(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(root.data)</span><br><span class="line">        self.deep(root.left)</span><br><span class="line">        self.deep(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deepTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ld = self.deepTree(root.left)</span><br><span class="line">        rd = self.deepTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(ld, rd) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n1 = BinaryTreeNode(data=<span class="string">"D"</span>)</span><br><span class="line">n2 = BinaryTreeNode(data=<span class="string">"E"</span>)</span><br><span class="line">n3 = BinaryTreeNode(data=<span class="string">"F"</span>)</span><br><span class="line">n4 = BinaryTreeNode(data=<span class="string">"B"</span>, left=n1, right=n2)</span><br><span class="line">n5 = BinaryTreeNode(data=<span class="string">"C"</span>, left=n3, right=<span class="keyword">None</span>)</span><br><span class="line">root = BinaryTreeNode(data=<span class="string">"A"</span>, left=n4, right=n5)</span><br><span class="line"></span><br><span class="line">bt = BinaryTree(root)</span><br><span class="line"></span><br><span class="line">bt = BinaryTree(root)</span><br><span class="line"><span class="comment"># print('先序遍历')</span></span><br><span class="line"><span class="comment"># bt.preOrder(bt.root)</span></span><br><span class="line"><span class="comment"># print('中序遍历')</span></span><br><span class="line"><span class="comment"># bt.inOrder(bt.root)</span></span><br><span class="line"><span class="comment"># print('后序遍历')</span></span><br><span class="line"><span class="comment"># bt.postOrder(bt.root)</span></span><br><span class="line">bt.levelOrder(root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print bt.deepTree(bt.root)</span></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flb</span><span class="params">(num)</span>:</span></span><br><span class="line">    result = <span class="keyword">None</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; num:</span><br><span class="line">        print(b)</span><br><span class="line">        result = b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = flb(<span class="number">6</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># def jump_floor(number):</span></span><br><span class="line"><span class="comment">#     if number &lt;= 2:</span></span><br><span class="line"><span class="comment">#         return number</span></span><br><span class="line"><span class="comment">#     prev, curr = 1, 2</span></span><br><span class="line"><span class="comment">#     for _ in range(3, number + 1):</span></span><br><span class="line"><span class="comment">#         prev, curr = curr, prev + curr</span></span><br><span class="line"><span class="comment">#         print(curr)</span></span><br><span class="line"><span class="comment">#     return curr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(jump_floor(5))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(time)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> time &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> time</span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, time + <span class="number">1</span>):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(jump(6))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def jumpm(time):</span></span><br><span class="line"><span class="comment">#     if time == 0:</span></span><br><span class="line"><span class="comment">#         return 0</span></span><br><span class="line"><span class="comment">#     return 2 ** (time - 1)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># fff = lambda a: a if a &lt;= 2 else (fff(a - 1) + fff(a - 2))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(fff(6))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法相关&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://www.liuzhidream.com/categories/algorithm/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="algorithm" scheme="http://www.liuzhidream.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="http://www.liuzhidream.com/2018/10/22/HTML/css/"/>
    <id>http://www.liuzhidream.com/2018/10/22/HTML/css/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:57:58.053Z</updated>
    
    <content type="html"><![CDATA[<p>css总结</p><a id="more"></a><h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><p>style=’word-wrap:break-word; word-break:break-all;display:block;width:100%;’</p><h2 id="不换行"><a href="#不换行" class="headerlink" title="不换行"></a>不换行</h2><p>white-space:nowrap</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>style=”-webkit-appearance:checkbox”   复选相关样式</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul><li>使用 \&nbsp; </li><li>使用样式，输出1 &nbsp; 2 &nbsp; 3 &nbsp;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"white-space:pre"</span>&gt;</span>1  2  3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt; - 定义表行</span><br><span class="line">&lt;th&gt; - 定义表头</span><br><span class="line">&lt;td&gt; - 定义表元(表格的具体数据)</span><br></pre></td></tr></table></figure><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>width  100%   auto</p><ol><li><p>某div不显示设置宽度，那么width为auto</p></li><li><p>某div的width在默认情况设置的是盒子模型中content的值</p></li><li><p>某div的width为100%表示的是此div盒子内容部分的宽度为其父元素的宽度</p></li><li><p>某个div的width不设置，或者设置为auto，那么表示的这个div的所有部分（内容、边框、内边距等的距离加起来）为父元素宽度</p></li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>关于滚动条：overflow 决定了溢出的操作，设置溢出用滚动条，那么这个容器必须有固定高度，才有溢出的概念。</p><h2 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h2><p>scoped 属性是一个布尔属性。<br>如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。（在style type=”text/css” scoped  这里使用）</p><h2 id="css3-选择器"><a href="#css3-选择器" class="headerlink" title="css3 选择器"></a>css3 选择器</h2><ul><li>:nth-child(n)    —-&gt;选中某个元素，该元素必须是某个父元素下的第n个子元素</li><li>p:nth-child(n)   —-&gt;选中p元素，且该p元素必须是某个父元素下的第n个子元素</li></ul><p>如果n是数字，比如2，那么第2个作用样式，如果是n+2 那么从第2个开始，后面的都作用样式</p><h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><p>body 默认会有 margin 8px 这是浏览器决定的，不同浏览器不一样，所以初始创建一个项目，我们可以修改body 的css就可以0px 了</p><h2 id="内联和块级元素"><a href="#内联和块级元素" class="headerlink" title="内联和块级元素"></a>内联和块级元素</h2><p>块级元素特点：</p><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</p><p>内联元素(行内元素  inline)特点：</p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度及顶部和底部边距不可设置；</p><p>3、元素的宽度就是它包含的文字或图片的宽度，不可改变。</p><p>内联块级inline-block 元素特点：</p><p>1、和其他元素都在一行上；</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>CSS 盒子模型(Box Model)</p><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>盒子模型居中显示，设置内联元素时 text-align:center;  这句话就可以让内联元素居中设置块状元素时定宽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">div&#123;</span></span><br><span class="line"><span class="undefined">    border:1px solid red;/*为了显示居中效果明显为 div 设置了边框*/</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">    width:200px;/*定宽*/</span></span><br><span class="line"><span class="undefined">    margin:20px auto;/* margin-left 与 margin-right 设置为 auto */</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定宽就是width值固定，此时设置margin左或右为自动即可，注意两个设置缺一不可。</p><p>不定宽：</p><p>加table，或者将其改为内联</p><p>在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。)不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）：</p><ul><li>加入 table 标签</li><li>设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置</li><li>设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的<br>第一种方法：<br>为什么选择方法一加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。</li></ul><p>第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 \<tbody>、\<tr>、\<td> )。</td></tr></tbody></p><p>第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）。</p><p>举例如下：</p><p>html代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第一行文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第二行文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是第三行文本<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">css代码：</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">table&#123;</span></span><br><span class="line"><span class="undefined">    border:1px solid;</span></span><br><span class="line"><span class="undefined">    margin:0 auto;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>隐形改变display类型</p><ol><li>position : absolute </li><li>float : left 或 float:right 加入这两句话中任意一句，就可以将元素变化inline-block</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>:<span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a原来是内联的，不能改变width，加入绝对定位后变为内联块就可以了。</p><p>width   height是改变盒子的背景background,    font-size才是改变文字大小</p><h2 id="权值"><a href="#权值" class="headerlink" title="权值"></a>权值</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure><p>浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>层模型有三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>3、固定定位(position: fixed)</p><p>Relative与Absolute组合使用</p><p>在三种形式中，1是相对于浏览器，2是移动后原来位置有保留，3是固定盒子 <code>利用2，1可以实现相对与某一个的移动（不用相对于浏览器）</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，box2就是相对于box1来移动的</p><p>注意这样做的前提</p><p>参照定位的元素box1必须是相对定位元素box2的前辈元素</p><p>即：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span>&gt;</span>相对参照元素进行定位<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于代码编写时移动的问题</p><p>绝对定位中，比如实现div元素相对于浏览器右移100px</p><p>此时代码写为  left:100px；</p><p>注意理解绝对定位，先把我的盒子定位好，来移动浏览器，这样为了让我在浏览器的右边，浏览器应该左移，绝对定位。</p><p>另一个理解方法</p><p>有四个参数来设置   left  right  top  bottom</p><p>比如设置left=50px   可以理解为此时盒子与浏览器左边相距50px，也就是盒子右移动50px</p><p>补充：</p><ol><li>static（静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li>relative（相对定位）：生成相对定位的元素，通过top,bottom,left,right的设置相对于其正常（原先本身）位置进行定位。可通过z-index进行层次分级。　　</li><li>absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</li><li>fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过z-index进行层次分级。</li></ol><p>css 相对固定位置 处理方案：</p><p>需要固定位置的时候，常使用 <code>position：fixed</code> 这种方式往往达不到理想的效果，我们经常需要的是容器在某个位置固定，这样你需要花时间去调整左右上下参数。可以让fixed定位的容器处在一个父容器内，父容器是relative定位的，这样我们固定定位的容器就不用调整位置了，以父容器为基准</p><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rich_text_class"</span> <span class="attr">style</span>=<span class="string">"position:fixed;"</span> <span class="attr">v-html</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="index-z"><a href="#index-z" class="headerlink" title="index-z"></a>index-z</h2><p>z序决定了dom的层级关系，数值越大的在最上层。关于宽度，父容器的宽度受到子dom的影响，可以调整让子dom的宽度不超过父容器，在设置width属性的时候，是块的宽加上内边距，可以改属性，让这个width只有块的宽决定。理解外边距和内边距和元素自己。块级元素才是占一行。</p><h2 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h2><p><code>:hover { }</code> css选择器中对被选中对象做操作，效果为鼠标指向时代码作用。例子鼠标指向时修改文字颜色（注意不能直接在便签中加style=color  先设置颜色，class设置的颜色就会失效，应该是遵循了就近原则）</p><h2 id="超出显示文字省略"><a href="#超出显示文字省略" class="headerlink" title="超出显示文字省略"></a>超出显示文字省略</h2><p>css3 超出显示文字省略 <code>text-overflow: ellipsis; white-space: nowrap; overflow: hidden;</code></p><p>设置行数，超出行数省略</p><pre><code>overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;</code></pre><p>把该样式作用于p标签上</p><h2 id="控制锚点"><a href="#控制锚点" class="headerlink" title="控制锚点"></a>控制锚点</h2><ol><li><p>js控制锚点跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;anchor&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">location.hash=&quot;anchor&quot;;</span><br><span class="line"></span><br><span class="line">不只有a其他元素也可以，比如在报表中：</span><br><span class="line">&lt;tr id=&quot;tr1&quot;&gt;...&lt;/tr&gt;</span><br><span class="line">location.hash=&quot;tr1&quot;</span><br><span class="line"></span><br><span class="line">或者用jQuery的动画滚动效果：</span><br><span class="line">var id=&quot;tr1&quot;;</span><br><span class="line">$(&apos;html,body&apos;).animate(&#123;scrollTop: $(&quot;tr#&quot;+id).offset().top&#125;, 500);</span><br></pre></td></tr></table></figure></li><li><p>html控制锚点跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#btn&quot;&gt;跳转到点击位置&lt;/a&gt;</span><br><span class="line">&lt;a name=&quot;btn&quot; id=&quot;btn&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>跨页面锚点跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码如下:</span><br><span class="line">&lt;a href=&quot;123.html#btn&quot;&gt;跳到btn&lt;/a&gt;</span><br><span class="line">&lt;a name=&quot;btn&quot; id=&quot;btn&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>js控制锚点跳转在HTML中实现方式</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 假设一个需要跳转到的节点 --&gt;</span><br><span class="line">&lt;div id=&quot;divNode&quot;&gt;&lt;!-- contents --&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;#&quot; onclick=&quot;</span><br><span class="line">    document.getElemetnById(&apos;divNode&apos;).scrollIntoView(true);</span><br><span class="line">    return false;&quot;&gt;</span><br><span class="line">    通过scrollIntoView实现锚点效果</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>box-sizing属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。</p><p>简单来说就是改变盒子模型的计算方式，默认盒子模型，容器的width等于容器设置的width。如果box-sizing 设置为border-box 容器的宽度等于除外边距外的其它属性和。</p><h2 id="cursor-pointer"><a href="#cursor-pointer" class="headerlink" title="cursor: pointer"></a>cursor: pointer</h2><p><code>cursor: pointer</code> 运用了该属性，鼠标指上元素时变成“小手”</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>给元素添加背景，做一个图标按钮，需要设置padding 扩充元素大小，不然图片没法显示</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;css总结&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://www.liuzhidream.com/categories/css/"/>
    
    
      <category term="css" scheme="http://www.liuzhidream.com/tags/css/"/>
    
      <category term="html" scheme="http://www.liuzhidream.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/Vue/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/Vue/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:32.469Z</updated>
    
    <content type="html"><![CDATA[<p>Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。</p><a id="more"></a><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a href="https://www.jianshu.com/p/dc5057e7ad0d" target="_blank" rel="noopener">一个不错的“简书”入门</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/JavaScript/vue-1.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul><li><p>在通过ajax获取到数据需要赋值到data里面的时候，如果是不可变变量，可以直接赋值，但是如果是arrey，需要迭代每个值，加到data中。<code>Ajax.data.forEach(function(val, index){  vue.data.push(val) })</code>。</p></li><li><p>vue:在html中传递 this  ，在vue中this都是指向vue的组件，如果我们想使用原本的this指向这个dom,需要这样使用<code>dofunc($event)</code>。在函数里面 <code>dofunc(v){ v.target }</code>。如果转换为 jQuery 对象 <code>$(v.target)</code>  </p></li><li><p>vue:由于dom是由js去渲染的，所以你在渲染的时候去操作dom，是选不到的。这里涉及到了vue的生命周期的问题，实例创建完毕(挂载)，再去渲染dom。</p></li><li><p>vue:template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元，可以使html结构更加清晰，还可以改善一个标签过长的情况。</p></li><li><p>注册指令：全局注册，在new vue同块写Vue.directive局部注册，当前组件使用，作为vue实例的一个属性  directives  多了个 S<br>注册组件也是如此，和指令类似</p></li><li><p>在vue实例中的选择基本都是可以在组件里面使用的（vue实例怎么写组件就怎么写），但是data必须是函数，如果是一般的对象，你在组件里面使用这个对象会报错</p></li><li><p>单页面的VUE实例只有一个，组件化开了，要想从实例拿到data，只能是组件props向下传递，记得绑定想要的数据在你的模板上。向上使用events</p></li><li><p>props  data  是驼峰命名，绑定数据的写法 <code>&lt;child :msg-a=&quot;msgA&quot;&gt;&lt;/child&gt;  v-bind=&quot; a &quot;</code> 使用绑定，外部的引号不是想表达这个是个字符串，它应该当成一个变量，这也是在绑定url的时候，我们可以使用变量加上字符串，其中的字符串就用单引号。</p></li><li><p>props: 单项流数据，从父组件流向子组件，子组件试图修改它会报错，如果你要用它，应该把这个值给data，定义局部变量的方法。如果data是可变类型的，在子组件中修改了是会影响到父组件的。</p></li><li><p>props:验证，可以验证流进来的数据。验证在这个组件实例创建之前，所以你不能把这个组件里面的 option 诸如 data methods用在验证里面。</p></li><li><p>插槽：组件嵌套的时候使用，定义了如何进行内容分发</p></li><li><p>组件实例的作用域是孤立的</p></li><li><p>vue:自定义组件命名不要命名常见的（怕和框架冲突）</p></li><li><p>给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）。等同于在自组件中：子组件内部处理click事件然后向外发送click事件：<code>$emit(&quot;click&quot;.fn)</code></p></li></ul><h2 id="字符串模板和非字符串模板"><a href="#字符串模板和非字符串模板" class="headerlink" title="字符串模板和非字符串模板"></a>字符串模板和非字符串模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"component1"</span> <span class="attr">type</span>=<span class="string">"x-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实例中option使用 template 会把挂载元素的内容替换掉，在组件中 option 使用 template是HTML元素扩展被替换的内容，很像，都是替换。  </p><p>实例的模板字符串，执行元素的时候，此时元素应该是template标签或者 <code>script type=x-template</code> 都是把这两个的内容替换到实例挂载的元素上。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>vue指令类似 v-model 可以自定义指令，在创建实例的时候声明即可</p><p>目前的vue架构，对于一个vue文件来说，在里面使用其它组件（就是引用的各种组件），那么这些组件对于当前vue文件来说就是子组件，当前vue文件是父组件。这在理解一些概念的时候会有用，比如子组件 <code>双向绑定值</code> 使用 <code>sync</code> 来修饰，把子组件的某个属性绑定到父组件上，做到双向绑定。</p><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>v-bind</td><td style="text-align:center">动态绑定数据。简写为“:” =&gt; 以后的:class=”{red:boolean}” </td></tr><tr><td>v-on</td><td style="text-align:center">绑定时间监听器。简写为“@”，例：@click=”xxx”</td></tr><tr><td>v-text</td><td style="text-align:center">更新数据，会覆盖已有结构。类似 <code>{ {msg} }</code></td></tr><tr><td>v-show</td><td style="text-align:center">根据值的真假，切换元素的display属性</td></tr><tr><td>v-if</td><td style="text-align:center">根据值的真假，切换元素会被销毁、重建；=&gt; 在dom中已消失 </td></tr><tr><td>v-else-if</td><td style="text-align:center">多条件判断，为真则渲染</td></tr><tr><td>v-else</td><td style="text-align:center">条件都不符合时渲染</td></tr><tr><td>v-for</td><td style="text-align:center">基于源数据多次渲染元素或模块</td></tr><tr><td>v-model</td><td style="text-align:center">在表单控件元素（input等）上创建双向数据绑定（数据源）</td></tr><tr><td>v-pre</td><td style="text-align:center">跳过元素和子元素的编译过程</td></tr><tr><td>v-once</td><td style="text-align:center">只渲染一次，随后数据更新也不重新渲染</td></tr><tr><td>v-cloak</td><td style="text-align:center">隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;} </td></tr></tbody></table><h2 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>vue cli</td><td style="text-align:center">主要功能就是创建vue工程 </td></tr><tr><td>vue init webpack myproject</td><td style="text-align:center">构建vue项目 </td></tr></tbody></table><h2 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h2><p>ref 这个通常在元素上使用（组件自定义的元素也可以），比如现在有个组件 </p><ul><li><code>&lt;my-component&gt;&lt;/my-component&gt;</code></li><li>使用ref <code>&lt;my-component ref=&#39;new-name&#39; attr-a=&#39;hello&#39;&gt;&lt;/my-component&gt;</code></li><li>在 js  中 <code>this.$refs[&#39;new-name&#39;].attr  // res hello</code> 就可以通过别名获取到元素，并且拿到元素对应的属性。</li></ul><p>补充：</p><p>利用ref属性可以获取到dom元素或者是子组件，从而可以调用子组件的方法（注意2.0版本用ref取代了el）</p><ol><li>当ref直接定义在dom元素上时，则通过this.$refs.name可以获取到dom对dom进行原生的操作</li></ol><ul><li><code>&lt;div class=&quot;foods-wrapper&quot; ref=&quot;foods-wrapper&quot;&gt;</code></li><li>通过 <code>this.$refs</code> 获取到dom进行操作（注意ref属性的命名不能用驼峰，同时获取的时候也是）</li><li><code>let menuList=this.$refs[&#39;menu-wrapper&#39;].getElementsByClassName(&#39;menu-list-hook&#39;);</code> 此处如果用 <code>this.$refs[&quot;menuWrapper&quot;]</code> 将获取不到元素</li></ul><ol start="2"><li>通过在引用的子组件上使用ref属性实现父组件调用子组件的方法以及属性</li></ol><ul><li>在父组件中引用子组件并定义ref</li><li><code>&lt;v-food  ref=&quot;selectfood&quot;&gt;&lt;/v-food&gt;</code></li><li>调用定义在子组件中的方法show</li><li><code>this.$refs.selectfood.show();</code> 同时也可以调用子组件中的属性</li></ul><p>声明下上面说的是vue 2.0的</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>template是html5的一个新元素，主要用于保存客户端中的内容，表现为浏览器解析该内容但不渲染出来，可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。</p><h2 id="slot-插槽模板和非插槽模板"><a href="#slot-插槽模板和非插槽模板" class="headerlink" title="slot 插槽模板和非插槽模板"></a>slot 插槽模板和非插槽模板</h2><p>非插槽模板指的是html模板，比如 <code>div、span、ul、table</code> 这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制。</p><p>插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置确由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p><p>一般的用法就是在子组件里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 子组件名称：&lt;children&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;solt&gt;<span class="xml"><span class="tag">&lt;/<span class="name">solt</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 父组件是这样的 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;children&gt;</span><br><span class="line">        &lt;span&gt;被插入的内容，这整个span便签都会替换子组件中的solt&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;children/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><p>这就是匿名插槽或叫做具名插槽，就是 <code>&lt;span solt=&#39;name&#39;&gt; &lt;/span&gt;</code> 在父组件上为要插入的内容取个名字，子组件<code>&lt;solt name=&#39;name&#39;&gt;&lt;/solt&gt;</code> 这样来和父组件对应起来。</p><p>作用域插槽：这个概念比较难理解，先看怎么用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 父组件： --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"father"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这里是父组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!--第一次使用：用flex展示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="tmpl"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span v-for="item in user.data"&gt;&#123; &#123;item&#125; &#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第二次使用：用列表展示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li v-for="item in user.data"&gt;&#123; &#123;item&#125; &#125;&lt;/</span>li&gt;</span><br><span class="line">            &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第三次使用：直接显示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">        &#123; &#123;user.data&#125; &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">    我就是模板</span></span><br><span class="line"><span class="regexp">    &lt;/</span>child&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"child"</span>&gt;</span><br><span class="line">        &lt;h3&gt;这里是子组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 作用域插槽</span></span><br><span class="line"><span class="regexp">        &lt;slot :data="data"&gt;&lt;/</span>slot&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data: [<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wanwu'</span>,<span class="string">'zhaoliu'</span>,<span class="string">'tianqi'</span>,<span class="string">'xiaoba'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，子组件写法是 <code>&lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;</code> 把数据绑定给data属性，而且数据的来源是子组件，这点就很重要了。 在父组件会这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; &#123;scope.row.id&#125; &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时通过scope就可以拿到子组件绑定的data了，这个scope可以随便写。</p><p>在什么时候会用到呢？由于做研发比较少，但是用框架的时候你就要知道这种写法，通常会对子组件绑定父组件的数据，子组件拿到父组件的时候后，做了处理，得到自己的 data 就是上面插槽绑定的 data 这个时候你就可以去这个里面拿一些你像要的数据了。</p><p>像element UI 的table组件，通过给组件list数据，在 el-table-column 组件里面用作用域插槽就可以拿到赋值给list也就是表格的数据。</p><h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick"></a>this.$nextTick</h2><p>在vue中，当页面加载完成以后，dom还没有加载，是无法获取进行操作的，但是在vue2.0中提供了一个方法 <code>this.$nextTick</code>，在这个回调函数里面写dom操作即可，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do somthing</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实这里还有一个小技巧，就是用settimeout(fn,20),来取代this.$nextTick,（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。</p><p>现在vue都快要到3.o了，不要使用settimeout了，在使用 <code>this.$nextTick</code> 如果失败了，很可能是生命周期相关问题没处理好。</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>当我们需要跳转一个页面的时候，既然是单页面应用，可以使用路由会很方便，比如带很多的参数过去。如果是普通的url跳转只能在url里面带参数，限制较大</p><p>比如我们的跳转由方法来处理 <code>@click=&quot;getDescribe(article.id)&quot;</code></p><p>方法内容(三种情况)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">1.</span>基本使用 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path: <span class="string">`/describe/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 路由配置 --&gt;</span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/describe/:id'</span>,</span><br><span class="line">    name: <span class="string">'Describe'</span>,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">2.</span>通过路由配置的name来匹配 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    name: <span class="string">'Describe'</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">    id: id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">3.</span>通过path来匹配 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path: <span class="string">'/describe'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方案2要优雅的多，可以在params中传递参数，这里的id用来做路由传参了。 </p><p>在子组件中通过 <code>$route.params</code> 获取到参数。方案3为 <code>$route.query</code> 就是获取 <code>$route</code> 对象的属性了。</p><p>运用：通过方法查询接口，返回数据由路由来响应，把参数都传给子组件，子组件通过在created生命周期中 <code>this.$route</code> 获取传递给子组件的参数。</p><h2 id="v-html-与-深度作用选择器"><a href="#v-html-与-深度作用选择器" class="headerlink" title="v-html 与 深度作用选择器"></a>v-html 与 深度作用选择器</h2><p>vue 使用v-html指令渲染的页面样式处理问题</p><p>由于是动态加载的页面，在style中写的class不会作用于v-html渲染的内容，作者给出的解决方案是给外层容器加个类名, 然后用后代选择器，css的选择器可以是类选到类 <code>.classA .classB</code>， 选择元素的 <code>.classA a</code> (选择a标签)</p><p><code>.classA &gt; a</code> 只对一代a标签作用。直接这样写还不行，需要深度作用选择器 <code>.classA &gt;&gt;&gt; a</code>。 有些像 <code>Sass</code> 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>&gt;&gt;&gt;</code> 的别名，同样可以正常工作。</p><p>总结：在使用指令的便签上加个类，用这个类选择后代（注意要用深度作用选择器）这样就可以解决问题了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'myclass'</span> <span class="attr">v-html</span>=<span class="string">'content'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .myclass /deep/ a&#123;</span></span><br><span class="line"><span class="undefined">    font-size: 10px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在被渲染的Html里面加style（没有测试过，感觉是可行的）</p><h2 id="子组件向父组件传递事件"><a href="#子组件向父组件传递事件" class="headerlink" title="子组件向父组件传递事件"></a>子组件向父组件传递事件</h2><p>子组件向父组件传递事件，通常用来实现子组件向父组件传递值，然后调用父组件的方法</p><ul><li>在子组件中对某个标签绑定点击事件 <code>v-on:click=&quot;$emit(&#39;click_event&#39;, data.guid)&quot;</code></li><li>这样在父组件中我们可以监听这个事件，<code>&lt;article-classify v-on:click_event=&quot;classifyHandler&quot;&gt;&lt;/article-classify&gt;</code> 方法 <code>classifyHandler</code> 会接受传递的参数，也就是 <code>data.guid</code>，这样我们就拿到子组件传递来的参数了，然后后面的逻辑也就可以去跟着执行方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="Vue" scheme="http://www.liuzhidream.com/tags/Vue/"/>
    
      <category term="framework" scheme="http://www.liuzhidream.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/javascript/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/javascript/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:45:13.043Z</updated>
    
    <content type="html"><![CDATA[<p>javascript学习笔记</p><a id="more"></a><h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><p>DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;<br>复制代码 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domObj = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>); <span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(<span class="string">"#id"</span>); <span class="comment">//jQuery对象;</span></span><br></pre></td></tr></table></figure><p>jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例:</p><p>$(“#foo”).html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法;</p><p>上面的那段代码等同于:</p><p>document.getElementById(“foo”).innerHTML;<br>$(“#foo”).innerHTML  是错误的</p><p>可以将jquery 和 dom  对象互相转换，这样dom对象就可以使用jquery的方法了，jquery对象亦如此。</p><h2 id="Json-方法"><a href="#Json-方法" class="headerlink" title="Json 方法"></a>Json 方法</h2><p>JSON.stringify(a) stringify()用于从一个对象解析出字符串</p><p>JSON.parse(str)  parse用于从一个字符串中解析出json对象</p><h2 id="取得url中get请求的参数"><a href="#取得url中get请求的参数" class="headerlink" title="取得url中get请求的参数"></a>取得url中get请求的参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line"><span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);  </span><br><span class="line"><span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ready-和-onload事件"><a href="#ready-和-onload事件" class="headerlink" title="ready 和 onload事件"></a>ready 和 onload事件</h2><p>页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！) 一般样式控制的，比如图片大小控制放在onload 里面加载。 </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>JavaScript 关键字必须以字母、下划线（_）或美元符（$）开始。</p><p>后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开关键字和数字）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/JavaScript/keyword.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="BOM-amp-DOM"><a href="#BOM-amp-DOM" class="headerlink" title="BOM &amp; DOM"></a>BOM &amp; DOM</h2><ul><li>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。</li><li>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。</li><li>BOM的内容不多，主要还是DOM。</li></ul><h2 id="字面量，变量"><a href="#字面量，变量" class="headerlink" title="字面量，变量"></a>字面量，变量</h2><p>有时候会遇到字面量的概念，它和变量对应，字面量就是固定值的表示法。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>js也有异常，不过很少见人使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//错误判断</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x == <span class="string">""</span>) <span class="keyword">throw</span> <span class="string">"值为空"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">"不是数字"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x &gt; <span class="number">10</span>) <span class="keyword">throw</span> <span class="string">"太大"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x &lt; <span class="number">5</span>) <span class="keyword">throw</span> <span class="string">"太小"</span>;</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">catch</span> (err) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//发生错误时在此执行，err为自定义错误 throw 对应的值，</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> y = <span class="built_in">document</span>.getElementById(<span class="string">"mess"</span>);</span></span><br><span class="line"><span class="javascript">y.innerHTML = <span class="string">"错误："</span> + err + <span class="string">"。"</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 JavaScript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请输出一个 5 到 10 之间的数字:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>测试输入<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"mess"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的定义方式大体有以下两种，浏览器对于不同的方式有不同的解析顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“定义式”函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“赋值式”函数定义</span></span><br><span class="line"><span class="keyword">var</span> Fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello wild!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速测试一段代码的执行时间"><a href="#快速测试一段代码的执行时间" class="headerlink" title="快速测试一段代码的执行时间"></a>快速测试一段代码的执行时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment">/* 这里运行待测代码 */</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><h2 id="对象总结"><a href="#对象总结" class="headerlink" title="对象总结"></a>对象总结</h2><p>对象</p><ol><li>javascript 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS Array     JS Boolean   JS Date  </span><br><span class="line">JS Number    JS String    JS RegExp </span><br><span class="line">JS Functions JS Events    JS Math</span><br></pre></td></tr></table></figure><p>其它对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Browser  Window  Navigator </span><br><span class="line">Screen   History Location</span><br></pre></td></tr></table></figure><p>Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。</p><ol start="2"><li>HTML DOM 对象</li></ol><ul><li>每个载入浏览器的 HTML 文档都会成为 Document 对象。</li><li>Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</li></ul><p>Element 节点，文本节点，元素节点等。</p><p>Attribute 属性； Event 事件； HTML 对象；</p><p>标签即是HTML对象，标签和元素的区别，属性的定义：</p><pre><code>比如&lt;p&gt;这就是一个标签； &lt;p&gt;这里是内容&lt;/p&gt;这就是一个元素，也就是说元素由一个开始的标签和结束的标签组成，用来包含某些内容。</code></pre><p>属性：</p><p>为HTML元素提供各种附加信息的就是HTML属性，它总是以”属性名=属性值”这种名值对的形式出现，而且属性总是在HTML元素的开始标签中进行定义。</p><p>节点的作用：</p><p>在有了标签，元素，属性后，引申出节点的概念，标签的元素中可能会有更多的元素，将多个或一个元素看作节点，节点就是为了去操作元素的。</p><h2 id="virtual-DOM"><a href="#virtual-DOM" class="headerlink" title="virtual DOM"></a>virtual DOM</h2><p>一些理解：</p><p>虚拟DOM，是一个模拟DOM数的js对象。 就是当我们需要更改DOM的时候，如果用原始方法比较慢，这在多节点的页面中体现就更明显了，原因是dom设计的复杂，所以我们用一个虚拟的DOM，虚拟的DOM记录了要更改的DOM，它通常不是立刻执行的，等到需要的时候，计算最小的执行，把执行更新到DOM上。这里为什么会有最小的DOM执行，是应为不是所有的地方都需要变更。</p><p>总结：virtual DOM 通过计算最小的DOM执行，能更快的渲染DOM。</p><p>别人的讲解：</p><ul><li>Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。</li><li>React 主要的目标是提供一套不同的, 高效的方案来更新 DOM.不是通过直接把 DOM 变成可变的数据, 而是通过构建 “Virtual DOM”, 虚拟的 DOM, 随后 React 处- 理真实的 DOM 上的更新来进行模拟相应的更新。</li></ul><p>引入额外的一个层怎么就更快了呢?</p><ul><li>那不是意味着浏览器的 DOM 操作不是最优的, 如果在上边加上一层能让整体变快的话?是有这个意思, 只不过 virtual DOM 在语义上和真实的 DOM 有所差别.最主要的是, virtual DOM 的操作, 不保证马上就会产生真实的效果.这样就使得 React 能够等到事件循环的结尾, 而在之前完全不用操作真实的 DOM。在这基础上, React 计算出几乎最小的 diff, 以最小的步骤将 diff 作用到真实的 DOM 上。批量处理 DOM 操作和作用最少的 diff 是应用自身都能做到的.任何应用做了这个, 都能变得跟 React 一样地高效。但人工处理出来非常繁琐, 而且容易出错. React 可以替你做到。</li><li>前面提到 virtual DOM 和真实的 DOM 有着不用的语义, 但同时也有明显不同的 API。</li><li>DOM 树上的节点被称为元素, 而 virtual DOM 是完全不同的抽象, 叫做 components。</li><li>component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。</li></ul><p>简单的说就是：</p><p>当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p><p>React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 </p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>数组过滤。indexOf作用是返回字符串第一次出现在给定字符串的index，可以用来处理某个字符串有没有在给定字符串中。  给定 <code>str.indexOf(某个字符串) = 0</code> 说明第一个就匹配到，这个给定字符串。如果是空格分隔的，如几个单词，那么结果就不一定是0了，因为会在后面的位置。记住是给定来调用这个方法就行了</p><p>补充：</p><p>js array indexOf 参数是对象的时候，不一定能返回对应位置的index(有的时候可以，我查了资料，有人是这么说的：让数组去判断<code>一个新创建的对象</code>，所以会得到 -1。我在vue中，把循环出来的元素做为参数去在原数组中判断，是可以的，不是循环出来的对象，虽然对象和数组元素字面看起来一摸一样，但是不行，猜测这和底层有关) 所以这个东西的使用，要很小心<br>推荐使用 <code>Array.findIndex()</code></p><p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstLargeNumber</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> element &gt; <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.findIndex(findFirstLargeNumber));</span><br><span class="line"><span class="comment">// expected output: 3</span></span><br></pre></td></tr></table></figure><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found = array1.find(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> element &gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure><p>通过find，findIndex可以完成很多的事情，少用通过各种方法获取索引，然后再去 <code>array[index]</code>。find就可以了</p><p>更详细的使用查看文档。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">文档地址</a></p><p>我发现这个从列表中给出来的数据，你不段的引用，其中一个引用改了，也会影响到原数组。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`a<span class="subst">$&#123;<span class="keyword">var</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>如果var是1，result 为 a1。注意两边的符号为tab键上面的</p><h2 id="bject-keys-obj"><a href="#bject-keys-obj" class="headerlink" title="bject.keys(obj)"></a>bject.keys(obj)</h2><p>返回值: 一个表示给定对象的所有可枚举属性的字符串数组</p><ol><li><p>传入字符串，返回索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: ['0', '1', '2']</span></span><br></pre></td></tr></table></figure></li><li><p>传入对象，返回属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="string">'alive'</span>, <span class="attr">b</span>: <span class="string">'bike'</span>, <span class="attr">c</span>: <span class="string">'color'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>只对字符串和数组有用，整形数字和对象返回未定义undefined</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>数组调用，监测数组是否包含给定的元素 <code>array.include(0)</code> 返回boolean</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>箭头函数与普通函数中的this指向不一样，前者基于定义时的上下文环境，后者则只是基于调用者。</p><h2 id="typeof-cb-“function”-amp-amp-cb"><a href="#typeof-cb-“function”-amp-amp-cb" class="headerlink" title="typeof cb == “function” &amp;&amp; cb()"></a>typeof cb == “function” &amp;&amp; cb()</h2><p>强大的js总有一些没见过的用法</p><p><code>function delay(time, cb) { typeof cb == &quot;function&quot; &amp;&amp; cb(time) }</code></p><p><code>cb&amp;&amp;cb(value)</code> 的意思是：</p><ul><li>如果cb为真（有值），那么执行cb(value)；</li><li>如果cb为假，&amp;&amp;短路，那么不执行cb(value)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>linux-base</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Linux/linux-base/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Linux/linux-base/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:48:05.168Z</updated>
    
    <content type="html"><![CDATA[<p>Linux学习笔记</p><a id="more"></a><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>/etc<br>存放系统管理和配置文件</p><p>/usr  (Unix System Resource)<br>用于存放系统应用程序，比较重要的目录/usr/local本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。</p><p>/usr/bin众多的应用程序<br>/usr/sbin超级用户的一些管理程序</p><p>/usr/src源代码，linux内核的源代码就放在/usr/src/linux里</p><p>/usr/local/bin本地增加的命令<br>/usr/local/lib本地增加的库</p><p>/proc<br>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</p><p>/sbin<br>存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等</p><p>一般，系统带的应用在/usr/bin   自己安装的在/usr/local/bin，/usr/sbin 也会有应用</p><p>如果你是编译安装的，最好用ln -s 源命令 /usr/local/bin，把编译安装的启动程序在通用安装目录下创建符号链接，这样就能直接在任何地方从命令行运行程序</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>目录（d）   文件（-）  字符型文件（c ）  块设备（b） l 链接文件   p 管道文件</p><p>创建文件  touch</p><p>复制文件  cp -i  (覆盖提醒) cp -i file newfile</p><p>链接文件（new）    命令  ln</p><p>有硬链接和符号链接（软链接）</p><p>重命名  命令 mv</p><p>mv  a  b   操作上称为移动文件，a在当前目录移动成b，实现了修改名字的作用</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>权限 r  w  x  文件的权限如下图所示，开始指文件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root  664 Apr 12 22:46 uwsgi_params</span><br><span class="line">-rw-r--r-- 1 root root 3610 Apr 12 22:46 win-utf</span><br></pre></td></tr></table></figure><p>除去类型，开始三个 rw-  描述的是文件所有者的权限，r–  文件所属组 ，最后是其他用户。</p><p>关于所属组，比如system组，可以执行系统相关命令，当某个用户被临时加入到系统组，则该用户将拥有对应权限，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r-xr-sr-x（- 类型， r-x 文件所有者权限  r-s  文件所属组权限  r-x 文件其它用户权限</span><br></pre></td></tr></table></figure><p>如某个用户像执行它，只要加入系统组即可。</p><p>文件特殊权限  <code>SUID</code>   <code>SGID</code></p><p>目录给予SGID权限，该目录下创建的文件都将是这个组的。</p><p>目录设置SBIT位，只能自己修改目录下的文件，该目录可能创建多个文件（不同用户），防止别人来修改自己的文件。</p><p>文件权限可以隐藏，此时ls -l 看不到，用lsattr查看隐藏权限。  </p><p>更进一步，对某个命令设置特定用户才能执行，对某个用户做设置。</p><p>权限后面是链接数，然后是文件所属用户名，之后是所属组名，然后文件大小，日期时间，文件名。</p><p>记住，一个文件被创建的时候，它拥有inode和block，每个文件占用一个独立的inode table，记录文件的权限和属性，包括数据地址。block数据存放的实际内容。ls -il  这个i参数可以查看inode。</p><p>知道该文件的einode，使用find-inum 可以找到所有指向inode的文件。</p><p>补充：</p><p>符号链接，可以对文件和目录创建符合链接。符号链接可以理解为快捷方式，它和原文件是两个不同的文件，所有他们的inode不一样，而且他数据很小，因为只做指向。在ls命令下，可以看到文件类型是 <code>l</code>，并且后面会有 <code>fileA -&gt; fileB</code>，意为A是B的符号链接。原始文件被删除后，符号链接也失效。可以跨文件系统创建符号链接。不要创建符号链接的符号链接。</p><p>硬链接，会创建独立的虚拟文件，但是共享原文件的inode，使用ls命令查看，会发现它们完全一样（链接数都是2），除了名字外。引用硬链接等于引用原文件。不能对目录创建硬链接（目录下的所有数据都会被创建硬链接），不能跨文件系统。</p><h2 id="挂载与分区"><a href="#挂载与分区" class="headerlink" title="挂载与分区"></a>挂载与分区</h2><p>linux 硬盘第一扇区512byte，记录着主引导记录和分区信息。主引导占了446byte，后面的空间一般分配3个主分区，1个扩展分区。每个占16byte。如果全是主分区，只能有4个，所以主分区不能超过4个。</p><p>挂载，/etc/fstab记载着挂载信息，SWAP称为交换分区，类似虚拟内存。</p><h2 id="磁盘冗余阵列"><a href="#磁盘冗余阵列" class="headerlink" title="磁盘冗余阵列"></a>磁盘冗余阵列</h2><p><strong>RAID</strong></p><p>RAID 0～RAID 50等数个规范</p><p>RAID 0是组建磁盘阵列中最简单的一种形式，只需要2块以上的硬盘即可，成本低，可以提高整个磁盘的性能和吞吐量。RAID 0没有提供冗余或错误修复能力，但实现成本是最低的。最大的缺点在于任何一块硬盘出现故障，整个系统将会受到破坏，可靠性仅为单独一块硬盘的1/N。</p><p><strong>RAID1</strong></p><p>称为磁盘镜像，原理是把一个磁盘的数据镜像到另一个磁盘上，也就是说数据在写入一块磁盘的同时，会在另一块闲置的磁盘上生成镜像文件，在不影响性能情况下最大限度的保证系统的可靠性和可修复性上，只要系统中任何一对镜像盘中至少有一块磁盘可以使用，甚至可以在一半数量的硬盘出现问题时系统都可以正常运行,当一块硬盘失效时，系统会忽略该硬盘，转而使用剩余的镜像盘读写数据，具备很好的磁盘冗余能力。缺点磁盘利用率不高。</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>这是linux的模块，python 的 torado会对其进行封装，提供接口，是实现高并发的关键。BSD系统的是kqueue，大概概念应该是类似的，BSD接触的较少了。</p><p>epoll是整个框架实现高性能的基础，所以为了发挥性能，你需要把程序部署在linux上，使用linux的epoll。 </p><p>要理解这个模块是做什么的，先说任务阻塞，多个任务阻塞了，一般的操作系统机制是使用轮询的方法，循环所有阻塞任务，看是否有被唤醒的，这样太浪费时间了，如果当前循环任务没有被唤醒的，CPU白白浪费了一次循环，所以有了epoll 这是一个代理，在操作系统设计的代码大概是这样的，原来的思路是循环任务列表，现在使用epoll，被循环的任务列表将由epoll提供，如果没有，那么CPU就不用浪费时间了，那么什么情况下会有呢？就是当有任务被唤醒的时候，比如任务因为别人的事件被唤醒，比如A给被阻塞的任务B一个事件“缓冲区非空”，B得到这个事件，B不用被阻塞了，它需要去缓冲区读取数据，这个时候就通知epoll，我可以被调度了。epoll的好处就是可以告诉内核那个任务可以调度，传统的轮询要一个一个任务的查看谁能被调度，如此，加入一个代理加快了CPU处理任务的速度。</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。 </p><p>nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p><p>安装 <code>apt-get install -y supervisor</code></p><p>注意：终止进程后重启电脑，进程将会重启。所以要移除某个进程，要把对应的配置删除。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>什么是守护进程？其实感觉守护进程并没有什么明确的定义，只是守护进程有一些特征，这是它需要遵循的。</p><p>守护进程的第一个特征是长时间在后台运行的程序，并且主要是为了提供某种服务，而为了能够让服务尽可能随时都可用，就要求这个服务是一直运行的，于是守护进程就守护着这个服务不挂掉。linux里面常见的守护进程一般都是以d结尾的，比如apache的httpd,samba的smbd,ssh的sshd。</p><p>它的第二个特征是与启动它的进程的环境隔离，包括关闭它打开的所有文件描述符，终端，会话，进程组，某些环境变量（如工作目录），文件掩码。</p><ol><li>为什么要脱离终端？</li></ol><p>如果它不脱离终端，那么就有可能收到来自终端的信号，比如SIGINT(Ctrl+c,会被发往所有前台进程组的进程，它的默认行为就是结束进程),SIGHUP（会被发往会话首进程）</p><ol start="2"><li>为什么要关闭它打开的所有文件描述符？</li></ol><p>如果创建它的进程之前打开了某个文件，然后创建这个守护进程，这样子进程就继承了fd,如果守护进程不关闭这个fd,一个是会占用资源，二个我猜测和改变工作目录一样，如果这个文件是位于挂载目录，那么就无法umount了</p><ol start="3"><li>为什么要清掩码？</li></ol><p>这是因为假设它的父进程之前对掩码做过特殊设置，守护进程作为子进程会继承这个，那么它创建文件时，因为掩码的缘故，文件的权限就可能和实际设置的不一致。</p><p>第三个特征，守护进程通常由启动脚本启动</p><h1 id="apt-utils"><a href="#apt-utils" class="headerlink" title="apt-utils"></a>apt-utils</h1><p>apt-utils是Linux系统的兼容程序，在安装系统时有提示推荐安装apt-utils，如果未安装会无法安装第三方提供的Linux软件，只能使用官方推出的软件。比如wget是第三方软件，如果没有apt-utils会导致安装不上</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://www.liuzhidream.com/2018/10/22/MySql/base/"/>
    <id>http://www.liuzhidream.com/2018/10/22/MySql/base/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.696Z</updated>
    
    <content type="html"><![CDATA[<p>mysql学习笔记</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>一般对于命令是不区分大小写的，为了区分保留关键字，一般保留关键字大写，变量和数据小写。</p><p>sudo service mysql start</p><p>mysql -u root</p><p>mysql -u root -p</p><p>show databases;</p><p>use dataname;</p><p>show tables;</p><p>create database; 库名    //创建数据库</p><p>drop databses; 库名      //删除数据库</p><p>请先到 /etc/mysql   配置  my.cnf  避免中文插入有误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[client]  </span><br><span class="line">default-character-set=utf8  </span><br><span class="line">  </span><br><span class="line">[mysqld]  </span><br><span class="line">character-set-server=utf8  </span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure><p>mysql –verbose –help | grep -A 1 ‘Default options’ </p><h2 id="理解数据库和实例，数据库引擎"><a href="#理解数据库和实例，数据库引擎" class="headerlink" title="理解数据库和实例，数据库引擎"></a>理解数据库和实例，数据库引擎</h2><p>关于引擎：引擎是数据库进行读写，保存，执行事务等一系列行为时，如何进行这些行为，就是由引擎来决定的。mysql默认会使用InnoDB引擎，引擎可以修改，可以对表指定不同的引擎（数据库应该要支持这种引擎），例如对于需要大量数据访问的，指定查询能力较强的引擎，对于需要事务处理的表，指定能处理事务的引擎。有些引擎是不支持事务的，InnoDB是功能较为齐全的引擎，各方面能力均衡。</p><p>索引：引擎不同，索引的实现也不用，保存的索引文件也不同（对于数据库来说，会有表结构文件，表数据文件，索引文件等，引擎不同也文件也不同，因为存储方式不一样）。索引类型   B-Tree索引，哈希索引，空间数据索引（R-Tree），全文索引（数据库引擎要支持，这种索引用来做海量搜索，但是如果需求高，还是用专业的搜索引擎）。<br>主键索引，唯一索引，普通索引</p><p>mysql锁：大致分为表级锁，行级锁，页面锁。理解这三种锁很简单，从字面就可以看出锁的锁定粒度，也就知道他们的区别了。其中这个页面锁的粒度介于另外两者之间。同样，锁怎么去控制数据库，也是和引擎有关的。</p><p>乐观和悲观：常会看到乐观锁，悲观锁，是一类概念的统称，比如假定对数据库的操作都会产生资源竞争的问题，这个时候就要锁库，悲观的做法就是都锁，实现这样的锁也可以被称为悲观锁。乐观的概念就是相反的，你假定不会出现资源竞争的情况。</p><p>悲观的做法</p><p>悲观的做法表明，您应该完全锁定资源，直到完成它 。 如果没有人可以在您处理对象时获取对象上的锁定，那么可以确保对象没有被更改。<br>我们使用数据库锁有几个原因：</p><ol><li>数据库非常擅长管理锁并保持一致性。</li><li>数据库是访问数据的最低级别 - 获取最低级别的锁也会防止其他进程尝试修改数据。 例如，DB中的直接更新，cron作业，清理任务等。</li><li>Django应用程序可以在多个进程 （例如工作者）上运行。 在应用程序级别维护锁将需要大量（不必要的）工作。</li></ol><p>要在Django中锁定一个对象，我们使用 <code>select_for_update</code>。</p><p>主键 id int primary key not null auto_increment</p><p>外键 CONSTRAINT emp_fk FOREIGN KEY (in_dpt) REFERENCES department(dpt_name) CONSTRAINT 后面的名字在一张表里面不能重复</p><p>插入数据  INSERT INTO tablename (column, column)  VALUES （values）</p><p><strong>数据类型</strong></p><p>除了我们常用的，补充  可变字符VARCHAR， ENUM单选（必须是定义时枚举的值之一） SET多选 </p><p><strong>SQL约束</strong></p><p>通过对表的行为或列的数据做出限制，来确保表的数据的完整性、唯一性</p><p><strong>约束类型</strong></p><p>主键  默认值  唯一  外键 非空</p><p>主键 ：对于主键还有复合主键，由两个字段来确定唯一性，比如一个学生成绩表，有学号，课程号，成绩。通过学号和课程号我们可以得到他的成绩，这个两个字段就组成复合主键，联合主键就是多个字段来决定主键。</p><p>唯一 ： 这个约束就是这个字段的这一列的值是唯一的，在执行INSERT 语句的时候，如果插入重复的值则会失败。例如 UNIQUE （phone） 对这个字段进行唯一约束</p><p>非空约束： age INT(10) NOT NULL, 在创建的表的语句中出现了这个，就是非空约束，如果插入数据的时候不填，会警告，不会报错。（可能有些mySQL版本会报错）</p><p>select  fields from table where 限制条件</p><p>限制条件比如大于小于，在什么范围。 where in (3, 10)  where not in (5, 20)</p><p>where age between 20 and 25  年龄在20到25包括20和25</p><p>通配符  where fieldname like ‘12_’  可以匹配到123 125等   用  %  代表不定个未指定字符</p><h2 id="其它内容"><a href="#其它内容" class="headerlink" title="其它内容"></a>其它内容</h2><p>合并排序：一种将数据排序的算法，在数据库排序的时候使用，这种算法比较灵活，比如你不必把数据完全读取出来，这种方法称为 原地排序</p><p>二维阵列：最简单的数据结构，就是一张表</p><p>二叉查找树：用来做索引。数据在保存的时候，如果使用了索引，则这个索引信息将建立一个二叉查找树。当然的，你每次更新新的数据都要维护和更新这个查找数，这个算法比起从头到尾查找数据，将会快很多。</p><p>B+索引树：二叉的升级版，新的索引结构方式，支持范围查找，比如1到5，你只要找到1，在结果里面，1下面对应的数据一直到5，我们需要的就得到了。如果是二叉树，那么你要找1，然后找2，2还不一定有，接着找3…</p><p>哈希表：是一种数据结构，保存的数据是键值对类型的。散列函数（哈希函数）是把键转换成哈希码的函数，散列表（哈希表）是存放记录的数组（这个记录空间是一片连续的空间），数据的键通过散列函数得到一样结果的，都分类在一个数组里面。  概述就是对数据保存进行哈希，得到一个哈希表，去查找数据的时候，对数据的键进行哈希函数运算（得到哈希码后，可能还要进行求模运算才得到记录数组的下标），得到的结果就是记录里面数组的下标，在这个数组里面去找值。</p><p>一些概念扩展：数据库是数据库和实例结合的，数据库服务被启动后，用户需要链接到服务上，我们去链接数据库后，系统为你分配了各种资源来操作数据库，就是你得到了数据库的一个实例。这个链接由客户端管理器来处理</p><p>多实例：理解了实例和数据库后，我们可以使用多实例，你只需要部署一次数据库应用（在linux上装一个MySql server）然后通过多个实例进行链接，生成的数据库文件也是多个的，这样可以实现很多功能，比如主从数据库。</p><p>数据库是多个组件构成的：一般有查询管理器，数据管理器，工具，核心组件</p><p>核心组件：<br>进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。<br>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。<br>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。<br>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。<br>安全管理器（Security Manager）：用于对用户的验证和授权。<br>客户端管理器（Client manager）：用于管理客户端连接。<br>……</p><p>工具：<br>备份管理器（Backup manager）：用于保存和恢复数据。<br>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。<br>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。<br>Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。<br>……</p><p>查询管理器：<br>查询解析器（Query parser）：用于检查查询是否合法<br>查询重写器（Query rewriter）：用于预优化查询<br>查询优化器（Query optimizer）：用于优化查询<br>查询执行器（Query executor）：用于编译和执行查询<br>数据管理器：<br>事务管理器（Transaction manager）：用于处理事务<br>缓存管理器（Cache manager）：数据被使用之前置于内存，或者数据写入磁盘之前置于内存<br>数据访问管理器（Data access manager）：访问磁盘中的数据</p><p>获取数据和联接数据</p><p>如何获取数据？</p><p>全扫描：完全读取一个表或者索引</p><p>范围扫描：where语句</p><p>唯一扫描：索引中获取一个值</p><p>存取路径：</p><p>1、问题的提出</p><p>数据库必须支持多个用户的多种应用，因而也就必须提供对数据访问的多个入口，也就是说对同一数据的存储要提供多条存取路径。数据库物理设计的任务之一就是确定应建立哪些存取路径。存取路径即索引结构，因为索引结构提供了定位和存取数据的一条路径。存取方法是快速存取数据库中数据的技术。数据库管理系统一般都提供多种存取方法。常用的存取方法有三种：</p><ul><li>索引方法；</li><li>簇集方法；</li><li>HASH方法；</li></ul><p>B+树索引方法是数据库中经典的索引存取方法，使用最普遍。</p><p>2、存取路径的特点</p><p>在关系数据库中存取路径具有以下特点：</p><ul><li>存取路径和数据是分离的，对用户来说是不可见的；</li><li>存取路径可以由用户建立、删除，也可以由系统动态地建立、删除。例如，在执行查询时DBMS的查询优化器会根据优化策略自动地建立索引，以提高查询效率；</li><li>存取路径的物理组织通常采用顺序文件、Ｂ+树文件和散列文件结构等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.liuzhidream.com/categories/database/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Python-multiprocessing</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Python-multiprocessing/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Python-multiprocessing/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>python多进程学习笔记</p><a id="more"></a><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>Python标准库为我们提供了 <code>threading</code> 和 <code>multiprocessing</code> 模块编写相应的多线程/多进程代码。从Python3.2开始，标准库为我们提供了 <code>concurrent.futures</code> 模块，它提供了 <code>ThreadPoolExecutor</code> 和 <code>ProcessPoolExecutor</code> 两个类，实现了对 <code>threading</code> 和 <code>multiprocessing</code> 的更高级的抽象，对编写线程池/进程池提供了直接的支持。 </p><p>concurrent.futures基础模块是executor和future。future是concurrent.futures模块和asyncio模块的重要组件</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>pid=os.fork()</p><ol><li>只用在Unix系统中有效，Windows系统中无效</li><li>fork函数调用一次，返回两次：在父进程中返回值为子进程id，在子进程中返回值为0</li></ol><h3 id="和线程的区别"><a href="#和线程的区别" class="headerlink" title="和线程的区别"></a>和线程的区别</h3><p>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>python中，进程池内部会维护一个进程序列。当需要时，程序会去进程池中获取一个进程。如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。</p><p>进程池支持同步，异步，映射方式添加任务到进程池。</p><h3 id="预创建"><a href="#预创建" class="headerlink" title="预创建"></a>预创建</h3><p>预先创建一组子进程，当有新任务来时，系统通过 调配 该组进程中的某个 子进程 完成此任务。</p><p>为什么需要？</p><ol><li>进程创建，销毁需要消耗cpu时间</li><li>预先创建，以空间换时间，提升性能。时间是唯一稀缺资源，空间不足加内存，能够用钱解决的问题，都不是问题，钱都解决不了的问题才是问题</li><li>通过系统合理分配任务，提高性能。尽量实现真正的并行处理，提升系统处理效率</li></ol><h3 id="关于GIL"><a href="#关于GIL" class="headerlink" title="关于GIL"></a>关于GIL</h3><p>多进程，一个进程就有一个GIL</p><h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>我们知道现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，<strong>每个进程可以拥有4G字节的虚拟空间</strong>。我们常说的陷入内核态，就是当前进程进入内核，去访问更高权限的东西。</p><p>需要注意的细节问题：</p><ul><li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </li><li>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</li><li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</li><li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li></ul><h3 id="windows中创建进程"><a href="#windows中创建进程" class="headerlink" title="windows中创建进程"></a>windows中创建进程</h3><p>在windows中创建进程，相当于导入模块，所以要把进行放在 <code>if __name__ == &#39;__main__&#39;:</code> 后面来执行，而且子进程会把代码再跑一次，如果你在代码块最外层有打印等执行语句，也会被执行（所以一般外层的代码都封装在函数里面，在linux上不会这样，由于外层代码不一定全是函数，只要是会被执行的都要执行，这和想像的情况相差太多，所以我建议多进程只在linux上使用，在windos上的多进程，只有演示学习的意义，过于复杂的程序受到太多的限制）</p><p>这是 Windows 上多进程的实现问题。在 Windows 上，子进程会自动 import 启动它的这个文件，而在 import 的时候是会执行这些语句的。如果你这么写的话就会无限递归创建子进程报错。但是在multiprocessing.Process的源码中是对子进程再次产生子进程是做了限制的，是不允许的，于是出现如上的错误提示。所以必须把创建子进程的部分用那个 if 判断保护起来，import 的时候 name 不是 main ，就不会递归运行了。</p><h3 id="操作系统的设计"><a href="#操作系统的设计" class="headerlink" title="操作系统的设计"></a>操作系统的设计</h3><ol><li>以多进程形式，允许多个任务同时运行；</li><li>以多线程形式，允许单个任务分成不同的部分运行；</li><li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库提供了队列模块queue，在py2中，通过 <code>import Queue</code> 使用队列，在py3中通过 <code>from queue import Queue</code> 来使用队列。<br>在multiprocessing模块中，通过了Queue类来实现队列。queue.Queue是进程内非阻塞队列，multiprocess.Queue是跨进程通信队列。</p><ol><li><p>from queue import Queue<br>这个是普通的队列模式，类似于普通列表，先进先出模式，get方法会阻塞请求，直到有数据get出来为止</p></li><li><p>from multiprocessing.Queue import Queue（各子进程共有）<br>这个是多进程并发的Queue队列，用于解决多进程间的通信问题。普通Queue实现不了</p></li></ol><h3 id="multiprocessing-Queue"><a href="#multiprocessing-Queue" class="headerlink" title="multiprocessing.Queue"></a>multiprocessing.Queue</h3><p>queue = Queue(5) 初始化Queue()对象时（ 例如：q=Queue() ），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）</p><p>Queue.qsize()：返回当前队列包含的消息数量，结果不可靠，理由同q.empty()和q.full()一样</p><p>Queue.empty()：如果队列为空，返回True，反之False。该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。</p><p>Queue.full()：如果队列满了，返回True，反之False。该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。</p><p>Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；这里的block代表阻塞。</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出”Queue.Empty”异常</p></li><li><p>如果block值为False，消息列队如果为空，则会立刻抛出”Queue.Empty”异常</p></li></ul><p>Queue.get_nowait()：相当Queue.get(False)</p><p>Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True</p><ul><li><p>如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常</p></li><li><p>如果block值为False，消息列队如果没有空间可写入，则会立刻抛出”Queue.Full”异常</p></li></ul><p>Queue.put_nowait(item)：相当Queue.put(item, False)</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>进程间通信（IPC）方式二：管道</p><p>创建管道的类：<code>Pipe([duplex])</code>，在进程之间创建一条管道，并返回元组（conn1,conn2），其中conn1，conn2表示管道两端的连接对象，强调一点：<strong>必须在产生Process对象之前产生管道</strong></p><p>参数介绍：</p><p>duplex:默认值是True，管道是全双工的，如果将duplex改成False，conn1只能用于接收，conn2只能用于发送。</p><p>方法介绍：（详情参考文档：multiprocessing.connection.Connection类）</p><ul><li>conn1.recv()：接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError</li><li>conn1.send(obj)：将一个对象发送到应该使用recv()读取的连接的另一端。obj必须是与序列化兼容的任意对象。非常大的pickle(大约32 MiB+，尽管这取决于操作系统)可能会引发ValueError异常</li><li>conn1.close()：关闭连接。如果conn1被垃圾回收，将自动调用此方法</li><li>conn1.fileno()：返回连接使用的整数文件描述符</li><li>conn1.poll([timeout])：返回是否有任何数据可供读取(如果连接上的数据可用，返回True)。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达</li><li>conn1.recv_bytes([maxlength])：接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常</li><li>conn.send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收    </li><li>conn1.recv_bytes_into(buffer [, offset])：接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。</li></ul><p>代码举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(p, name)</span>:</span></span><br><span class="line">    left_conn, right_conn = p</span><br><span class="line">    left_conn.close()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = right_conn.recv()</span><br><span class="line">            print(<span class="string">'%s 消费产品:%s'</span> % (name, data))</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            right_conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(sequence, p)</span>:</span></span><br><span class="line">    left_conn, right_conn = p</span><br><span class="line">    right_conn.close()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">        left_conn.send(i)</span><br><span class="line">        print(<span class="string">'%s 生产产品:%s'</span> % (<span class="string">'c2'</span>, i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left_conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    left, right = Pipe()</span><br><span class="line"></span><br><span class="line">    c1 = Process(target=consumer, args=((left, right), <span class="string">'c1'</span>))</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    seq = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">    producer(seq, (left, right))</span><br><span class="line"></span><br><span class="line">    right.close()</span><br><span class="line">    left.close()</span><br><span class="line"></span><br><span class="line">    c1.join()</span><br><span class="line">    print(<span class="string">'主进程'</span>)</span><br></pre></td></tr></table></figure><p>注意：生产者和消费者都没有使用管道的某个端点，就应该将其关闭，如在生产者中关闭管道的右端，在消费者中关闭管道的左端。如果忘记执行这些步骤，程序可能再消费者中的recv()操作上挂起。管道是由操作系统进行引用计数的，必须在所有进程中关闭管道后才能生产EOFError异常。因此在生产者中关闭管道不会有任何效果，付费消费者中也关闭了相同的管道端点。</p><p>管道可以用于双向通信，利用通常在客户端/服务器中使用的请求／响应模型或远程过程调用，就可以使用管道编写与进程交互的程序（代码略）</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">p = Process()</span><br></pre></td></tr></table></figure><p>创建实例的参数：</p><ul><li><p>group参数未使用，值始终为None</p></li><li><p>target表示调用对象，即子进程要执行的任务</p></li><li><p>args表示调用对象的位置参数元组，args=(1,2,’hexin’,)</p></li><li><p>kwargs表示调用对象的字典，kwargs={‘name’:’hexin’,’age’:18}</p></li><li><p>name为子进程的名称</p></li></ul><p>Process()由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</p><p>方法介绍：</p><ul><li>p.start()：启动进程，并调用该子进程中的p.run() </li><li>p.run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </li><li>p.terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li><li>p.is_alive()：如果p仍然运行，返回True</li><li>p.join([timeout])：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</li></ul><p>实例属性：</p><ul><li>p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置<br>— p.name：进程的名称</li><li>p.pid：进程的pid</li><li>p.exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</li><li>p.authkey：进程的身份验证键，默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python多进程学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Celery</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Celery/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Celery/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过Python的包管理工具来安装，在我查到的一些资料中，celery和docker的配合不是很好，建议不要在单一容器中使用celery了。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>生产者(Celery client)。生产者(Celery client)发送消息。在Flask上工作时，生产者(Celery client)在Flask应用内运行。</li><li>消费者(Celery workers)。消费者用于处理后台任务。消费者(Celery client)可以是本地的也可以是远程的。我们可以在运行Flask的server上运行一个单一的消费者(Celery workers)，当业务量上涨之后再去添加更多消费者(Celery workers)。</li><li>消息传递者(message broker)。生产者(Celery client)和消费者(Celery workers)的信息的交互使用的是消息队列(message queue)。Celery支持若干方式的消息队列，其中最常用的是RabbitMQ和Redis.</li></ul><p>以上是最基本的架构，完整的组件还包括：</p><ol><li>Celery Beat：任务调度器</li><li>Celery Worker：执行任务的消费者</li><li>Broker：消息代理</li><li>Product：任务生产者（通过API，装饰器等产生任务并交个任务队列处理）</li><li>Result Backend：任务处理完成后，保存状态信息，以供查询</li></ol><p>1，4都是任务的生产者，只是方式不一样，1的方式是Beat进程读取配置文件，周期性的将到期的任务发给任务队列执行，就是定时任务。</p><h2 id="在flask中使用celery"><a href="#在flask中使用celery" class="headerlink" title="在flask中使用celery"></a>在flask中使用celery</h2><p>如何集成，并且很好的解耦模块是celery运用的关键。你总不能把代码都堆叠在一起吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>flask_celery不能支持celery4.0，所以弃用扩展模块，直接使用celery模块。使用扩展的好处是在扩展模块在一个文件初始化，并且全局保持一个实例对象，所以你的celery需要在app创建后才能创建，需要考虑是否使用了全局的celery对象</li><li>创建celery的实例对象的名字使用flask应用程序app的名字，通过 <code>app.name</code> 获取，如果你使用扩展插件，建议不要修改此名称，否则创建失败，不使用扩展插件也不建议修改</li><li>当有多个装饰器的时候，celery.task一定要在最外层</li></ul><p>init代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = create_app(CONFIG)</span><br><span class="line">celery = CeleryApp(app.name)</span><br><span class="line">celery.conf.update(app.config)</span><br></pre></td></tr></table></figure><p>首先创建Flask app的实例app，然后创建Celery的实例celery，这里需要传递一个名称，这个名称会作为celery task的前缀，例如 <code>flask_app.celery_app.task.long_task</code>，long_task是我们定义的任务，你要改创建实例的参数也可以，建议不要修改。这里的CeleryApp是自己编写的，继承Celery的一个类，目的是实现单实例，让其它模块通过CeleryApp创建的实例保持一样，然后调用celery.conf.update更新参数，<code>flask app.config</code> 是继承dict的Config类，这样就把需要的参数配置通过flask配置，作用于celery。</p><p>flask大多数的插件做的事情就是在单独的扩展文件中，先不传递参数实例化扩展，然后在创建app的时候初始化它，估计flask_celery也是做差不多的事情，不过实例化Celery必须要先传递参数，现在插件没有在更新了(有一些其他名称的扩展可以支持)，主要还是为了工程化。</p><p>这里记录一下扩展包的情况吧，在py3中，有：</p><p>Flask-Celery：这个其实不是扩展，而是装这个就把Celery相关的给安装了，这个是Celery的作者写的，他也说在4.0版本不再需要了，我也没看出来这个有什么用</p><p>Flask-Celery-Helper：这个就是扩展了，导入用flask_celery，不支持4.0</p><p>Flask-Celery-py3，Flask-Celery3：好像都是不支持4.0的</p><p>Flask-CeleryExt：在文档中写明可以支持4.0了，和大部分扩展使用方法一样，用懒加载的方式实例化</p><h3 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h3><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>pickle:</td><td style="text-align:center">二进制序列化方式；是标准库的一个模块，支持Python的内置数据结构，但是他是Python的专有协议，在celery3.2开始，出于安全考虑，不再采用此方案；</td></tr><tr><td>json:</td><td style="text-align:center">json支持多种语言，可用于跨语言方案，但好像不支持自定义的类对象； </td></tr><tr><td>XML:</td><td style="text-align:center">类似标签语言； </td></tr><tr><td>msgpack:</td><td style="text-align:center">二进制的类json序列化方案，但比json的数据结构更小，更快； </td></tr><tr><td>yaml:</td><td style="text-align:center">yaml表达能力更强，支持的数据类型较json多，但是python客户端的性能不如json; </td></tr></tbody></table><p>在自定义对象上，序列化方案我也出现过问题，pickle用了不行，可能就是不支持了，有待解决</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><code>celery = Celery(app.name)</code> 创建celery实例</li><li><code>celery.conf.update(app.config)</code> 更新配置</li><li>在需要后台运行的任务使用@celery.task</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello_world"</span></span><br></pre></td></tr></table></figure><p>需要注意的是，被装饰的任务需要调用才会加到任务队列，也就是通过hello_world.delay()调用，在官方的例子中，通过继承的方式，增加 <code>__call__</code> 方法，内部调用run，这样装饰器@celery.task()便会直接加入任务队列了，不过这样的功能应该是不需要的。</p><p>通过 <code>r = hello_world.delay()</code> 方法，返回的对象拥有以下方法：</p><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>r.ready()</td><td style="text-align:center">#查看任务状态，返回布尔值，任务执行完成，返回True，否则返回False. </td></tr><tr><td>r.wait()</td><td style="text-align:center">#等待任务完成,返回任务执行结果，很少使用； </td></tr><tr><td>r.get(timeout=1)</td><td style="text-align:center">#获取任务执行结果，可以设置等待时间 </td></tr><tr><td>r.result</td><td style="text-align:center">#任务执行结果. </td></tr><tr><td>r.state</td><td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td></tr><tr><td>r.status</td><td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td></tr><tr><td>r.successful</td><td style="text-align:center">#任务成功返回true </td></tr><tr><td>r.traceback</td><td style="text-align:center">#如果任务抛出了一个异常，你也可以获取原始的回溯信息</td></tr></tbody></table><h3 id="装饰器参数"><a href="#装饰器参数" class="headerlink" title="装饰器参数"></a>装饰器参数</h3><p><a href="mailto:`@celery.task" target="_blank" rel="noopener">`@celery.task</a>()`</p><ol><li><p>name：可以显示指定任务的名字；</p></li><li><p>serializer：指定序列化的方法；</p></li><li><p>bind：一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，具体属性可参照 <code>celery--app--task.py</code> 中的Task类，通过<code>self.request.__dict__</code>打印相关属性；</p></li><li><p>base：指定任务的基类，可以定义一个类，继承celery.Task，利用重写或扩展的类接口技术制定需求，例如on_success方法，默认是没有返回值的，就是提供这个钩子让开发者自定义的；</p></li></ol><h3 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h3><p>任务被装饰器装饰后，通过task.delay()，task.apply_async()把任务加入到队列中，send_task()，可以发送未被注册的异步任务，即没有被celery.task装饰的任务</p><h3 id="apply-async的参数"><a href="#apply-async的参数" class="headerlink" title="apply_async的参数"></a>apply_async的参数</h3><table><thead><tr><th>Command</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td>countdown</td><td style="text-align:left">设置该任务等待一段时间再执行，单位为s； </td></tr><tr><td>eta</td><td style="text-align:left">定义任务的开始时间；eta=time.time()+10; </td></tr><tr><td>expires</td><td style="text-align:left">设置任务时间，任务在过期时间后还没有执行则被丢弃； </td></tr><tr><td>retry</td><td style="text-align:left">如果任务失败后,是否重试;使用true或false，默认为true </td></tr><tr><td>shadow</td><td style="text-align:left">重新指定任务的名字str，覆盖其在日志中使用的任务名称； </td></tr><tr><td>retry_policy</td><td style="text-align:left">重试策略，为一个字典，各个键值配置：<code>max_retries</code>-最大重试次数，默认为 3 次. <code>interval_start</code>-重试等待的时间间隔秒数，默认为 0 ，表示直接重试不等待. <code>interval_step</code>-每次重试让重试间隔增加的秒数，可以是数字或浮点数，默认为 0.2. <code>interval_max</code>-重试间隔最大的秒数,即通过 interval_step 增大到多少秒之后，就不在增加了，可以是数字或者浮点数，默认为 0.2 .</td></tr><tr><td>routing_key</td><td style="text-align:left">自定义路由键； </td></tr><tr><td>queue</td><td style="text-align:left">指定发送到哪个队列； </td></tr><tr><td>exchang</td><td style="text-align:left">指定发送到哪个交换机； </td></tr><tr><td>priority</td><td style="text-align:left">任务队列的优先级，0-9之间； </td></tr><tr><td>serializer</td><td style="text-align:left">任务序列化方法；通常不设置； </td></tr><tr><td>compression</td><td style="text-align:left">压缩方案，通常有zlib,bzip2 </td></tr><tr><td>headers</td><td style="text-align:left">为任务添加额外的消息； </td></tr><tr><td>link</td><td style="text-align:left">任务成功执行后的回调方法；是一个signature对象；可以用作关联任务； </td></tr><tr><td>link_error</td><td style="text-align:left">任务失败后的回调方法，是一个signature对象；</td></tr></tbody></table><p>自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task.apply_async((<span class="number">2</span>,<span class="number">2</span>), </span><br><span class="line">    compression=<span class="string">'zlib'</span>,</span><br><span class="line">    serialize=<span class="string">'json'</span>,</span><br><span class="line">    queue=<span class="string">'priority.high'</span>,</span><br><span class="line">    routing_key=<span class="string">'web.add'</span>,</span><br><span class="line">    priority=<span class="number">0</span>,</span><br><span class="line">    exchange=<span class="string">'web_exchange'</span>)</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URL</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://username:passwd@host:port/虚拟主机名'</span></span><br><span class="line"><span class="comment"># 指定结果的接受地址</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://username:passwd@host:port/db'</span></span><br><span class="line"><span class="comment"># 指定任务序列化方式</span></span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'msgpack'</span> </span><br><span class="line"><span class="comment"># 指定结果序列化方式</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'msgpack'</span></span><br><span class="line"><span class="comment"># 任务过期时间,celery任务执行结果的超时时间</span></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">60</span> * <span class="number">20</span>   </span><br><span class="line"><span class="comment"># 指定任务接受的序列化类型.</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">"msgpack"</span>]   </span><br><span class="line"><span class="comment"># 任务发送完成是否需要确认，这一项对性能有一点影响     </span></span><br><span class="line">CELERY_ACKS_LATE = <span class="keyword">True</span>  </span><br><span class="line"><span class="comment"># 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据</span></span><br><span class="line">CELERY_MESSAGE_COMPRESSION = <span class="string">'zlib'</span> </span><br><span class="line"><span class="comment"># 规定完成任务的时间</span></span><br><span class="line">CELERYD_TASK_TIME_LIMIT = <span class="number">5</span>  <span class="comment"># 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程</span></span><br><span class="line"><span class="comment"># celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目</span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">4</span> </span><br><span class="line"><span class="comment"># celery worker 每次去rabbitmq预取任务的数量</span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">4</span> </span><br><span class="line"><span class="comment"># 每个worker执行了多少任务就会死掉，默认是无限的</span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">40</span> </span><br><span class="line"><span class="comment"># 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中</span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">"default"</span> </span><br><span class="line"><span class="comment"># 设置详细的队列</span></span><br><span class="line">CELERY_QUEUES = &#123;</span><br><span class="line">    <span class="string">"default"</span>: &#123; <span class="comment"># 这是上面指定的默认队列</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"direct"</span>,</span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"topicqueue"</span>: &#123; <span class="comment"># 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列</span></span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"topic.#"</span>,</span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"topic_exchange"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"topic"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"task_eeg"</span>: &#123; <span class="comment"># 设置扇形交换机</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"fanout"</span>,</span><br><span class="line">        <span class="string">"binding_key"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>celery worker -A auto_app.celery --loglevel=info</code> 启动Worker</p><h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>PENDING</td><td style="text-align:center">任务等待中 </td></tr><tr><td>STARTED</td><td style="text-align:center">任务已开始 </td></tr><tr><td>SUCCESS</td><td style="text-align:center">任务执行成功 </td></tr><tr><td>FAILURE</td><td style="text-align:center">任务执行失败 </td></tr><tr><td>RETRY</td><td style="text-align:center">任务将被重试 </td></tr><tr><td>REVOKED</td><td style="text-align:center">任务取消 </td></tr></tbody></table><p>通过 <code>r.get(&#39;status&#39;) == &#39;PENDING&#39;</code> 获取状态</p><h2 id="设置任务调度器"><a href="#设置任务调度器" class="headerlink" title="设置任务调度器"></a>设置任务调度器</h2><p>配置文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">Config = dict(</span><br><span class="line">    CELERYBEAT_SCHEDULE=&#123;</span><br><span class="line">        <span class="string">'ptask'</span>: &#123;</span><br><span class="line">            <span class="string">'task'</span>: <span class="string">'flask_app.celery_app.task.period_task'</span>,</span><br><span class="line">            <span class="string">'schedule'</span>: timedelta(seconds=<span class="number">5</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置中 schedule 就是间隔执行的时间，这里可以用 datetime.timedelta 或者 crontab，如果定时任务涉及到 datetime 需要在配置中加入时区信息，否则默认是以 utc 为准。例如中国可以加上：</p><p><code>CELERY_TIMEZONE = &#39;Asia/Shanghai&#39;</code></p><p>task的任务路径不能出错，在启动Worker进程的时候，可以看到task列表，这里指的的定时任务和其对应即可。</p><p>启动命令：</p><p>需要执行两个进程，一个是Worker进程，用来处理生成的任务，一个就是beat进程，启动任务调度器进程，定时生成任务</p><ul><li><code>celery beat -A auto_app.celery --loglevel=info</code></li><li><code>celery worker -A auto_app.celery --loglevel=info</code></li></ul><blockquote><p>任务调度会有需要动态添加任务，管理任务的情况，Django框架通过djang-celery实现在管理后台创建，删除，更新任务，它通过自定义调度类来实现，如果有类似的需求，可以参考源码实现</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>Signature 对象，把任务通过签名的方法传递给其它任务，成为一个子任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [6]: task = signature(&apos;flask_app.celery_app.task.add&apos;, args=(2, 2), countdown=5)</span><br><span class="line">In [7]: task</span><br><span class="line">Out[7]: flask_app.celery_app.task.add(2, 2)</span><br><span class="line">In [8]: task.apply_async()</span><br><span class="line">Out[8]: &lt;AsyncResult: 0cbe319e-c3f6-48b9-b1e4-6a034711cf3a&gt;</span><br></pre></td></tr></table></figure><p><code>from celery import signature</code> 导入signature，可以看到，传递的第一个参数是已经存在的任务，也可以先把add导入，通过 <code>add.subtask((2, 2), countdown=5)</code>，或使用subtask的缩写s，add.s()。</p><p>子任务能支持偏函数的方式，利用它实现工作流。</p><p>支持原语实现工作流，原语表示由若干条指令组成的，用于完成一定功能的过程</p><p>1.chain - 调用链，任务的链式执行，前面的执行结果作为参数传递给后面，直到任务完成</p><p>chain 函数接受一个任务的列表，Celery 保证一个 chain 里的子任务会依次执行，在 AsynResult 上执行 get 会得到最后一个任务的返回值。和 link 功能类似，每一个任务执行结果会当作参数传入下一个任务，所以如果你不需要这种特性，采用 immutable signature 来取消。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> chain</span><br><span class="line">    part = add.s(<span class="number">1</span>, <span class="number">2</span>) | add.s(<span class="number">3</span>) | add.s(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># or part = (add.s(1, 2), add.s(3), add.s(5))</span></span><br><span class="line">    res = chain(part)()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure><p>2.group - 任务的并发执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> group</span><br><span class="line">    res = group([add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)])()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure><p>group 函数也接受一个任务列表，这些任务会同时加入到任务队列中，且执行顺序没有任何保证。在 AsynResult 上执行 get 会得到一个包含了所有返回值的列表。<code>意参数必须是list对象</code></p><ol start="3"><li>chord - 带回调的 group</li></ol><p>chord 基本功能和 group 类似，只是有一个额外的回调函数。回调函数会在前面的任务全部结束时执行，其参数是一个包含了所有任务返回值的列表。在 AsynResult 上执行 get 会得到回调函数的返回值。</p><ol start="4"><li><p>map/starmap - 每个参数都作为任务的参数执行一遍</p></li><li><p>chunks - 将任务分块</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在启动Worker进程后，可以看到被装饰的任务已经被列出来了，这说明Celery有读取文件的机制(你可以在任务模块的最外层使用print测试)，被装饰的函数应该要在最外层，而且，创建实例后，再去修改配置，似乎没有生效（在我的测试中是这样的），其实这也符合逻辑，在进程被创建了，却又动态的去修改配置，与之对应的风险也很高。</p><p>celery是队列管理工具，真正的队列是Broker，更深入一点要了解RabbitMQ，AMQP协议，一般在celery上关注Worker，可以使用多个Worker，任务的生成使用定时器或触发的机制，任务本身就要由Python来编写，也包括对执行结果的处理。</p><p>任务生成，处理有了，还有队列的管理，默认使用名为celery的队列，可以配置队列，比如队列A，队列B，进入A队列的任务优先级要高，会被先处理。可以在启动worker进程的时候指明队列(通过-Q指定队)，这样这个Worker只会处理指定的队列。</p><p>后续扩展内容：celery信号，分析任务执行情况。Worker管理，监控和管理celery。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>https ssl 证书</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/ssl-credential/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/ssl-credential/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.698Z</updated>
    
    <content type="html"><![CDATA[<p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的</p><a id="more"></a><h1 id="https-ssl-证书"><a href="#https-ssl-证书" class="headerlink" title="https ssl 证书"></a>https ssl 证书</h1><p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的。以下内容截取自网络。</p><p>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。</p><p>创建自签名证书的步骤<br>注意：以下步骤仅用于配置内部使用或测试需要的SSL证书。<br>第1步：生成私钥使用openssl工具生成一个RSA私钥<br>$ openssl genrsa -des3 -out server.key 2048<br>说明：生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。<br>注意：生成私钥，需要提供一个至少4位的密码。<br>第2步：生成CSR（证书签名请求）生成私钥之后，便可以创建csr文件了。<br>此时可以有两种选择。理想情况下，可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书（很贵）。另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名，具体操作如下：</p><p>$ openssl req -new -key server.key -out server.csr<br>说明：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。</p><p>Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:Beijing<br>Locality Name (eg, city) []:Beijing<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:joyios<br>Organizational Unit Name (eg, section) []:info technology<br>Common Name (e.g. server FQDN or YOUR name) []:demo.joyios.com<br>Email Address []:<a href="mailto:liufan@joyios.com" target="_blank" rel="noopener">liufan@joyios.com</a></p><p>第3步：删除私钥中的密码在第1步创建私钥的过程中，由于必须要指定一个密码。而这个密码会带来一个副作用，那就是在每次Apache启动Web服务器时，都会要求输入密码，这显然非常不方便。要删除私钥中的密码，操作如下：</p><p>cp server.key server.key.org<br>openssl rsa -in server.key.org -out server.key</p><p>第4步：生成自签名证书如果你不想花钱让CA签名，或者只是测试SSL的具体实现。那么，现在便可以着手生成一个自签名的证书了。</p><p>$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt<br>说明：crt上有证书持有人的信息，持有人的公钥，以及签署者的签名等信息。当用户安装了证书之后，便意味着信任了这份证书，同时拥有了其中的公钥。证书上会说明用途，例如服务器认证，客户端认证，或者签署其他证书。当系统收到一份新的证书的时候，证书会说明，是由谁签署的。如果这个签署者确实可以签署其他证书，并且收到证书上的签名和签署者的公钥可以对上的时候，系统就自动信任新的证书。<br>第5步：安装私钥和证书将私钥和证书文件复制到Apache的配置目录下即可，在Mac 10.10系统中，复制到/etc/apache2/目录中即可。<br>需要注意的是，在使用自签名证书时，浏览器会提示证书不受信任，如果你是对外网站使用，建议还是去CA机构申请可信的SSL证书，现在证书也很便宜，沃通CA超快SSL Pre才488元/年。</p><p>一般情况下，如果能找到可用的证书，就可以直接使用，只不过会因证书的某些信息不正确或与部署证书的主机不匹配而导致浏览器提示证书无效，但这并不影响使用。<br>需要手工生成证书的情况有：<br>找不到可用的证书<br>需要配置双向SSL，但缺少客户端证书<br>需要对证书作特别的定制<br>首先，无论是在Linux下还是在Windows下的Cygwin中，进行下面的操作前都须确认已安装OpenSSL软件包。</p><ol><li>创建根证书密钥文件(自己做CA)root.key：<br>openssl genrsa -des3 -out root.key<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out root.key<br>Generating RSA private key, 512 bit long modulus<br>……………..++++++++++++<br>..++++++++++++<br>e is 65537 (0×10001)<br>Enter pass phrase for root.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for root.key: ← 重新输入一遍密码</li><li>创建根证书的申请文件root.csr：<br>openssl req -new -key root.key -out root.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key root.key -out root.csr<br>Enter pass phrase for root.key: ← 输入前面创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市的全名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []: ← 此时不输入<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随意填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建一个自当前日期起为期十年的根证书root.crt：<br>openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./emailAddress=admin@mycompany.com</a><br>Getting Private key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建服务器证书密钥server.key：<br>openssl genrsa –des3 -out server.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -out server.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>….+++<br>…………………………………………..+++<br>e is 65537 (0×10001)<br>运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施!<br>去除key文件口令的命令:<br>openssl rsa -in server.key -out server.key<br>5.创建服务器证书的申请文件server.csr：<br>openssl req -new -key server.key -out server.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key server.key -out server.req<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []:<a href="http://www.mycompany.com" target="_blank" rel="noopener">www.mycompany.com</a> ← 服务器主机名，若填写不正确，浏览器会报告证书无效，但并不影响使用<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建自当前日期起有效期为期两年的服务器证书server.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.csr -out server.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in server.csr -out server.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建客户端证书密钥文件client.key：<br>openssl genrsa -des3 -out client.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>……………………………………………………………………………..+++<br>……………………………………………………………………………………………………….+++<br>e is 65537 (0×10001)<br>Enter pass phrase for client.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for client.key: ← 重新输入一遍密码</li><li>创建客户端证书的申请文件client.csr：<br>openssl req -new -key client.key -out client.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key client.key -out client.csr<br>Enter pass phrase for client.key: ← 输入上一步中创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名称，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名称，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不填<br>Common Name (eg, YOUR name) []:Lenin ← 自己的英文名，可以随便填<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可以随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不填<br>An optional company name []: ← 可以不填</li><li>创建一个自当前日期起有效期为两年的客户端证书client.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in client.csr -out client.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入上面创建的密码</li><li>将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx：<br>openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>输出内容为：<br>[lenin@archer ~]$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>Enter pass phrase for client.key: ← 输入上面创建的密码<br>Enter Export Password: ← 输入一个新的密码，用作客户端证书的保护密码，在客户端安装证书时需要输入此密码<br>Verifying – Enter Export Password: ← 确认密码</li><li>保存生成的文件备用，其中server.crt和server.key是配置单向SSL时需要使用的证书文件，client.crt是配置双向SSL时需要使用的证书文件，client.pfx是配置双向SSL时需要客户端安装的证书文件<br> .crt文件和.key可以合到一个文件里面，把2个文件合成了一个.pem文件（直接拷贝过去就行了）<br>参考：<a href="http://sinolog.it/?p=1460" target="_blank" rel="noopener">http://sinolog.it/?p=1460</a><br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br><a href="http://blog.sina.com.cn/s/blog_4fd50c390101891c.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4fd50c390101891c.html</a><br>x509证书一般会用到三类文，key，csr，crt。<br>Key是私用密钥openssl格，通常是rsa算法。<br>Csr是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。<br>crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。 </li></ol><p>1.key的生成<br>opensslgenrsa -des3 -out server.key 2048<br>这样是生成rsa私钥，des3算法，openssl格式，2048位强度。server.key是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。可以通过以下方法生成没有密码的key:<br>opensslrsa -in server.key -out server.key </p><p>server.key就是没有密码的版本了。 </p><p>2.生成CA的crt<br>opensslreq -new -x509 -key server.key -out ca.crt -days3650<br>生成的ca.crt文件是用来签署下面的server.csr文件。 </p><p>3.csr的生成方法<br>opensslreq -new -key server.key -outserver.csr<br>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 </p><p>4.crt生成方法<br>CSR文件必须有CA的签名才可形成证书，可将此文件发送到verisign等地方由它验证，要交一大笔钱，何不自己做CA呢。<br>opensslx509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key-CAcreateserial -out server.crt<br>输入key的密钥后，完成证书生成。-CA选项指明用于被签名的csr证书，-CAkey选项指明用于签名的密钥，-CAserial指明序列号文件，而-CAcreateserial指明文件不存在时自动生成。<br>最后生成了私用密钥：server.key和自己认证的SSL证书：server.crt<br>证书合并：<br>catserver.key server.crt &gt; server.pem</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="http" scheme="http://www.liuzhidream.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>人生的意义</title>
    <link href="http://www.liuzhidream.com/2018/10/22/blog/rensheng-blog/"/>
    <id>http://www.liuzhidream.com/2018/10/22/blog/rensheng-blog/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:47:07.832Z</updated>
    
    <content type="html"><![CDATA[<p>胡适说，人生应该有梦，否则人生不是太不丰富吗？</p><p>现在你们都有理想，但出了社会便可能不同了。那时各奔前程，各种打击，各种现实的考虑，都可能使得你把崇高的理想收敛起来。这就是现实在考验我们的道德力，我们的理想性，我们对真对善对美的追求是否迫切。在世界上每一个角落都是如此的。我们是否能撑得住，就在这个关头。现在是考验我们的时候了。</p><a id="more"></a><h2 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义"></a>人生的意义</h2><p>今天是一九六六年四月八日，我今天要跟大家谈的问题是「人生的意义」。我为什么要选这个问题呢？这有两个理由：</p><p>第一个理由是我个人是非常喜欢思考的。从少年时代到青年时代，从青年时代到中年时代，都是不停的想问题，对人生的辛酸波折也经历过一些。因此把我所想的人生的意义是什么，人生的道路是什么陈示出来，给各位参考；我只说参考，但我没有说各位一定要采取我的人生观和人生的意义。人生的意义是各人自己的。我只是把我的提供各位参考而已。</p><p>第二个理由是：就我观察所及，我们正处在一个转型的社会，我们的文化在蜕变中，而且这个世界是这样的扰攘不安，差不多的人实实在在说来心灵都失落了：失落在街头，失落在弹子房，失落在电影院，失落在会客室里，种种的失落。他们的心灵是不凝炼，不坚强的。</p><p>比如说，有些体育家，运动家，他们的个子是蛮大的，打人蛮行的，但他的心灵很脆弱。譬如说，他们稍微把一句话说错了，就怕这个人不喜欢吧，怕那个人被得罪了。这充分表现出心灵的脆弱。</p><p>假如我们具有强健的身体而心灵如此脆弱，这是很可悲的，我们只有做别人的工具。这是时代的厄运。为了免于这一厄运，所以我愿意把我自己的想法提供出来。</p><p>这就是今天讨论这个问题的基础，并以此为范围。</p><p>人生是有很多层次的，此处我只能简略的说。</p><p>首先要说的是物理层。</p><p>任何人无法不受物理定律的支配。如果有人活得不耐烦的话，他从楼上跳下来，非伤即死，毫无问题的。那就是受物理定律的支配。人是有限的动物，虽然有时觉得自己是无限的，那大概是太狂妄了。这层是用不着多说了。</p><p>第二层是生物逻辑层。</p><p>人不仅是物而且是生物，是有生命的。有生命则不能不受生物法则的支配，如呼吸，心脏的搏动，肌肉的收缩都是受生理法则的支配，没有人能例外。我们就是这种构造的。可是，在这层有一种特别的现象，这在别的生物里是不发达的──即使不是没有的话。这就是一个生物文化的界域。</p><p>我们是一种生物，有许多是需要必须满足的，如吃饭喝水，到一定的岁数要结婚，所谓「窈窕淑女，君子好逑，求之不得，辗转反侧」，那么难过，这都属生物逻辑层。固然，别的生物也都要吃东西，寻配偶。但它们与人有大不同之处：它们是赤裸裸的，没有文化，人则不同，吃东西要讲礼貌，有不同的分殊，不同的形式。就穿衣而论，我不相信任何一位小姐，本来就像孔雀般美丽，而是藉各种物质的工具来补足其美。人为了御寒有棉、皮革、尼龙、奥龙、达克龙。这都是生物文化层的东西。我们满足人类之生物文化。但人类的生存并非发展到此结束的。</p><p>人是有「意识」的。这最关重要。别的生物大概没有，至少到现在为止大概尚末发展到这地步。这在生物发展的过程中是一个很重要的关键。别的生物大概不知道自身的生死间题，人则知道，晓得有生就有死。彭祖长寿，但到了八百岁时依然要死。而且人都怕死，但上帝绝不因此多留你一天，打针吃药于事无补。由于我们有死的意识，便产生许多神话，许多礼仪。</p><p>就这样，慢慢的发展，扩充我们的界域，由单纯的物理层，进为生物逻辑层，再由此发展到生物文化界，继续发展。</p><p>然后人类有真善美的意识，有理想、有道德，这也就是价值层。</p><p>这层就是人之所以为人的层级，生物逻辑层则是凡高等生物皆有。生物文化界别的高等动物虽可分享一部份，但人最多。唯最高层是人所独有。</p><p>我们讲道德，追求理想，要创造理想杜会，从柏拉图的理想国，托马斯穆尔的乌托邦，以至我们追求真善美等等，这都是超生物逻辑的东西，借用黑格尔的话说是「精神的创造」。我想大概说来只有人类有精神的创造。这层是人所特有的。当然，人只是太空中的一种生物而已，将来星际交通发达了，在别的星球中可能有超人类存在。超人类的智慧是可能比人类发达得多。</p><p>  现在我已把我要讨论的基本架构说出。依此，我们讨论人生的意义何在，人生的道路何在。人活在这世界上，首先必须要能生存。可是不同的文化价值，对这种需要的满足方式是不同的。而且有的文化价值取向不把重点放在这上面。</p><p>例如古代圣贤说：君子谋道不谋食。当我少年时，同学间常以为问舍求田的人，是没有大志的。因为，当时大家只谈理想，只谈学问。万一有人谈钱，大家一定笑他的。这是当时一般知识分子的价值观念。这也表示文化价值的重点之所在。又如古时有人说「饿死事小，失节事大」；「饿死首阳之山，义不食周粟」。这是认为生物需要不及道德价值之重要。尤其宋明理学家就是如此的。他们的想法高得很，但也空得很的。他们从不屑谈这些经济事务。但是，我们现在重视这个了。</p><p>第二次世界大战以后，亚非地区的人众抬头了。十九世纪末叶以迄二次世界大战以前约八十年间非洲地区是白种人的殖民地，有色人种受白种人的轻视，尤其认为有色人种无论是体力、道德或天然的脑力都不如白人。可是，曾几何时，现在非洲人受白人之哄抬。这个变化真非始料所及！亚非地区的人特别多，经济落后，但是我并非认为经济落后是罪恶。</p><p>正好相反，不开发，不开马路，漫步森林之中，享受天然之乐，岂不更好？现在，亚非地区受重视，却经济落后、知识水平低、贫困、饥荒，野心份子可用他们来扰乱世界和平。于是乎，自由国家要开发落后地区了。现在世界，无论何地均拼命经济发展，刻意经营。这些努力无非在生物文化层。</p><p>我并不是说这一层是可以忽略的。在实际上，我们不可能不经此层而跳至最上层。因为，如果腾空而起的话，高等精神文化的发展和道德实践便失去支持。宋明理学的大病在此。他们的毛病在当时并不严重。因为吃饭问题不大，如朱熹、程颐、程颢等人在这方面都不成问题，顶多是有无肉吃的问题而已。因为他们有人供养，他们是士大夫阶层。据贵校金耀基先生说，我们已经不是士大夫了。我听后有股淡淡的哀愁！</p><p>但是，落花流水春去也！又有什么办法呢？</p><p>以前我是会做秋梦的，以为身为士大夫，四民之首，好神气﹗但现在不是了，一个月的收入不及华怡保的百分之一，因此你们可以说：殷海光，你的梦可以醒了！这样我们便要面对现实了。当时朱熹可不如此，好惬意哦！到山上开家书院，自任山长。But now all gone！现在时代不同了，生活的需要多了。</p><p>我们的传统文化价值取向把重点放在名教、仪制、伦序、德目的维系这一层次上，而不太注重生物文化层。于是精神文化和现实生活脱了节。到头来，我们的文化发展，像一座高楼似的，上一层的人在吹笙箫，底下一层劳动终日难得一饱，于是空了。整个文化建构都发生问题。这一历史的教训是值得今日的我们留意的。</p><p>我举一个现实的例子。经济落后的地区要人来协助。肚子被人抓住了还有什么自由哟！我们的肚子被人控制，很多志气便无法伸张，人的尊严便很难维持。有钱才能扬眉，才能吐气。否则高尚的志趣，卓越的理想，都要收起来。人到屋檐下不能不低头。所以我们必须充实生物文化层才能谈上一层的价值。现在发展外销，致力经济起飞，在这种意义下是对的。</p><p>然而，我们现在的问题是：人生的意义，人生的目的，人生的价值，人生的道路是否就停在这一层呢？你如何把你与其它高等动物分别开？丰衣足食后是否安心在此停顿？人之所以为人是否这就够了呢？</p><p>这是要我们大学生，知识分子想的大问题。今天我们都受了时代沉闷空气的压力，担心出路，许多人不爱想这类问题，视之为高调。我个人的境遇困难，但从未停止想这类问题，尤其在困难的时候更要想！前面所说的生物逻辑的条件没有满足时，固然到不了最上层。但满足之后，高尚的理想和价值都可不要吗？希腊出那么多大哲学家、科学家、思想家，为后世之基础，我们多么向往啊！因为他们的精神生活是如此丰富。显然得很，要人生完美，必须透过生物文化层再往上升。生物文化层满足了，我们还要真善美、理想、道德，这样人生的道路才算完成。</p><p>这里又生一个问题：假设我们已有很好的文化遗产，如中国的。就中国来说，我认为孟轲有气象，他可说是一个标准的道德英雄；又如韩非子，思想那么严格，观察那么锐利。如果他生在现代的话，就可能是一个逻辑家了。</p><p>我们现在进一步提出一个问题：如果我们面临一个两难式，即是：如果我们要满足衣食等生物逻辑，那么势必牺牲道德或理想；如果我们要维持道德或理想，那末势必困难以满足衣食等生物逻辑的要求而难以生存。处此困境之下，我们怎样作决定？</p><p>照现在的趋势，一般人在有意无意之间，碰到求生与顾及道德不能两全的情形，就为了求生而牺牲道德原则。有些人更因满足自己的利益而牺牲道德，陷害别人。所以，道德就「江河日下」了。人吃粗一点尚可活下去。人群没有道德来维系，势必难免为「率兽食人」的世界。如何得了！在这样的情形之下，我们怎样处理？我以为孟夫子所倡导的「义」是救药。他要人舍生而取义。这当然是一个极限原则。我们并不是说人必须动不动就牺牲生命来保全道德原则和崇高理想。</p><p>我的意思是说：</p><p>第一，我们万不可在自己的生存并末受威胁时为了换取现实利益而牺牲道德原则。</p><p>第二，在我们的生活勉强可过时万不可因要得到较佳报酬而牺牲他人。</p><p>第三，当我们因生活困难而被迫不得不放弃若干作人的原则时，我们必须尽可能作「道德的抗战」，把道德的领土放弃的愈少愈好；而且要存心待机「收复道德的失地」。</p><p>复次，我们有我们的好恶。</p><p>如果经济贫困了，我们的好恶是否就要放弃？是否就不能讲？</p><p>还有尊严问题，如人的经济不能满足，尊严是否可以不顾呢？诸如此类的问题，作为一个人，真值得想一想。</p><p>在各位现在这种年龄大家都有梦。胡适说，人生应该有梦，否则人生不是太不丰富吗？</p><p>现在你们都有理想，但出了社会便可能不同了。那时各奔前程，各种打击，各种现实的考虑，都可能使得你把崇高的理想收敛起来。这就是现实在考验我们的道德力，我们的理想性，我们对真对善对美的追求是否迫切。在世界上每一个角落都是如此的。我们是否能撑得住，就在这个关头。现在是考验我们的时候了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胡适说，人生应该有梦，否则人生不是太不丰富吗？&lt;/p&gt;
&lt;p&gt;现在你们都有理想，但出了社会便可能不同了。那时各奔前程，各种打击，各种现实的考虑，都可能使得你把崇高的理想收敛起来。这就是现实在考验我们的道德力，我们的理想性，我们对真对善对美的追求是否迫切。在世界上每一个角落都是如此的。我们是否能撑得住，就在这个关头。现在是考验我们的时候了。&lt;/p&gt;
    
    </summary>
    
      <category term="causerie" scheme="http://www.liuzhidream.com/categories/causerie/"/>
    
    
      <category term="causerie" scheme="http://www.liuzhidream.com/tags/causerie/"/>
    
  </entry>
  
  <entry>
    <title>为什么那么多成功的人，他们每天只睡几个小时？</title>
    <link href="http://www.liuzhidream.com/2018/10/22/blog/sleep-blog/"/>
    <id>http://www.liuzhidream.com/2018/10/22/blog/sleep-blog/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:46:51.352Z</updated>
    
    <content type="html"><![CDATA[<p>这是个值得思考的问题</p><a id="more"></a><h1 id="为什么那么多成功的人，他们每天只睡几个小时？"><a href="#为什么那么多成功的人，他们每天只睡几个小时？" class="headerlink" title="为什么那么多成功的人，他们每天只睡几个小时？"></a>为什么那么多成功的人，他们每天只睡几个小时？</h1><p>这个世界就是一波人昼夜不停地运转,另一波人醒来后发现世界变了！</p><p>美剧都是骗人的，现实真的很累</p><p>一直有一个很大的困惑，为什么很多有名的成功人士可以睡得那么少？</p><p>第一次意识到这个问题，是刚到美国读书的时候。</p><p>相信在美国上过学的人都有体会，学习强度非常大。</p><p>每天早上8点起床去上课，晚上在图书馆待到1点，周末也基本都安排得满满的。不是因为故意用功，而是功课实在太多，让你完全没有任何喘息的时间。</p><p>拿其中一门主课来说，一周上三次课，一次三小时，每次课后教授都会在学校内网上传当天的阅读材料，都是她从各种数据库里找的论文文献和在图书馆里扫描的书籍，通常是PDF文档，可以下载后到图书馆免费打印。</p><p>每次要打印上百张A4纸（正反两面打印），偶尔打印完一看，今天的材料竟然只有六七十张，就会觉得心情一下子轻松了不少。</p><p>不要忘了这不是看休闲杂志，里面的内容都是枯燥艰深的学术论文，而且通常排版得密密麻麻并且极少插图。</p><p>你以为光看这些材料就完了吗？并没有。</p><p>在还没有开学前，教授已经发邮件给每一个学生，列出了整个学期的阅读书目，一共有30多本，都是学术书籍，要求学生自己到书店里去买，每周课上会讨论其中的一两本书。</p><p>至于统一的教材，反而是没有的。此外，每周还要写两篇文章，还得抽时间准备毕业前要交的论文。</p><p>不要忘了，这还只是其中的一门课，其他每一门课的教授都会这样像地主恶霸一样地把你榨成渣渣。</p><p>读完一年的硕士课程，每一个人都像经历了一场生死炼狱，毕业时仿佛有重生之感。</p><p>那个时候最好的纪念，就是去学院里的纪念品商店买一件上面印着“I survived J School”的T恤衫（J School是学院的简称），意思是“我读完J School竟然活了下来”。</p><p>这么高强度的工作量，正常的作息时间是绝对不可能完成的。</p><p>所以几乎每天大部分人都只能蓬头垢面地在学校和住处之间两点一线地疲于奔命。</p><p>之前设想的要多去旁听其他系有意思的课、多认识人、多参加社会活动等等美好憧憬，全部都被残酷的现实击打得粉碎。</p><p>即使现在已经几年过去了，重新回想起来仍然觉得心有余悸。</p><p>尽管当时居住的地方右转300米就是著名的中央公园，但是整整三个月愣是没有时间去瞅一眼。</p><p>总有那么几个学霸天生不用睡觉</p><p>当时班里一共9个学生，除了两人以外，其他都是美国人。大多数人也都是疲于奔命，眼睛带着血丝。但是，有一个本科在哈佛读的美国同学，却每天都一副容光焕发精力充沛的样子。</p><p>曾经以为他是偷懒没看阅读材料，所以有足够的休息时间，可后来发现并非如此，他不但把大部分功课都完成了，而且还有时间去听个讲座、参加个派对什么的。</p><p>他说，他固定在凌晨3点半睡觉，早上7点半起床。这让人很震惊，问他睡这么少为什么还能保持这么旺盛的精力？一般人每天睡6个多小时，就已经觉得到了自己的极限了。</p><p>他笑笑说，他一直都是这样，每天睡4个小时就差不多够了。他还说，在美国就是这样，工作、社交、睡觉，每个人都只能保证两样，他不想耽误学习也不想没有社交，就只能牺牲睡眠了。</p><p>其实不仅仅是在顶尖的学校，美国社会里顶尖的那一批人，几乎都是处于这样一种疯狂高速运转的状态。为了保证工作学习和社交娱乐，他们不约而同地牺牲了自己的睡眠，每天只睡四五个小时是很常见的。</p><p>比如学院里的教授，也是如此。除了教书以外，她还是好几家媒体的专栏作者，每周都要写很多文章；还经常参加各种研讨会和研究计划；在这样的情况下，她还有时间每年写一本书。</p><p>相比学生，她的工作量只多不少。不知道她每天睡几个小时，只知道每天收到的最后一封电子邮件必定是她发的，每天早上收到的第一封邮件也是她发的。</p><p>有时候学生们晚上1点写完作业用电子邮件给她发过去，第二天一大早必然会收到她回复的修改意见，而且看邮件发送时间常常是凌晨三、四点。可是每天早上9点开始的课，她从来没有迟到过一次。</p><p>再比如工作以后遇到过的几位上司，几乎都是每天半夜两三点给大家发工作邮件，第二天一大早8点不到进办公室，而且天天如此。</p><p>媒体也时不时地会写关于睡眠时间的文章，列出那些成功人士只睡三四个小时的例子——奥巴马每天只睡6个小时，雅虎的美女 CEO 玛丽莎·梅耶尔每天只睡4个小时，还有特朗普据说也只睡4个小时……</p><p>为什么他们不睡觉还有精力拼搏</p><p>在北美一个华人论坛上出现过这么一个话题：</p><p>为什么跨国公司的CEO们每天只睡四五个小时，却能有效地管理几百亿市值的公司？</p><p>当然，这个问题并没有一个明确的答案。有科学家做过研究说，有些人可以每天只睡四五个小时还精力充沛，除了他们自己很拼很努力，更主要的原因是他们体内有一种异于常人的基因。</p><p>他们还把这种基因命名为“撒切尔基因”，因为据说撒切尔夫人就是一个非常著名的“少睡者”的典型。</p><p>所以，最大的解释就是，这就是天分吧。</p><p>对于那些没有少睡基因、“输在起跑线上”的人来说，办法大概是：</p><p>一，尽可能地保证睡眠的质量；</p><p>二，提高睡眠的效率，有些事情睡觉时能办的就在睡觉时办。</p><p>三，多运动，这是补充精力的有效方法。</p><p>前方高能，再来看看这22位CEO的作息：</p><p>1、美国在线公司（AOL）首席执行官Tim Armstrong</p><p>这位前谷歌执行官并不是一位“爱好睡觉”的人，他每天都在清晨5点或5：15醒来。之后要么工作，要么阅读，或者看看自家公司的产品，回复电子邮件。</p><p>为了保证更多的思考时间，Tim Armstrong通常不会自己开车，而是请专职司机。</p><p>2、苹果公司首席执行官Tim Cook</p><p>这位科技巨擘在业界正是以早起出名，苹果的员工会在清晨、或者说接近黎明时分的4：30就收到Tim Cook的电子邮件，且每日如此，他们已经习以为常。</p><p>当然，Tim Cook会在5点钟的时候准时出现在健身房。</p><p>3、通用电气（GE）首席执行官Jeff Immelt</p><p>通用电气（GE）首席执行官Jeff Immelt每一天的5：30都会起床做有氧运动。</p><p>期间，他还会读报纸，看CNBC。</p><p>他曾经提起，自己已经连续24年每周工作100个小时了。</p><p>这就是说，按照7天的时间计算，他每天的工作时长为14个小时以上……</p><p>4、通用汽车公司（General Motors）首席执行官Mary Barra</p><p>早起大概成了通用公司的传统，现任CEO Mary Barra就像其前任Daniel Akerson一样，日日早起。</p><p>她每天准时准点地在清晨6点出现在办公室。</p><p>在这一点上，她比前任做的还要出色。</p><p>5、富士施乐（Xerox）首席执行官Ursula Burns</p><p>回复电邮是Ursula Burns每日清晨的习惯，为此，她会在5：15起床。</p><p>不过，尽管经常会工作到深夜，但Ursula Burns会保证自己每周两次的个人健康训练，这个时间定在6：00，每次一个小时。</p><p>6、菲亚特（Fiat）和克莱斯勒（Chrysler）首席执行官Sergio Marchionne</p><p>这位具有加拿大和意大利双重国籍的商人起床的时候，恐怕大部分人都还在梦乡中——3：30。</p><p>公司有位高管曾表示：“Sergio创造出了（一周里的）第八天，我们来实现它。”</p><p>还有一位高管曾在60 Minutes节目中这样说：“当意大利放假的时候，他回美国工作；当美国放假的时候，他再回意大利工作。”</p><p>7、太平洋投资管理公司（PIMCO）创始人Bill Gross</p><p>Bill Gross的早起如同他那糟糕的君王脾气，以及职业二十一点玩家的身份一样出名。</p><p>他会在4：30就起床，查看全球市场行情和消息，并在6点钟准时坐在办公桌前。</p><p>8、Twitter创始人、移动支付公司Square首席执行官Jack Dorsey</p><p>Jack Dorsey曾对媒体透露，他一般会在5：30起床，然后就开始做早课——冥想，以及一个小时的慢跑。</p><p>这样的生活方式他持续了很久，尤其是同时在Twitter和Square之间来回奔波工作的时候。</p><p>9、维珍集团（Virgin Group）创始人及董事局主席Richard Branson</p><p>Richard Branson自曝起床时间是5：45，甚至在他的私人岛屿上度假时也是如此。他会拉开窗帘睡觉，这样，第二天的阳光就会叫醒自己。</p><p>10、百事集团（PepsiCo）首席执行官Indra Nooyi</p><p>这位这位印度裔女执行官最早的起床时间是清晨4点。</p><p>她曾称：“人们说，睡眠是上帝赐予的礼物……这份礼物我从未得到过。”她透露自己每天到公司的时间不会晚于7点。</p><p>11、维珍美国首席执行官David Cush</p><p>他曾向媒体表示，自己每天会在4：15起床，然后发邮件、致电东海岸的商业伙伴。</p><p>不过，每天清晨的达拉斯体育广播是他不会错过的节目，当然，还包括读报纸和健身。</p><p>12、迪斯尼集团首席执行官Bob Iger</p><p>Bob Iger曾对纽约时报表示，他一般在4：30起床，利用上班前这段安静的时光读报纸、看电视。这段时间无人打扰，他能同时处理多项事情。</p><p>13、Hain Celestial Group首席执行官Irwin Simon</p><p>他是美国天然日用品制造商Hain Celestial集团CEO，他每天5点钟起床，之后的习惯就像上述几个CEO们一样，回复邮件、与欧洲和亚洲的商业伙伴通话。</p><p>不同的是，他还会在孩子们起来之前祈祷、遛狗、做运动。</p><p>而且，他还能在进入长岛办公室之前在曼哈顿开个早餐会。</p><p>14、前百事可乐CEO Steve Reinemund</p><p>现任Wake Forest大学商学院院长，他告诉媒体，他在5:30起床，再读报纸。他会在工作前浏览纽约时报、华尔街日报、金融时报、达拉斯晨报。</p><p>15、星巴克CEO Howard Schultz</p><p>Howard Schultz以晨练开始新的一天，一般是与妻子一同骑车。即便如此，他也会保证自己在6点之前赶到办公室。</p><p>16、Aurora Fashions首席执行官Mike Shearwood</p><p>作为一家英国时尚领域的先锋公司，Aurora Fashions首席执行官Mike Shearwood忙碌的一天开始于清晨5点。</p><p>他从诺丁汉赶到伦敦差不多是7：45了。他对这种长距离的上下班路途乐此不疲：“我会赶复邮件、赶工作，还能与团队通电话。”</p><p>17、布鲁克林篮网队首席执行官Brett Yormark</p><p>布鲁克林篮网队（Brooklyn Nets）在更名前为新泽西篮网队。Brett Yormark是全美NBA界最年轻的CEO。</p><p>他的起床时间也许会让很多人汗颜——3点半，而且他在4：30就会出现在办公室了，然后开始一天的工作，发邮件什么的。</p><p>不过，他并非铁人，周末是他放松自己的时间——7点钟才到办公室工作。</p><p>18、前氧气媒体公司 （Oxygen Channel）首席执行官Gerry Laybourne</p><p>作为二十世纪80年代有线电视界先锋人物，Gerry Laybourne总是在6点起床，半小时以后离家赶赴公司。</p><p>如果你起得够早，她可能还会带上你。</p><p>她曾对雅虎财经说：“每周一到两次，我都会在中央公园步行，并与一名寻求我的建议的年轻人同行。这是我帮助下一代人的方式。如果有人早起，我认为，他对待生活是认真的。我无法在公司做这些事，但早起让我有空健身，同时，还能和年轻人保持沟通交流。</p><p>19、私募股权投资公司Saban Capital首席执行官Haim Saban</p><p>这位埃及出生的以色列-美国籍亿万富豪也很勤奋，6：02，他就开始享用清晨咖啡了。他会在75分钟的晨练前先工作一小时。</p><p>20、Brooklyn Industries首席执行官Lexy Funk</p><p>这位时尚企业联合创始人之一曾对赫芬顿邮报如此形容她的一天：她一般在4点醒来。然后开始纠结，到底是倒头再睡，还是拿起黑莓工作呢？不过，绝大多数情况下，她在忙于回复邮件的同时，会抽空打几个和生意有关的电话。</p><p>21、喜达屋酒店（Starwood Hotels）首席执行官Frits Van Paasschen</p><p>他在5：50就开始跑步了，你可以想象他的起床时间。6：30，他会准时出现在办公桌前。</p><p>22、Cisco 首席执行官Padmasree Warrior</p><p>这位印度裔女强人4：30就起来了，发邮件、读新闻、晨练，一样不少。最晚在8：30，她就会进入公司工作了。</p><p>也正因其勤奋而卓有成效的工作，Padmasree Warrior早在作为摩托罗拉首席技术官的时候就备受赞誉了。</p><p>时间赋予每个人都是24小时，只是有些人把时间用到了极致。</p><p>这个世界最可怕事，比你牛逼的人，竟然比你还努力。</p><p>有一波人昼夜不停地运转,另一波人醒来后发现世界变了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是个值得思考的问题&lt;/p&gt;
    
    </summary>
    
      <category term="causerie" scheme="http://www.liuzhidream.com/categories/causerie/"/>
    
    
      <category term="causerie" scheme="http://www.liuzhidream.com/tags/causerie/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Docker/Docker/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Docker/Docker/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:47:07.832Z</updated>
    
    <content type="html"><![CDATA[<p>docker 容器技术学习笔记</p><a id="more"></a><h1 id="Docker-笔记"><a href="#Docker-笔记" class="headerlink" title="Docker 笔记"></a>Docker 笔记</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/learn_programing/images/docker/docker.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>docker ps 列出容器列表docker container ls 管理容器</code></pre><p>两个命令都是查看正在运行的容器，加 -a 参数可以查看更多的信息</p><pre><code>docker run     docker container run   都是运行容器(但是本质还是不同的，可以深入研究下)Ctrl+P+Q  退出容器不关闭docker start goofy_almeida  启动容器在后台运行docker attach goofy_almeida 后台容器进入终端docker network create &lt;name&gt;docker network inspect &lt;name&gt;docker stats 容器ID  查看容器状态docker logs 把容器运行后产生的输入都打印出来，不要轻易尝试</code></pre><h3 id="多个终端访问容器"><a href="#多个终端访问容器" class="headerlink" title="多个终端访问容器"></a>多个终端访问容器</h3><p>有时候需要开启多个终端来访问容器，通过容器ID，执行命令 <code>docker exec -it 40c330755e61 /bin/bash</code> 就可以了，这个终端的退出不会影响到已经开启的终端</p><h3 id="创建容器的参数"><a href="#创建容器的参数" class="headerlink" title="创建容器的参数"></a>创建容器的参数</h3><ul><li>-d：后台运行容器，并返回容器ID</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li></ul><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>容器连接就是把容器接到一起，让它们可以相互通信，如果你使用一个容器运行一个软件的方式，容器连接就是很有必要的，比如你的服务和数据库进行通信，那么你的容器就要连接在一起。<br>使用到的命令有 <code>--link</code> ，不过新的特性推荐使用 <code>network</code> ，network把容器都加到一个网络中，实现之间的互相通信。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><hr><ol><li>创建网络，<code>my_network</code> 是网络的名称。创建完网络，把容器加入到网络就行了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create my_network</span><br></pre></td></tr></table></figure></li></ol><p>tip 加入网络示例：</p><p><code>docker run -it --name=web_django --network web_network --network-alias django -v /root/py_web_vadmin/:/root/web_work -p 8080:8080 debian:v2 bash</code></p><p><code>docker run -it --name=web_nginx --network web_network --network-alias nginx -v /root/py_web_vadmin/:/root/web_work -p 80:80 nginx bash</code></p><p>把debian和nginx加入到一个已创建的网络中。</p><ol start="2"><li>查看网络<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls 查看已创建的网络，默认有服务自己创建的网络</span><br></pre></td></tr></table></figure></li></ol><p>效果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID      NAME    DRIVER  SCOPE</span><br><span class="line">9872c9881f6e    bridge  bridge  local</span><br><span class="line">6fc119c0ceda    host    host    local</span><br><span class="line">c3fdf8d5c56e    none    null    local</span><br></pre></td></tr></table></figure></p><ul><li>bridge：默认网络，所有容器默认连接到它</li><li>none：没有网络接口</li><li>host：连接到主机的网络栈，主机和容器间的网络没有隔离</li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷用来做数据持久化，如果你的数据在容器中，比如数据库文件，日志文件等，这些文件是会不断生成的，当你关闭容器，再次启动容器，数据倒是不会丢失，如果你从镜像启动新的容器，数据就没了（出现这种情况是因为：通常使用run命令来启动容器，如果没有定义name，那么每次使用run命令都会从镜像创建新的容器，这样上次容器的操作都没了，应该养成定义容器name的习惯，创建同名的容器是不允许的）。数据要想保持，除非你不断的提交镜像，当然这种做法是不可取的，所以要用到数据卷技术。数据可以让容器和宿主主机共享一个目录，通常把程序，数据库文件等放在宿主机上，通过创建数据卷，让容器可以操作到宿主机文件，并把新的数据写到此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -v /root/data:/root/PythonProjects/GitTest -it -p 8080:8080 debian:v2 bash</span><br></pre></td></tr></table></figure><p>上面命令的含意是：本机目录/root/data映射到容器目录/root/PythonProjects/GitTest（在启动容器的时候就得使用-v 命令，容器和主机共用一个目录，关闭容器，在启动容器也得带-v命令）<br>一般会把程序放在宿主机上，更新修改都在这，不过修改了代码后，记得进入容器中去重启项目。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从主机复制到容器 sudo docker cp host_path containerID:container_path</span><br><span class="line">从容器复制到主机 sudo docker cp containerID:container_path host_path</span><br></pre></td></tr></table></figure><p>操作流程：先把容器运行起来，宿主主机执行 docker container 查询正在运行的container 的containerID 然后去执行上面的命令</p><p>保存容器修改：</p><ul><li>pull 了一个新的image后，或操作已有的容器，并对容器做了修改，退出容器后</li><li>执行 docker ps -l 得到 容器的ID</li><li>执行 docker commit 容器ID 镜像名称 该操作将覆盖现有进行为修改后的容器</li><li>docker commit 容器ID 镜像名称:v2 保存修改为tag为v2的镜像</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器(container)是docker一个很重要的概念，通过镜像我们就可以创建容器。这里记录一些相关命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">查看</span><br><span class="line">docker container <span class="keyword">ls</span> 等同于 docker <span class="keyword">ps</span>  -<span class="keyword">a</span> 查看更多的信息</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">docker rm  container id</span><br><span class="line">docker rmi  image id</span><br><span class="line"></span><br><span class="line">杀死所有正在运行的容器</span><br><span class="line">docker kill $(docker <span class="keyword">ps</span> -<span class="keyword">a</span> -q)</span><br><span class="line"></span><br><span class="line">删除所有已经停止的容器(容器不再使用了，可以使用此命令把它们都清空了)</span><br><span class="line">docker rm $(docker <span class="keyword">ps</span> -<span class="keyword">a</span> -q)</span><br><span class="line"></span><br><span class="line">删除所有未打 dangling 标签的镜像</span><br><span class="line">docker rmi $(docker images -q -<span class="keyword">f</span> dangling=true)</span><br><span class="line"></span><br><span class="line">删除所有镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line">强制删除镜像名称中包含“doss-api”的镜像</span><br><span class="line">docker rmi --force $(docker images | <span class="keyword">grep</span> doss-api | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line"></span><br><span class="line">删除所有未使用数据</span><br><span class="line">docker <span class="built_in">system</span> prune</span><br><span class="line"></span><br><span class="line">只删除未使用的volumes</span><br><span class="line">docker volume prune</span><br><span class="line"></span><br><span class="line">docker start goofy_almeida  启动容器在后台运行</span><br><span class="line">docker attach goofy_almeida 后台容器进入终端</span><br></pre></td></tr></table></figure><h3 id="docker-ps-–选项"><a href="#docker-ps-–选项" class="headerlink" title="docker ps –选项"></a>docker ps –选项</h3><table><thead><tr><th>Name, shorthand</th><th style="text-align:center">Default</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td>–all , -a</td><td style="text-align:center"></td><td style="text-align:center">Show all containers (default shows just running)</td></tr><tr><td>–filter , -f</td><td style="text-align:center"></td><td style="text-align:center">Filter output based on conditions provided</td></tr><tr><td>–format</td><td style="text-align:center"></td><td style="text-align:center">Pretty-print containers using a Go template</td></tr><tr><td>–last , -n</td><td style="text-align:center">-1</td><td style="text-align:center">Show n last created containers (includes all states)</td></tr><tr><td>–latest , -l</td><td style="text-align:center"></td><td style="text-align:center">Show the latest created container (includes all states)</td></tr><tr><td>–no-trunc</td><td style="text-align:center"></td><td style="text-align:center">Don’t truncate output</td></tr><tr><td>–quiet , -q</td><td style="text-align:center"></td><td style="text-align:center">Only display numeric IDs</td></tr><tr><td>–size , -s</td><td style="text-align:center"></td><td style="text-align:center">Display total file sizes</td></tr></tbody></table><p>使用 <code>docker attach</code> 命令进入container（容器）有一个缺点，那就是每次从container中退出到前台时，container也跟着退出了。<br>要想退出container时，让container仍然在后台运行着，可以使用 <code>docker exec -it</code> 命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it goofy_almeida /bin/bash</span><br><span class="line"></span><br><span class="line">goofy_almeida：要启动的container的名称</span><br><span class="line"></span><br><span class="line">/bin/bash：在container中启动一个bash shell</span><br></pre></td></tr></table></figure></p><p>这样输入“exit”或者按键“Ctrl + C”退出container时，这个container仍然在后台运行。</p><blockquote><p>关于容器的运行，我本人的做法会使用 <code>screen</code> (linux的一个软件)，一般没有做后台运行。</p></blockquote><h3 id="container总结"><a href="#container总结" class="headerlink" title="container总结"></a>container总结</h3><p>run 命令后从镜像创建container(容器)，此时的容器是新的，如果修改了内容，用exit退出，这个容器被关闭了（进入了Exited状态），如果想留着修改，最好是Ctrl+P+Q  退出容器不关闭  这样docker ps  可以查看容器还在，这样就可以通过start 容器name再次进入容器了。（这里我感觉容器的状态是有用的，具体就要看文档了，因为run新容器后，通过exit命令退出了，再次run，此时ps命令应该是创建了一次，然后关闭，又创建了一次，出现过两个name, 但是第二次run的容器是新的，上次修改的拿不到。 但是修改后，exit退出，通过docker ps -l，可以看到容器id,  这里可以进行提交。所以像保持容器的修改，最好用上面的流程，等理清楚了生命周期，就比较清楚整个流程了）经测试，docker ps -l列不出的容器，通过docker ps -a找到，即使状态不是update也可以去commit。</p><blockquote><p>One of created, restarting, running, removing, paused, exited, or dead</p></blockquote><h2 id="容器导入导出"><a href="#容器导入导出" class="headerlink" title="容器导入导出"></a>容器导入导出</h2><pre><code>docker save imageID &gt; filename.tardocker load &lt; filename.tardocker export imageID &gt; filename.tardocker import &lt; filename.tar</code></pre><p>镜像和容器导出和导入的区别</p><p>镜像导入和容器导入的区别：</p><ol><li>容器导入 是将当前容器 变成一个新的镜像</li><li>镜像导入 是复制的过程</li></ol><p>save 和 export区别：</p><ol><li>save 保存镜像所有的信息-包含历史</li><li>export 只导出当前的信息</li></ol><h2 id="Dockerfile-使用"><a href="#Dockerfile-使用" class="headerlink" title="Dockerfile 使用"></a>Dockerfile 使用</h2><p>除了通过拉取官方镜像的方式外，使用Dockerfile可以定制镜像，使其更加灵活。<br>整个Dockerfile文件就是执行的脚本，由特定的命令组成，一个redis镜像Dockerfile文件大概是这样的。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM cento<span class="variable">s:latest</span></span><br><span class="line"></span><br><span class="line">RUN yum -y update; yum clean all</span><br><span class="line">RUN yum -y install epel-release; yum clean all</span><br><span class="line">RUN yum -y install redis; yum clean all</span><br><span class="line"></span><br><span class="line"># 设置挂载点</span><br><span class="line">VOLUME [<span class="string">"/data/redis"</span>]</span><br><span class="line"></span><br><span class="line"># Define working directory.</span><br><span class="line">WORKDIR /data</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"redis-server"</span>]</span><br></pre></td></tr></table></figure><p>上述Dockerfile文件是基于基础镜像CentOS来制作Redis。</p><p><code>docker build -t centos:v2 .</code> 在文件所在目录下执行构建命令</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>Dockerfile指令就是上述文件中开头的FROM，RUN等。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。</p><p>FROM scratch 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ADD</span><br><span class="line">COPY</span><br><span class="line">ENV</span><br><span class="line">EXPOSE</span><br><span class="line">FROM</span><br><span class="line">LABEL</span><br><span class="line">STOPSIGNAL</span><br><span class="line">USER</span><br><span class="line">VOLUME</span><br><span class="line">WORKDIR</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>这个工具是用来做容器编排的，简单来说就是可以一次启动多个容器，包括了设置端口映射，数据卷，容器连接等。在使用docker部署项目时，还是应该一个软件对应一个容器，而不是基于一个容器安装多个软件（这样就搞成一个虚拟机了），你要依次启动4，5个容器，设置端口映射，容器连接等会很麻烦，使用docker-compose只需要编写一个 <code>docker-compose.yaml</code> 文件就可以了。</p><p>使用了docker-compose，最好再配合一下Dockerfile，这样很快速就可以搭建一个环境。</p><p>以Python语言为例，流程应该是编写Dockerfile，在Dockerfile中基于一个基本容器（ubuntu，或者是Python3等容器），设置一些参数，然后安装依赖 <code>RUN pip install -r requirements.txt</code>，这样语言环境就有了，下面就是各个服务，比如MySQL，Redis等，这些不是太复杂的情况，直接在Dockerfile中指定image就行了。</p><p>总结：</p><ol><li>Dockerfile 定义应用的运行环境</li><li>docker-compose.yml 定义组成应用的各服务</li><li>docker-compose up 启动整个应用</li></ol><h3 id="编写yaml文件"><a href="#编写yaml文件" class="headerlink" title="编写yaml文件"></a>编写yaml文件</h3><p>这个编写很简单，就是把各个容器怎么运行，参数配置组织在一起</p><p>来看一个简单的官方例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">.:/code</span></span><br><span class="line"><span class="attr">    - logvolume01:</span><span class="string">/var/log</span></span><br><span class="line"><span class="attr">    links:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  logvolume01:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>官方文档总结：</p><p>一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，官方这里的例子使用links，而没有使用新的networks特性。configs配置在3.3及以上版本使用，用于配置文件的访问权限。</p><ul><li><p>version：用来指定版本，依照官方的例子，现在可以使用3版本了，不同版本对一些配置的支持不同，比如配置参数从字符串到对象的变化，这里不再深入了</p></li><li><p>services：就是需要运行的容器，容器通过build或image指定，build就是使用Dockerfile文件，image就是使用镜像，本地有的使用本地的，否则下载仓库的。build后面还可以加参数，例如context，args，用来设置上下文，参数等，这属于Dockerfile相关的内容，一般情况，直接在build指定当前目录就行了。ports指定端口映射，volums指定数据卷（使用数据卷，修改代码不用重启容器），在这个官方例子中，在最外层也就是顶级定义了volumes，这是为服务定义的，使用一个单机开发环境在services中定义就行了。标签有两种情况，在服务上（部署集群的时候）deploy: labels: ’标签内容‘，在容器上只需要用labels。看到deploy，它下面的配置都是和部署有关的。depends_on依赖关系，依赖的容器会先启动。command命令，类似python3 manage.py runserver 0.0.0.0:8000。pid: “host” 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的–add-host类似。</p></li></ul><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>Command</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td>build</td><td style="text-align:left">构建或重建服务，这会把Dockerfile再执行一次</td></tr><tr><td>help</td><td style="text-align:left">命令帮助 </td></tr><tr><td>kill</td><td style="text-align:left">杀掉容器 </td></tr><tr><td>logs</td><td style="text-align:left">显示容器的输出内容 </td></tr><tr><td>port</td><td style="text-align:left">打印绑定的开放端口 </td></tr><tr><td>ps</td><td style="text-align:left">显示容器 </td></tr><tr><td>pull</td><td style="text-align:left">拉取服务镜像 </td></tr><tr><td>restart</td><td style="text-align:left">重启服务 </td></tr><tr><td>rm</td><td style="text-align:left">删除停止的容器 </td></tr><tr><td>run</td><td style="text-align:left">运行一个一次性命令，run web bash</td></tr><tr><td>exec</td><td style="text-align:left">Execute a command in a running container，感觉run差不多</td></tr><tr><td>scale</td><td style="text-align:left">设置服务的容器数目 </td></tr><tr><td>start</td><td style="text-align:left">开启服务 </td></tr><tr><td>stop</td><td style="text-align:left">停止服务 </td></tr><tr><td>up</td><td style="text-align:left">创建并启动容器 </td></tr><tr><td>version</td><td style="text-align:left">查看版本，如果你是2版本的，就不要在yaml里面使用3版本的写法了</td></tr></tbody></table><p>使用总结：</p><ul><li><p>个人心得，大致浏览了一下官方文档，docker-compose最大的用处应该是集群，它提供了很多功能，不过对于单机来说仍然有它的价值，省去了很多命令，同样作为单机来用，不需要学的很深入，很多配置都是用不到的</p></li><li><p>启动容器：使用up命令来启动容器，同时也会把build配置生成镜像，在我使用的版本中，给出了警告，对于需要使用Dockerfile构建的镜像，警告说应该先使用 <code>docker-compose up --build</code>，不过这对容器的启动到是没什么影响（不知道这里官方想表达什么）。build命令只会构建镜像，并不会去启动容器，up命令启动容器后，会把容器的输出打印到终端，要想在后台运行，应该 <code>up -d</code></p></li><li><p>name：使用image的，镜像名称就是指定的，使用build，镜像名称为当前目录加上在services中的配置，在容器中的name也是当前目录加上在services中的配置。使用docker-compose需要在yaml文件目录执行，这样在services中的配置，比如一个叫做web的配置，第一次使用镜像（或用build构建）是Python，生成的容器也是 <code>当前目录_web_1</code>，修改了web配置，image变成Redis，那么上次创建的容器会被删除，创建新的容器，容器的名称是一样的，因为修改的是image，而不是web。使用container_name可以自定义容器name，不过通过ps命令可以看到系统的缺省名称是web_1，如果自定义了，那么在集群上因为名称相同导致错误</p></li><li><p>exited with code 0：我用自定义的dockerfile启动容器，结果返回这么一个信息容器就停止了，我分析了官方例子做了一些测试后发现，如果你的容器启动后，什么都不做，那就会退出了，一些情况也是会退出的，比如你用 <code>command echo $HOME</code> 终端会打印这个信息，然后退出容器，我写了一个Python循环，用logging打印信息，终端一直在打印信息，没有退出。也就是说启动容器不能什么也不做</p></li><li><p>使用command，推荐绝对路径</p></li></ul><p>:sunny:docker-compose应该这么来理解，它把多个容器组织在一起，并默认加到一个网络中（如果你没有定义网络或把容器分到不同的网络），通过run命令可以向整个环境发送命令(<code>docker-compose run dev /bin/zsh</code> 进入交互环境)，同时也可以使用docker的命令。体现了一个整体的概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker 容器技术学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="docker" scheme="http://www.liuzhidream.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Collect</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Collect/collect/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Collect/collect/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:47:07.832Z</updated>
    
    <content type="html"><![CDATA[<p>常用内容收集整理，内容来自网络与个人整理</p><a id="more"></a><h1 id="收藏内容"><a href="#收藏内容" class="headerlink" title="收藏内容"></a>收藏内容</h1><p>内容来自<a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener">某位大佬</a>，网络收集与个人整理</p><h2 id="注册码"><a href="#注册码" class="headerlink" title="注册码"></a>注册码</h2><p><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><a href="https://www.jianshu.com/p/3ae2f024c291" target="_blank" rel="noopener">申请Let’s Encrypt永久免费SSL证书(来自简书)</a><br><a href="https://app.netlify.com/" target="_blank" rel="noopener">Netlify 是一个提供网络托管的综合平台</a></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><a href="https://github.com/nuxt/consola" target="_blank" rel="noopener">consola</a> 优雅命令行 console vuepress 也使用了</p><p><a href="https://github.com/nuxt/webpackbar" target="_blank" rel="noopener">webpackbar</a> webpack 打包进度可视化</p><p><a href="https://github.com/zouhir/jarvis" target="_blank" rel="noopener">jarvis</a> webpack dashboard</p><p><a href="https://github.com/Popmotion/popmotion" target="_blank" rel="noopener">popmotion</a> 一个函数式声明前端动画库</p><p><a href="https://github.com/lukechilds/merge-images" target="_blank" rel="noopener">merge-images</a> 图片合成</p><p><a href="https://github.com/NigelOToole/direction-reveal" target="_blank" rel="noopener">direction-reveal</a> 一个根据鼠标进入方向展现 hover 描述的库</p><p><a href="https://github.com/webkul/micron" target="_blank" rel="noopener">micron</a> 通过动画属性绑定动画效果的库</p><p><a href="https://github.com/sweetalert2/sweetalert2" target="_blank" rel="noopener">sweetalert2</a> 一个自适应优美自定义性强的弹出框</p><p><a href="https://github.com/photonstorm/phaser" target="_blank" rel="noopener">phaser</a> 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。<br>你可以为 iOS、 Android 和不同的本地应用程序创建游戏。</p><p><a href="https://github.com/Botre/vue-sauce" target="_blank" rel="noopener">vue-sauce</a> 一个可以展示 vue 源码的指令</p><p><a href="https://github.com/atomiks/tippyjs" target="_blank" rel="noopener">tippy.js </a>tooltip/popover library</p><p><a href="https://github.com/kutlugsahin/vue-smooth-dnd" target="_blank" rel="noopener">vue-smooth-dnd</a> Vue wrappers components for smooth-dnd</p><p><a href="https://github.com/text-mask/text-mask" target="_blank" rel="noopener">text-mask</a> 一个可以让 input 按照规则输入(如电话,email,日期等)</p><p><a href="https://github.com/CompuIves/codesandbox-client" target="_blank" rel="noopener">codesandbox-client</a> 在线 web 开发容器</p><p><a href="https://github.com/fkling/astexplorer" target="_blank" rel="noopener">astexplorer</a> 一个在线 ast 生成器</p><p><a href="https://github.com/sarahdayan/dinero.js" target="_blank" rel="noopener">dinero.js</a> 一个钱计算的库</p><p><a href="https://github.com/atulmy/crate" target="_blank" rel="noopener">crate</a> 一个 react 全栈练习(pc,mobile,rn,api)demo</p><p><a href="https://github.com/Jasonette/JASONETTE-iOS" target="_blank" rel="noopener">Jasonette</a>一个用 json 来构建 hybrid 的框架</p><p><a href="https://github.com/vuegg/vuegg" target="_blank" rel="noopener">vuegg</a> 一个 vue 可视化拖拽界面生成器</p><p><a href="https://github.com/sindresorhus/refined-github" target="_blank" rel="noopener">refined-github</a> 优化 github 默认功能的 chrome 插件</p><p><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">lerna</a> 大项目版本控制工具，项目中可以有多个 package.json 文件</p><p><a href="https://github.com/himynameisdave/git-labelmaker" target="_blank" rel="noopener">git-labelmaker</a> 命令行快速创建 github</p><p><a href="https://github.com/krasimir/react-in-patterns" target="_blank" rel="noopener">react-in-patterns</a> 一本开源叫你写 react 的书</p><p><a href="https://github.com/tehnokv/picojs" target="_blank" rel="noopener">picojs</a> js 人脸识别库</p><p><a href="https://github.com/RevillWeb/img-2" target="_blank" rel="noopener">img-2</a> 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览</p><p><a href="https://github.com/Valve/fingerprintjs2" target="_blank" rel="noopener">fingerprintjs</a> 是一个快速的浏览器指纹库</p><p><a href="https://github.com/epoberezkin/ajv" target="_blank" rel="noopener">ajv</a> 一个 json schema 验证的库</p><p><a href="https://github.com/xx45/dayjs" target="_blank" rel="noopener">dayjs</a> 一个轻量级类 moment.js API 时间库</p><p><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> 一个建议快速 dev 开发自动刷新的 http server</p><p><a href="https://github.com/zeit/serve" target="_blank" rel="noopener">serve</a>快速起本地静态服务</p><p><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">primjs</a> 代码高亮</p><p><a href="https://github.com/RelaxedJS/ReLaXed" target="_blank" rel="noopener">ReLaXed</a> 一个将 document html 转成 PDF 的工具</p><p><a href="https://github.com/fabricjs/fabric.js" target="_blank" rel="noopener">fabric.js</a> 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。</p><p><a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> 高颜值 ui 模板</p><p><a href="https://github.com/liabru/matter-js" target="_blank" rel="noopener">matter-js</a> web 物理引擎</p><p><a href="https://github.com/pshihn/rough" target="_blank" rel="noopener">rough</a> 基于 Canvas 的手绘风格图形库</p><p><a href="https://github.com/wiredjs/wired-elements" target="_blank" rel="noopener">wired-elements</a> 基于 rough.js 分装 button input raido 等组件 真正特别之处在于它的底层是 Web components</p><p><a href="https://github.com/transloadit/uppy" target="_blank" rel="noopener">uppy</a> 一个很好看的也很好用的 前端上传库</p><p><a href="http://ui.toast.com/tui-calendar/" target="_blank" rel="noopener">tui-calendar</a> 功能全面的日程安排日历控件，还支持拖拽。</p><p><a href="https://github.com/tabler/tabler" target="_blank" rel="noopener">tabler</a> 基于 Bootstrap 4 的 Dashboard UI Kit 和美观</p><p><a href="https://github.com/baianat/vee-validate" target="_blank" rel="noopener">vee-validate</a> 基于 vue 的验证，能验证的内容比较全</p><p><a href="https://yugasun.github.io/x-chart/#/" target="_blank" rel="noopener">x-chart</a> 我就是觉得颜色挺好看的</p><p><a href="https://github.com/lusaxweb/vuesax" target="_blank" rel="noopener">vuesax</a> 一个很漂亮的基于 vue 的 ui 框架</p><p><a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a> 基于 vue 的虚拟列表无限滚动</p><p><a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">particles.js</a> 一个前端画颗粒 粒子的库</p><p><a href="https://github.com/BoxFactura/pulltorefresh.js" target="_blank" rel="noopener">pulltorefresh.js</a> 下个下拉刷新插件</p><p><a href="https://github.com/yued-fe/lulu" target="_blank" rel="noopener">lulu</a> 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架</p><p><a href="https://github.com/chancejs/chancejs" target="_blank" rel="noopener">chancejs</a> 生成随机数据的库</p><p><a href="https://github.com/spritejs/spritejs" target="_blank" rel="noopener">spritejs</a> 360 奇舞团出的跨平台绘图对象模型</p><p><a href="https://github.com/googlechrome/workbox" target="_blank" rel="noopener">workbox</a> 让你的网站更方便的变成 pwa</p><p><a href="https://github.com/nhnent/tui.image-editor" target="_blank" rel="noopener">tui.image-editor</a> 一个功能齐全的在线图片编辑，基于 canvas</p><p><a href="https://github.com/deepsweet/hocs" target="_blank" rel="noopener">hocs</a> react 相关 hoc 收集库</p><p><a href="https://github.com/ai/nanoid" target="_blank" rel="noopener">nanoid</a> 前端轻量 unique string ID 生成库</p><p><a href="https://github.com/pubkey/rxdb" target="_blank" rel="noopener">rxdb</a> 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库</p><p><a href="https://github.com/MatteoGabriele/vue-analytics" target="_blank" rel="noopener">vue-analytics</a> 基于 vue 的 谷歌统计封装</p><p><a href="https://github.com/danburzo/percollate" target="_blank" rel="noopener">percollate</a> 命令行工具 能将网页转换成 pdf</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a> node 监听文件变化的库</p><p><a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener">fs-extra</a> fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API</p><p><a href="https://github.com/sindresorhus/globby" target="_blank" rel="noopener">globby</a> 用于模式匹配目录文件</p><p><a href="https://github.com/npm/node-semver" target="_blank" rel="noopener">node-semver</a> node 版本验证库</p><p><a href="https://github.com/mysticatea/npm-run-all/blob/master/docs/node-api.md" target="_blank" rel="noopener">npm-run-all</a> 一个 CLI 工具可以并行或者串行执行 script</p><p><a href="https://github.com/tapio/live-server" target="_blank" rel="noopener">live-server</a> 一个简单的 http server 带有 reload 功能</p><p><a href="https://github.com/indexzero/node-portfinder" target="_blank" rel="noopener">node-portfinder</a> 一个端口嗅探工具</p><p><a href="https://github.com/yeoman/update-notifier" target="_blank" rel="noopener">update-notifier</a> Update notifications for your CLI app</p><p><a href="https://github.com/yargs/y18n" target="_blank" rel="noopener">y18n</a> yargs 基于 i18n 的一个包</p><p><a href="https://github.com/klauscfhq/signale" target="_blank" rel="noopener">signale</a> Hackable console logger</p><p><a href="https://github.com/sindresorhus/execa" target="_blank" rel="noopener">execa</a> A better <code>child_process</code></p><p><a href="https://github.com/SamVerschueren/listr" target="_blank" rel="noopener">listr</a> Terminal task</p><p><a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander.js</a> 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单</p><p><a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">Inquirer.js</a> A collection of common interactive command line user interfaces. 命令行询问库</p><p><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> Elegant terminal spinner 命令行 loaidng</p><p><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a> 命令行着色美化库</p><p><a href="https://github.com/jondot/hygen" target="_blank" rel="noopener">hygen</a> 快速方便的创建代码 可以命令行创建预设的 template</p><p><a href="https://github.com/GoogleChromeLabs/ndb" target="_blank" rel="noopener">ndb</a> node 调试</p><p><a href="https://github.com/sindresorhus/got" target="_blank" rel="noopener">got</a> http 请求库 如果你觉得 request 太多的话 这是一个不错的选择</p><p><a href="https://github.com/zeeshanu/dumper.js" target="_blank" rel="noopener">dumper.js</a> 能让你的 node console 更加的规整，方便调试</p><p><a href="https://github.com/nswbmw/node-in-debugging" target="_blank" rel="noopener">node-in-debugging</a> node.js 调试指南</p><p><a href="https://github.com/i0natan/nodebestpractices" target="_blank" rel="noopener">nodebestpractices</a> node 最佳实践</p><p><a href="https://github.com/pyloque/fastscan" target="_blank" rel="noopener">fastscan</a> node 敏感词库</p><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p><a href="https://www.prisma.io/docs/" target="_blank" rel="noopener">prisma</a> 让前端也能快速的写出</p><p><a href="https://www.apollographql.com/" target="_blank" rel="noopener">Apollo GraphQL</a> 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便</p><h2 id="有趣1"><a href="#有趣1" class="headerlink" title="有趣1"></a>有趣1</h2><p><a href="https://github.com/hendricius/the-bread-code" target="_blank" rel="noopener">the-bread-code</a> 使用程序员的思维制作面包 ，比如制作中使用 A/B test,<br>来比较那种做法更好。</p><p><a href="https://github.com/danistefanovic/build-your-own-x" target="_blank" rel="noopener">build-your-own-x</a> 教你用各种语言实现 Bot Database Neural Network</p><p><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">javascript-algorithms </a> 教你用前端知识认识各种算法</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://github.com/high-speed-downloader/high-speed-downloader" target="_blank" rel="noopener">high-speed-downloader</a> 百度网盘不限速下载 支持 Windows 和 Mac</p><p><a href="https://github.com/zeit/hyper" target="_blank" rel="noopener">hyper</a> 前端命令行</p><p><a href="https://github.com/ymfe/yapi" target="_blank" rel="noopener">yapi</a> 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台</p><p><a href="https://sway.com/" target="_blank" rel="noopener">sway</a> 一个微软自己出的在线 ppt 很强大</p><p><a href="http://bigjpg.com/" target="_blank" rel="noopener">bigjpg</a> 放大图片的神器 通过神经网络可以放大图片并能降噪</p><p><a href="https://asciiartgen.now.sh" target="_blank" rel="noopener">Ascii Art Generator</a> 在线生成 Ascii 图案</p><p><a href="https://github.com/GetStream/Winds" target="_blank" rel="noopener">Winds</a> 开源 RSS</p><p><a href="https://github.com/kitze/JSUI" target="_blank" rel="noopener">JSUI</a> 一个用来控制管理前端项目的客户端</p><p><a href="https://github.com/pedronauck/docz" target="_blank" rel="noopener">docz</a> 让你能快速写文档的一个库</p><p><a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a> 性能统计分析工具</p><p><a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">verdaccio</a> 私有 npm</p><p><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git-guide</a> git 入门指南</p><p><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">git-tips</a> git 进阶</p><p><a href="https://github.com/teambit/bit" target="_blank" rel="noopener">bit</a> 实现了项目之间的代码共享 可以自建私有</p><p><a href="https://github.com/Kenshin/simpread" target="_blank" rel="noopener">simpread</a> 简悦 ( SimpRead ) - 让你瞬间进入沉浸式阅读的扩展</p><p><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert</a> 一键命令 让本地也支持 https</p><p><a href="https://github.com/nbedos/termtosvg" target="_blank" rel="noopener">termtosvg</a> 录制 命令操作转成 svg 基于 python</p><p><a href="https://github.com/apex/gh-polls" target="_blank" rel="noopener">gh-polls</a> 可以在 github issue 中添加投票</p><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">eruda</a> 移动端调试工具</p><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 也是一个移动端调试工具 腾讯出品</p><p><a href="https://github.com/faressoft/terminalizer" target="_blank" rel="noopener">terminalizer</a> 命令行录制工具 基于 node</p><p><a href="https://github.com/amio/badgen-service" target="_blank" rel="noopener">badgen</a> 快速构建和 shields 一样的 svg badge 但速度更快</p><p><a href="https://github.com/luin/readability" target="_blank" rel="noopener">readability</a> 移除页面非正文部分 基于 jsdom</p><p><a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a> 一款功能强大的 macOS 版微信小助手</p><p><a href="https://github.com/checkly/puppeteer-recorder" target="_blank" rel="noopener">puppeteer-recorder</a> 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码</p><p><a href="https://github.com/jxnblk/mdx-deck" target="_blank" rel="noopener">mdx-deck</a> 用 markdown 编写演示文稿</p><p><a href="https://github.com/pomber/code-surfer" target="_blank" rel="noopener">code-surfer</a> 基于 mdx-deck 的一个插件<br>让你更好的在文稿中展示 code</p><p><a href="https://progressivetooling.com/" target="_blank" rel="noopener">Progressive Tooling</a> 前端性能优化工具集合</p><p><a href="https://github.com/artf/grapesjs" target="_blank" rel="noopener">https://github.com/artf/grapesjs</a> 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了</p><p><a href="https://www.image-charts.com/" target="_blank" rel="noopener">image-charts</a> 该服务通过 URL 接受参数，然后生成图表，以图片形式返回</p><p><a href="https://github.com/Zulko/eagle.js" target="_blank" rel="noopener">eagle.js</a> 一个用 vue 来制作 PPT 的库</p><p><a href="https://www.optimizely.com/" target="_blank" rel="noopener">Optimizely</a> A/B Test</p><p><a href="http://www.appadhoc.com/" target="_blank" rel="noopener">appadhoc</a> 一个国内的 A/B Test 服务</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p><a href="https://itunes.apple.com/cn/app/get-plain-text/" target="_blank" rel="noopener">get-plain-text</a> 能清除剪贴板里的格式 很实用</p><p><a href="https://github.com/lhc70000/iina" target="_blank" rel="noopener">IINA</a> mac 平台感觉免费最好的播放器 强推</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://git.io" target="_blank" rel="noopener">github 短域名服务</a></p><p><a href="https://shields.io/" target="_blank" rel="noopener">shields</a> Github README 里面的装逼小图标</p><p><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">Emoji</a> 方便平时写查找 emoji</p><p><a href="http://emoji.muan.co/#" target="_blank" rel="noopener">emoji.muan</a> 同上 而且更全</p><p><a href="http://git-awards.com/users/search?login=panjiachen" target="_blank" rel="noopener">git-awards</a> github ranking 没事可以查着玩玩</p><p><a href="http://githubrank.com/" target="_blank" rel="noopener">http://githubrank.com/</a> github 按照 followers 排名</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p><a href="https://app.zeplin.io/" target="_blank" rel="noopener">zeplin</a> 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。</p><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a> 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。</p><p><a href="http://cssicon.space/#/" target="_blank" rel="noopener">cssicon</a> 所有的 icon 都是纯 css 画的 缺点：icon 不够多</p><p><a href="http://zhitu.isux.us/" target="_blank" rel="noopener">智图</a> 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用</p><p><a href="https://www.picdiet.com/zh-cn" target="_blank" rel="noopener">picdiet</a> 另一个图片压缩网站</p><p><a href="http://apps.eky.hk/css-triangle-generator/" target="_blank" rel="noopener">CSS triangle generator</a> 帮你快速用 css 做出三角形</p><p><a href="http://www.cssarrowplease.com/" target="_blank" rel="noopener">cssarrowplease</a> 帮你做对话框三角的</p><p><a href="http://bennettfeely.com/clippy/" target="_blank" rel="noopener">clippy</a> 在线帮你使用 css clip-path 做出各种形状的图形</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expressions</a> 在线正则网站</p><p><a href="https://jex.im/regulex/" target="_blank" rel="noopener">jex</a> 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多</p><p><a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a> 在线运行代码网站 很不错，可惜要翻墙</p><p><a href="https://codepan.net/" target="_blank" rel="noopener">codepan</a> 在线运行代码网站 不用翻墙，可以自己部署</p><p><a href="https://fiddle.md/" target="_blank" rel="noopener">fiddle.md</a> 一个方便的在线共享 markdown 在线笔试题一般都用这个</p><p><a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a> cdn 服务</p><p><a href="https://unpkg.com" target="_blank" rel="noopener">unpkg</a> cdn 服务</p><p><a href="https://coderpad.io/" target="_blank" rel="noopener">coderpad</a> 远程面试的神器，可以让面试者远程写代码 不过需要翻墙</p><p><a href="http://www.icode.live/" target="_blank" rel="noopener">icode</a> 有赞团队出品的 coderpad 可以互补，它不需要翻墙</p><p><a href="https://snipper.io" target="_blank" rel="noopener">snipper</a> 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。</p><p><a href="https://codesandbox.io/" target="_blank" rel="noopener">codesandbox</a> 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器</p><p><a href="https://tympanus.net/codrops/" target="_blank" rel="noopener">codrops</a> 上面的交互都非常酷炫</p><p><a href="http://www.aigei.com/bgremover" target="_blank" rel="noopener">bgremover</a> 在线图片去底工具</p><p><a href="https://www.photopea.com/" target="_blank" rel="noopener">photopea</a> 一个网页端 Photoshop 很变态</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p><a href="https://uimovement.com/" target="_blank" rel="noopener">uimovement</a> 能从这个网站找到不少动画交互的灵感</p><p><a href="https://www.awwwards.com/" target="_blank" rel="noopener">awwwards</a>是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站</p><p><a href="https://dribbble.com/" target="_blank" rel="noopener">dribbble</a> 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的</p><p><a href="https://www.behance.net/" target="_blank" rel="noopener">Bēhance</a> dribbble 是设计师的微博，Bēhance 是设计师的博客</p><p><a href="https://logojoy.com/" target="_blank" rel="noopener">Logojoy</a> 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。</p><p><a href="http://brandmark.io/" target="_blank" rel="noopener">brandmark</a> 另一个在线制作 logo 网站(这个不打水印，很良心)</p><p><a href="https://instantlogodesign.com/" target="_blank" rel="noopener">instant</a> 有一个 logo 制作网站</p><p><a href="https://coolors.co/" target="_blank" rel="noopener">coolors</a> 帮你在线配色的网站 你能找到不少配色灵感</p><p><a href="http://colorhunt.co/" target="_blank" rel="noopener">colorhunt</a> 另一个配色网站</p><p><a href="https://uigradients.com/#SummerDog" target="_blank" rel="noopener">uigradients</a> 渐变色网站</p><h2 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h2><p><a href="http://www.baidu-x.com/" target="_blank" rel="noopener">帮你百度一下</a> 可以 <a href="http://www.baidu-x.com/?q=%E5%92%8C%E8%B0%90%E6%9C%89%E7%88%B1%E5%AF%8C%E5%BC%BA" target="_blank" rel="noopener">点我测试一下</a></p><p><a href="http://lmgtfy.com/" target="_blank" rel="noopener">国际版</a> 同<code>帮我百度一下</code> <a href="http://lmgtfy.com/?q=a" target="_blank" rel="noopener">点我测试一下</a></p><p><a href="https://alpha.wallhaven.cc/" target="_blank" rel="noopener">wallhaven</a> 壁纸网站</p><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p><a href="http://aliscued.lofter.com/" target="_blank" rel="noopener">微交互</a> 里面收集了市面上很多很好的微交互例子 值得学习</p><p><a href="http://littlebigdetails.com/" target="_blank" rel="noopener">Little Big Details</a> 同上，一个国外微交互汇集网站</p><p><a href="https://cruip.com/" target="_blank" rel="noopener">cruip</a> 登录页的各种页面设计，可以免费下载模板</p><h2 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h2><p><a href="https://css-tricks.com/" target="_blank" rel="noopener">css-tricks</a> 一个学习 css 不错的网站 有很多有意思的 demo</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://egghead.io/courses/execute-npm-package-binaries-with-the-npx-package-runner" target="_blank" rel="noopener">npx</a> 教你怎么合理的使用 npx</p><h2 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h2><p><a href="http://www.pmdaniu.com/" target="_blank" rel="noopener">产品大牛</a> 什么有很多完整的产品原型可以借鉴</p><p><a href="https://modao.cc/pricing" target="_blank" rel="noopener">磨刀</a> 快速出 ui 原型</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用内容收集整理，内容来自网络与个人整理&lt;/p&gt;
    
    </summary>
    
      <category term="collect" scheme="http://www.liuzhidream.com/categories/collect/"/>
    
    
      <category term="water" scheme="http://www.liuzhidream.com/tags/water/"/>
    
  </entry>
  
  <entry>
    <title>Python-threading</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T15:52:04.697Z</updated>
    
    <content type="html"><![CDATA[<p>python多线程相关笔记</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL）</p><p>可以通过time.sleep(3)来阻塞线程</p><p>一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 此时创建列表a占用了解释器，先hello world 再 sleep</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11111111111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器）</span></span><br></pre></td></tr></table></figure><h2 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h2><ul><li>current_thread()  # 返回当前线程对象.</li><li>main_thread()  # 返回主线程对象.</li><li>active_count()  # 当前处于alive状态的线程个数.</li><li>enumerate()  # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程.</li><li>get_ident()  # 返回当前线程ID，非0整数.</li></ul><p>看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># a = [i for i in range(1111)]</span></span><br><span class="line">    print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">    print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">    print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line">print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br></pre></td></tr></table></figure><p>运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。</p><h2 id="thread实例的属性和方法"><a href="#thread实例的属性和方法" class="headerlink" title="thread实例的属性和方法"></a>thread实例的属性和方法</h2><ul><li>name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。</li><li>ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。</li><li>is_alive(): 返回线程是否活着。</li></ul><p>通过threading.Thread()  我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性</p><p><code>t = threading.Thread(target=func, name=&#39;my_thread&#39;, args=(&#39;1&#39;, ), kwargs={&#39;a&#39;: 2})</code></p><ul><li>start(): 启动线程。每一个线程必须且只能执行该方法一次。</li></ul><p>开始线程活动。</p><p>对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。<br>当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。</p><ul><li>run(): 运行线程函数。</li></ul><p>代表了线程活动的方法。</p><p>你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。</p><p>start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。</p><p>而run只在当前线程中执行。</p><h2 id="多线程情况"><a href="#多线程情况" class="headerlink" title="多线程情况"></a>多线程情况</h2><p>继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line">        <span class="comment"># print(threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.main_thread())</span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.start()</span><br><span class="line">t2.start()</span><br><span class="line">t.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># &lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。</p><p>打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。</p><p>换成run()方法后，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        <span class="comment"># print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.run()</span><br><span class="line">t2.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，run就是去调用函数，谁来调用呢？当然是<code>当前线程</code>了，可以看到 <code>print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</code> 打印出来的都是主线程。</p><p><strong>没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。</strong></p><p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p><p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个<code>主线程</code>。其他线程称为<code>工作线程</code>。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。</p><p>print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。</p><p>说明print函数不是线程安全函数。</p><p>print函数还没执行换行符，就被其它线程打断了，在python3中：</p><p><code>def print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None)</code></p><p>print变成了函数，结尾默认加‘\n’，你可以去改变这个参数，比如改成’’, 打印结果就是一行的一串字符</p><p>线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。</p><h2 id="线程daemon"><a href="#线程daemon" class="headerlink" title="线程daemon"></a>线程daemon</h2><p>线程可以被标识为”Daemon线程”，<strong>Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出</strong>。该属性值继承自父线程，可通过setDaemon()函数设定该值。</p><p>daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)：</p><ul><li>进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。</li><li>主线程是第一个启动的线程。</li><li>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</li><li>子线程：B就是A的子线程。</li><li>python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。</li></ul><p>daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。</p><blockquote><p>daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完<br>daemon=True 运行发现主线程执行完程序立即结束了</p></blockquote><p>实例方法：</p><p>isDaemon()：是否是daemon线程。<br>setDaemon()：设置为daemon线程，必须在start方法之前设置。</p><p>总结:</p><p>线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。</p><p>如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。</p><p>主线程是non-daemon线程，即daemon=False。</p><p>从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。</p><p>python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p><ul><li>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束</li><li>如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。</li></ul><p>线程创建的时候<code>t = threading.Thread(target=func, daemon=False)</code>这个daemon不设置就是False</p><p>子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。</p><p>Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=foo, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line"><span class="comment"># t1.join()  # 设置join.</span></span><br><span class="line">print(<span class="string">'Main Thread Exiting'</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3…..</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul><li>使用了join方法后，daemon线程执行完了，主线程才退出。</li><li>join(timeout=None)，是线程的标准方法之一。</li><li>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。</li><li>一个线程可以被join多次。</li><li>timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。</li><li>调用谁的join方法，就是join谁，就要等谁。</li></ul><p>把上面例子的 <code>t1.join()  # 设置join.</code> 放开，<code>print(&#39;Main Thread Exiting&#39;)</code> 要等子线程执行完成才执行。</p><p>join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。</p><p>总结：</p><p>主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。</p><p>在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br></pre></td></tr></table></figure><p>利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列）</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制</code></p><ul><li>queue.qsize() 返回队列的大小</li><li>queue.empty() 如果队列为空，返回True，反之False</li><li>queue.full() 如果队列满了，返回True，反之False</li><li>queue.full 与 maxsize 大小对应</li><li>queue.get([block[, timeout]])获取队列，timeout等待时间</li><li>queue.get_nowait() 相当queue.get(False)</li><li>queue.put(item) 写入队列，timeout等待时间</li><li>queue.put_nowait(item) 相当queue.put(item, False)</li><li>queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号</li><li>queue.join() 实际上意味着等到队列为空，再执行别的操作</li></ul><h2 id="本地线程"><a href="#本地线程" class="headerlink" title="本地线程"></a>本地线程</h2><p>不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响，在flask框架中有使用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_data = threading.local()</span><br><span class="line">my_data.number = <span class="number">42</span></span><br><span class="line">print(my_data.number)</span><br><span class="line">log = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    my_data.number = <span class="number">11</span></span><br><span class="line">    log.append(my_data.number)</span><br><span class="line">    print(id(my_data.number))</span><br><span class="line"></span><br><span class="line">thread = threading.Thread(target=f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br><span class="line">print(log)</span><br><span class="line">print(my_data.number)</span><br><span class="line">print(id(my_data.number))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559721904</span></span><br><span class="line"><span class="comment"># [11]</span></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559722896</span></span><br></pre></td></tr></table></figure><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>控制多线程同时访问资源，包括互斥锁，信号量，条件变量，事件</p><p>以房间为例子举例：</p><p>有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>还有些房间，可以同时容纳n个人。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用信号量做为同步机制，使用with进入上下文管理器，省略了acquire和release，信号量通过计数器来管理，这里计数器初始是3，获取acquire操作，计数器减1，release操作，计数器加1，当计数器为0的时候，阻塞其它线程的操作。</p><p>通过执行结果可以看到，创建了5个线程，前3个线程 0，1，2 执行了 acquire操作，使得信号量为0，阻塞了其它线程，通过sleep模拟<br>线程阻塞，等到线程 2 release的时候，线程 3 才执行 acquire 操作，4 线程也是等待 3 线程release后才执行 acquire。</p><p>通过使用信号量，实现了只能有3个线程并发，而锁其实就是信号量为1的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"></span><br><span class="line">sema = Semaphore(<span class="number">3</span>) <span class="comment"># 创建信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(tid)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> sema:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> acquire sema'</span>)</span><br><span class="line">        time.sleep(random() * <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> release sema'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = Thread(target=foo, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">    i.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 acquire sema</span></span><br><span class="line"><span class="comment"># 1 acquire sema</span></span><br><span class="line"><span class="comment"># 2 acquire sema</span></span><br><span class="line"><span class="comment"># 2 release sema</span></span><br><span class="line"><span class="comment"># 3 acquire sema</span></span><br><span class="line"><span class="comment"># 3 release sema</span></span><br><span class="line"><span class="comment"># 4 acquire sema</span></span><br><span class="line"><span class="comment"># 1 release sema</span></span><br><span class="line"><span class="comment"># 0 release sema</span></span><br><span class="line"><span class="comment"># 4 release sema</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。</p><p>线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。</p><ol><li><p>协同式多任务处理<br>当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。</p></li><li><p>抢占式多任务处理<br>Python线程可以主动释放 GIL，也可以先发制人抓取 GIL 。</p></li></ol><p>让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python多线程相关笔记&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-异步与协程</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Python-asyncio/README/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Python-asyncio/README/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2019-01-09T16:09:22.044Z</updated>
    
    <content type="html"><![CDATA[<p>异步编程是一个很难的点，不同于同步编程，编程模型将变得复杂。下文引用理查德·史蒂文斯（William Richard (Rich) Stevens，1951年2月5日－1999年9月1日）所编写的《UNIX网络编程》关于I/O Models 部分内容，并结合个人以及网络上的内容做的整理，关于Linux编程遇到的函数，由于没有太多的接触，先做个理解。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。<br>注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换。</li></ul><h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p><h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h3 id="缓存-IO"><a href="#缓存-IO" class="headerlink" title="缓存 IO"></a>缓存 IO</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>缓存 IO 的缺点：</p><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h3 id="recvfrom-recv"><a href="#recvfrom-recv" class="headerlink" title="recvfrom() recv()"></a>recvfrom() recv()</h3><p>本函数用于从（已连接）套接口上接收数据，并捕获数据发送源的地址。recv也是差不多的功能，不过不能知道对端地址信息（由谁发来的）</p><h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><ul><li><p>概念：消息的通知机制</p></li><li><p>解释：涉及到IO通知机制；所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。</p></li></ul><p>反应到编程模型中：同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p><h2 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h2><ul><li><p>概念：程序等待调用结果时的状态</p></li><li><p>解释：涉及到CPU线程调度；所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。</p></li></ul><p>反应到编程模型中：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p><p>有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。</p><p>对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：</p><ol><li>如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；</li><li>如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；</li></ol><p>所以同步的实现方式会有两种：<code>同步阻塞</code>、<code>同步非阻塞</code>；同理，异步也会有两种实现：<code>异步阻塞</code>、<code>异步非阻塞</code></p><p>对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回</p><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</p><p>场景举例：</p><p>去银行营业厅办业务员，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p><p>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p><p>也就是说，你去排队，要时不时留意有没有排队排到你了，这是同步机制（如果是等叫号就是异步机制），然后你在排队的时候如果不做其它事情，就是阻塞（如果排队的时候玩手机，就是非阻塞），共可以组合出4种情况，也就是对应<code>同步阻塞</code>、<code>同步非阻塞</code>、<code>异步阻塞</code>、<code>异步非阻塞</code></p><p>但是需要注意了，同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p><p><strong>1. 同步阻塞形式</strong><br>效率是最低的，拿上面的例子来说，就是你专心排队，什么别的事都不做。</p><p><strong>2. 异步阻塞形式</strong><br>如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。</p><p><code>异步操作是可以被阻塞住的</code>，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</p><p>比如select 函数，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处。</p><p><strong>3. 同步非阻塞形式</strong><br>实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p><p>很多人会写阻塞的read/write 操作，但是别忘了可以对fd设置O_NONBLOCK 标志位，这样就可以将同步操作变成非阻塞的了。</p><p><strong>4. 异步非阻塞形式</strong><br>效率更高，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。<br>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p><p>如果使用异步非阻塞的情况，比如aio_*组的操作，当发起一个aio_read操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。</p><p>很多人会把同步和阻塞混淆，我想是因为很多时候同步操作会以阻塞的形式表现出来，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。</p><p>同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p><h2 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h2><ul><li>blocking IO （阻塞IO）</li><li>nonblocking IO （非阻塞IO）</li><li>IO multiplexing （IO多路复用）</li><li>signal driven IO （信号驱动IO）</li><li>asynchronous IO （异步IO）</li></ul><p>以上五种IO模型不仅在操作系统中存在，也可以引申到编程模型中，有些框架的原理就是其中的一种。</p><p>再说一下IO发生时涉及的对象和步骤。</p><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br>对于socket流而言，<br>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。<br>第二步：把数据从内核缓冲区复制到应用进程缓冲区。<br>网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。</li></ol><p>最后，记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</p><h3 id="blocking-IO"><a href="#blocking-IO" class="headerlink" title="blocking IO"></a>blocking IO</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/blocking-io.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p><h3 id="non-blocking-IO"><a href="#non-blocking-IO" class="headerlink" title="non-blocking IO"></a>non-blocking IO</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/noblocking-io.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。</p><h3 id="IO-multiplexing"><a href="#IO-multiplexing" class="headerlink" title="IO multiplexing"></a>IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/io-multiplexing.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><p>IO多路复用是需要特别理解的，因为在很多框架中都有运用，再多啰嗦几句：</p><p>网络模型：</p><p>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的。</p><p>IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是<code>阻塞</code>的。select或poll调用之后，会<code>阻塞进程</code>，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧。</p><p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。</p><p>对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。</p><p>:sunny:<strong>总结</strong>：blocking IO只处理一个IO，IO multiplexing通过系统调用函数，处理多个IO。no-blocking IO 的轮询是用户态的（由当前进程来执行），多路复用的轮询由系统调用来执行，可以等待多个socket，能实现同时对多个IO端口进行监听。</p><p>I/O多路复用的主要应用场景如下：</p><ul><li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</li><li>服务器需要同时处理多种网络协议的套接字。</li></ul><p>了解了前面三种IO模式，在用户进程进行系统调用的时候，他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询，两个阶段过程：</p><ul><li>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</li><li>第二个阶段都是阻塞的。</li></ul><p>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态</p><p>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</p><p>注意：IO多路复用是同步阻塞模型还是异步阻塞模型：</p><p>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。</p><h3 id="signal-driven-IO"><a href="#signal-driven-IO" class="headerlink" title="signal-driven IO"></a>signal-driven IO</h3><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/signal-io.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h3><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/asynchronous-io.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪：</p><p>先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：</p><pre><code>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;An asynchronous I/O operation does not cause the requesting process to be blocked; </code></pre><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p>各个IO Model的比较如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/Python-async/io-models.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><p>最后，再举几个不是很恰当的例子来说明这四个IO Model:</p><p>有A，B，C，D四个人在钓鱼：</p><ul><li>A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；</li><li>B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；</li><li>C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；</li><li>D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。 </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步，异步，阻塞，非阻塞</p><p>同步和异步说的是消息通知的机制</p><p>同步调用，调用者要一直等待消息返回，编程模型就是由A向B发起了请求，B要把本次请求的任务做完成，然后返回数据给A（通知A任务完成了）。</p><p>这里对于任务的调用又会有<code>阻塞</code>和<code>非阻塞</code>，阻塞的编程模型就是在B中，数据还没准备好，但是它不会返回给你，A没有得到返回，要一直等着。如果是非阻塞，编程模型就是在B中，可能会去查数据，没查到（说明内核没有准备好数据），就返回，A收到返回了（假设是一个错误信息，即数据没准备好），A的请求不被B影响，它不需要等待，但是你是同步的，如果A没得到数据，虽然没阻塞A调用，A可以去做其它事情，但是A仍然要再次去请求B，整个调用是同步的，A不去请求B，没人会通知A，所以同步非阻塞是效率低下的编程模型。</p><p>异步就是B不需要立即通知A，A可以马上得到返回，B通过回调机制来通知A，这个回调机制就是通知A的手段，可以比喻成发短信，打电话，编程模型就是要准备回调函数，这个回调函数内去通知A。</p><ul><li>异步阻塞，A调用B，A不会得到返回，等着回调函数来通知A，A的调用被阻塞了</li><li>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞</li><li>异步非阻塞，A调用B，A不会被阻塞，等待回调函数来通知A</li></ul><p>同步和阻塞，异步和非阻塞，很容易混淆概念，把同步当成是阻塞的，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。</p><p>一般情况，我们不会自己处理这么复杂的编程模型，都是使用现成的模型，linux中的5种IO模型，再比如webserver中，利用gunicorn+django的方式部署项目，理解此时的IO模型是什么样的，gunicorn使用不同的worker模式，IO模型是什么样的。更加细的理解要结合内核态和用户态，操作系统的机制来。理解好概念，当真的需要编写相关代码的时候，理解好整个编程模型，知道什么操作被阻塞，是同步机制还是异步机制。</p><p>理解“消息通知机制”和“等待消息通知时的状态（程序等待调用结果时的状态）”这两个概念，这是理解四个概念的关键所在。</p><p>关于异步阻塞：</p><p>业务逻辑需要的是做完一件事后做另一件事，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。另外一种使用阻塞方式的理由是降低响应延迟。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        v = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">f'consume: <span class="subst">&#123;v&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">13</span>):</span><br><span class="line">        c.send(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">c.send(<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">producer(c)</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        v = <span class="keyword">yield</span> r</span><br><span class="line">        print(<span class="string">f'consume: <span class="subst">&#123;v&#125;</span>'</span>)</span><br><span class="line">        r = <span class="string">f'Result : <span class="subst">&#123;v * <span class="number">2</span>&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">13</span>):</span><br><span class="line">        print(<span class="string">f'Producing... <span class="subst">&#123;i&#125;</span>'</span>)</span><br><span class="line">        r = c.send(i)</span><br><span class="line">        print(<span class="string">f'Consumer return: <span class="subst">&#123;r&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">c.send(<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">producer(c)</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">framework</span><span class="params">(logic)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        it = logic()</span><br><span class="line">        s = next(it)</span><br><span class="line">        print(<span class="string">f'[FX] logic: <span class="subst">&#123;s&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'[FX] do something...'</span>)</span><br><span class="line">        it.send(<span class="string">f'async: <span class="subst">&#123;s&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logic</span><span class="params">()</span>:</span></span><br><span class="line">    s = <span class="string">'Logic'</span></span><br><span class="line">    r = <span class="keyword">yield</span> s</span><br><span class="line">    print(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">framework(logic)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异步编程是一个很难的点，不同于同步编程，编程模型将变得复杂。下文引用理查德·史蒂文斯（William Richard (Rich) Stevens，1951年2月5日－1999年9月1日）所编写的《UNIX网络编程》关于I/O Models 部分内容，并结合个人以及网络上的内容做的整理，关于Linux编程遇到的函数，由于没有太多的接触，先做个理解。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
</feed>
