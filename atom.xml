<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VanLiuZhi</title>
  
  <subtitle>有梦想的人不睡觉</subtitle>
  <link href="/learn_programing/atom.xml" rel="self"/>
  
  <link href="http://www.liuzhidream.com/"/>
  <updated>2018-10-21T16:00:00.000Z</updated>
  <id>http://www.liuzhidream.com/</id>
  
  <author>
    <name>Liu Zhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git-command</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Git/git-command/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Git/git-command/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。</p><a id="more"></a><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>使用GitHub，给出的地址我们一般用ssh。使用ssh需要https，如果不支持只能使用http，但是每次都要输口令。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>Git鼓励大量使用分支：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch \<name></name></li><li>切换分支：git checkout \<name></name></li><li>创建+切换分支：git checkout -b \<name></name></li><li>合并某分支到当前分支：git merge \<name></name></li><li>删除分支：git branch -d \<name></name></li></ul><p>主要理解分支，克隆远程仓库，将本地和远程仓库关联，搭建git服务器</p><h2 id="git-pull-命令"><a href="#git-pull-命令" class="headerlink" title="git pull 命令"></a>git pull 命令</h2><p>作用：取回远程主机某个分支的更新，再与本地的指定分支合并</p><p>格式：git pull  &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p><ol><li>如果与当前分支合并，则可省略本地分支名git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 相当于：git fetch &lt;远程主机名&gt; &lt;远分支名&gt; git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</li><li>如果当前分支与远程分支存在追踪关系 git pull &lt;远程主机名&gt;</li><li>如果当前分支只有一个追踪关系 git pull</li><li>手动建立追踪关系 git branch –set-upstream master origin/next</li><li>清理远程已删除本地还存在的分支 git fetch –prune origin 或者 git fetch -p 或者 git pull -p</li></ol><h2 id="如何上传GitHub"><a href="#如何上传GitHub" class="headerlink" title="如何上传GitHub"></a>如何上传GitHub</h2><ol><li>在用户目录下 .ssh</li><li>ssh-keygen -t rsa -C “<a href="mailto:1441765847@qq.com" target="_blank" rel="noopener">1441765847@qq.com</a>“ </li><li>把 id_rsa.pub  添加到GitHub的ssh上</li><li>git init  把当前目录变为仓库</li><li>git add  把文件添加进仓库  git commit 把文件提交到仓库  </li><li>git add –all 当我们在一个不是空目录下init需要把所有文件添加到仓库的时候使用</li></ol><h2 id="文件的标记解释："><a href="#文件的标记解释：" class="headerlink" title="文件的标记解释："></a>文件的标记解释：</h2><pre><code>A: 你本地新增的文件（服务器上没有）.C: 文件的一个新拷贝.D: 你本地删除的文件（服务器上还在）.M: 文件的内容或者mode被修改了.R: 文件名被修改了。T: 文件的类型被修改了。U: 文件没有被合并(你需要完成合并才能进行提交)。X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。</code></pre><p>git pull</p><p>git pull origin master</p><p>git pull origin master<br> –allow-unrelated-histories</p><h2 id="git的hook-钩子"><a href="#git的hook-钩子" class="headerlink" title="git的hook(钩子)"></a>git的hook(钩子)</h2><p>为了防止一些不规范的代码 <code>commit</code> 并 <code>push</code> 到远端，我们可以在  <code>git</code> 命令执行前用一些钩子来检测并阻止。<br>在node中，安装需要的模块：<code>husky</code>, <code>pre-commit</code> 配置package.json在提交代码前执行自定义的脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .git/hooks</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>该目录提供了git的各个钩子的脚步案例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.liuzhidream.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/ECMAScript/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/ECMAScript/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等</p><a id="more"></a><h1 id="ECMAScript6"><a href="#ECMAScript6" class="headerlink" title="ECMAScript6"></a>ECMAScript6</h1><p>ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等</p><h2 id="扩展运算符（-spread-）"><a href="#扩展运算符（-spread-）" class="headerlink" title="扩展运算符（ spread ）"></a>扩展运算符（ spread ）</h2><p>是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">  <span class="string">'name'</span>: <span class="string">'little bear'</span>,</span><br><span class="line">  <span class="string">'age'</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">'sayHello'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.Person + <span class="string">'我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁!'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.sayHello()</span><br></pre></td></tr></table></figure><p>基础语法</p><ul><li>(参数1, 参数2, …, 参数N) =&gt; {函数声明}</li><li>(参数1, 参数2, …, 参数N) =&gt; 表达式（单一）</li></ul><p>相当于：(参数1, 参数2, …, 参数N) =&gt;{ return表达式}</p><ol><li>当只有一个参数时，圆括号是可选的：</li></ol><ul><li>(单一参数) =&gt; {函数声明}</li><li>单一参数 =&gt; {函数声明}</li></ul><ol start="2"><li>没有参数的函数应该写成一对圆括号。</li></ol><ul><li>() =&gt; {函数声明}</li></ul><p>在上面的代码里面，谁调用，this指向谁，所以this指向的是setInterval, 就是window（因为setInterval）是window就注入的函数。 所以在setInterval 上一行，我们可以var self = this此时的this是sayHello 由Person来调用，这样才能得到我们想要的结果。</p><p>箭头函数最大特点： 不绑定this  不绑定arguments</p><p>es6箭头函数，这个是原来定义函数的缩写。let 和原来的 var 类似，var是声明变量，它所处的位置决定了变量的作用域，比如在函数里面就是函数的作用于，在外部就是全局作用域。let也是这样，但是它的位置决定的是最接近的块的作用域，作用域比var更细，除了函数全局外，如果你用在for，if里面，那么在整个函数里面是不可见的。所以可以用let声明作用域更细的变量。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>理解继承的机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数我们称为构造函数，js通过对构造函数使用new 关键字创建实例（构造函数相当于Class），这样我们就从原型对象生产了一个实例对象。</p><ol><li>共有属性：</li></ol><ul><li>这样创建的实例没有共有属性，于是通过为构造函数设置prototype属性，来让从这个构造函数创建的实例都有共有属性。</li><li>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</li></ul><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p><p>这个prototype是大家共同引用的，修改它会影响实例。</p><ol start="2"><li>constructor：</li></ol><p>通过构造函数创建的实例，访问这个属性就可以知道实例的构造函数是谁。</p><p><code>cat1 instanceof Cat</code> 判断实例cat1是否是通过构造函数Cat来的，类似python的isinstance。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6.1 isPrototypeOf()</span><br><span class="line"></span><br><span class="line">这个方法用来判断，某个proptotype对象和某个实例之间的关系。</span><br><span class="line"></span><br><span class="line">　　alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line"></span><br><span class="line">　　alert(Cat.prototype.isPrototypeOf(cat2)); //true</span><br><span class="line"></span><br><span class="line">6.2 hasOwnProperty()</span><br><span class="line"></span><br><span class="line">每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</span><br><span class="line"></span><br><span class="line">　　alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line"></span><br><span class="line">　　alert(cat1.hasOwnProperty(&quot;type&quot;)); // false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prototype constructor</span><br><span class="line">__proto__</span><br></pre></td></tr></table></figure><ol start="3"><li>普通对象</li></ol><ul><li>最普通的对象：有<strong>proto</strong>属性（指向其原型链），没有prototype属性。</li><li>原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)。</li></ul><ol start="4"><li>函数对象：</li></ol><ul><li>凡是通过new Function()创建的都是函数对象。</li><li>拥有<strong>proto</strong>、prototype属性（指向原型对象）。</li><li>Function、Object、Array、Date、String、自定义函数。</li></ul><p>特例： Function.prototype(是原型对象，却是函数对象，下面会有解释)</p><ol start="4"><li>如何判断是什么对象 typeof 对象</li></ol><p>其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。</p><h2 id="早绑定和晚绑定"><a href="#早绑定和晚绑定" class="headerlink" title="早绑定和晚绑定"></a>早绑定和晚绑定</h2><p>所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。</p><p>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</p><p>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p><h2 id="文件导入"><a href="#文件导入" class="headerlink" title="文件导入"></a>文件导入</h2><p>export default 和 export 区别：</p><ol><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</li><li>在一个文件或模块中，export、import可以有多个，export default仅有一个</li><li><p>通过export方式导出，在导入时要加{ }，export default则不需要</p></li><li><p>export</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> str = <span class="string">"blablabla~"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">sth</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> sth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; str, log &#125; <span class="keyword">from</span> <span class="string">'a'</span>; <span class="comment">//也可以分开写两次，导入的时候带花括号</span></span><br></pre></td></tr></table></figure><ol start="2"><li>export default</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"blablabla~"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str;</span><br></pre></td></tr></table></figure><p>对应的导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> str <span class="keyword">from</span> <span class="string">'a'</span>; <span class="comment">//导入的时候没有花括号</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p><code>Object.assign({}, row)</code> 拷贝对象</p><h2 id="import和require的区别"><a href="#import和require的区别" class="headerlink" title="import和require的区别"></a>import和require的区别</h2><p>node编程中最重要的思想就是模块化，import和require都是被模块化所使用。</p><ol><li>遵循规范</li></ol><ul><li>require 是 AMD规范引入方式</li><li>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li></ul><ol start="2"><li>调用时间</li></ol><ul><li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li><li>import是编译时调用，所以必须放在文件开头</li></ul><ol start="3"><li>本质</li></ol><ul><li>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</li><li>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</li></ul><p>引用同级文件 <code>a.js</code>，<code>b.js</code> 都在一起，应该 <code>import  ./b</code> 不要直接 <code>import b</code></p><p>1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）<br>2，等同于在自组件中：<br>   子组件内部处理click事件然后向外发送click事件：$emit(“click”.fn)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>element-UI</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/element-UI/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/element-UI/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>饿了么前端团队出品的Vue UI框架</p><a id="more"></a><h1 id="element-UI"><a href="#element-UI" class="headerlink" title="element UI"></a>element UI</h1><p>饿了么前端团队出品的Vue UI框架</p><h2 id="from-rules"><a href="#from-rules" class="headerlink" title="from rules"></a>from rules</h2><p>from rules 是表单组件中用于在表单验证规则的属性，把rules绑定给一个对象，对象的属性即为需要做验证的字段，属性值为验证规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rules: &#123;</span><br><span class="line">type: [&#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'type is required'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;],</span><br><span class="line">timestamp: [&#123; <span class="attr">type</span>: <span class="string">'date'</span>, <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'timestamp is required'</span>, <span class="attr">trigger</span>: <span class="string">'change'</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对表单的type字段做规则验证，该字段是必须的。</p><h2 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h2><p>关于 Loading  拥有指令调用，服务调用（在需要的地方手动触发），指令的话就是 v-loading=’true’<br>即可。可以通过修饰符把效果的遮蔽罩覆盖到DOM的body上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;饿了么前端团队出品的Vue UI框架&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="farmework" scheme="http://www.liuzhidream.com/tags/farmework/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/jQuery/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/jQuery/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><a id="more"></a><h1 id="jQuery-方法"><a href="#jQuery-方法" class="headerlink" title="jQuery 方法"></a>jQuery 方法</h1><p>javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了</p><h2 id="each"><a href="#each" class="headerlink" title="each( )"></a>each( )</h2><p>如果是去迭代数组 类似 Inpute标签组成的 a:1,b:2：</p><p>使用 <code>$.each(对象，function（index,value）{   });</code> 这样可以拿到数组的键和值</p><p>如果是迭代元素 类似p标签的集合：</p><p>使用 <code>$(&quot;p&quot;).eache(function(index){  });</code> 在函数中，使用this得到当前迭代的元素  </p><h2 id="is"><a href="#is" class="headerlink" title="is()"></a>is()</h2><p>is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。</p><h2 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h2><p>解析一个字符串，并返回一个浮点数，参数必须且是一个字符</p><p>该函数先去判断第一个字符串是否是数字，不是，函数返回 NaN，是，继续执行。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p><p>NaN 属性是JS的Number对象，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。比如月份用数字5代表5月份，var number=5; number.NaN,number现在就不是数字了。</p><ul><li>isNaN()  该一个要检测的参数（必须）看是不是NaN，是就返回True 其它值返回False。</li><li>parseInt() 函数可解析一个字符串，并返回一个整数。</li><li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。即索引值。</li><li>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</li></ul><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>text（）用来设置或返回值，val()返回value的值</p><p>attr() 方法设置或返回被选元素的属性值。该方法不同的参数会有不同的效果</p><p>attr(“id”,123)   选择器得到的JQuery对象的attr方法，将对象的id 改变为 “123”（没有id直接添加一个id）</p><p>appendto() append()</p><p>append() 方法在被选元素的结尾（仍然在内部）插入指定内容。<br>提示：append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容的位置和选择器。<br>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p标签原来的内容 &lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br><span class="line">$(&quot;p&quot;).append(&quot; &lt;b&gt;Hello world!&lt;/b&gt;&quot;);   </span><br><span class="line">执行方法后  This is a paragraph. Hello world!</span><br><span class="line"></span><br><span class="line">$(&quot;&lt;b&gt; Hello World!&lt;/b&gt;&quot;).appendTo(&quot;p&quot;);</span><br><span class="line">p标签原内容和执行结果同上。</span><br></pre></td></tr></table></figure><p>find（）方法 由给定表达式去匹配满足条件的后代元素，返回jquery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b=$(<span class="string">"#id"</span>).find(<span class="string">'[name=id]'</span>);</span><br></pre></td></tr></table></figure><p>window.location.href=”url”  当前页面打开URL</p><p>当点击元素时，会发生 click 事件。</p><p>当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click。</p><p>click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数。</p><p>on 为元素绑定事件，比如click事件，然后加个函数，这个元素点击后就会去执行这个函数。</p><h2 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h2><p>jquery渲染页面方法，<code>$.html()</code> 对dom执行html方法，会将dom的内容给替换了，比如 <code>&lt;div class=123&gt;&lt;/div&gt;</code>  对这个dom执行方法<code>html(&lt;p&gt;123&lt;/p&gt;)</code> 结果是<code>&lt;div class=123&gt;&lt;p&gt;123&lt;/p&gt;&lt;/div&gt;</code></p><h2 id="元素切换"><a href="#元素切换" class="headerlink" title="元素切换"></a>元素切换</h2><p>sildeup sildedown，show hide 元素切换隐藏</p><h2 id="jQuery遍历"><a href="#jQuery遍历" class="headerlink" title="jQuery遍历"></a>jQuery遍历</h2><ul><li>siblings：<code>dom.siblings(.class).addClass()</code> 对选择对象执行遍历，找到所有class类，并给他们添加样式。</li></ul><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll()"></a>scroll()</h2><p>dom调用，可以在滚动条滚动的时候触发，只要有滚动就触发。这里注意如果逻辑涉及到滚动的数值判断，使用比较不要使用相等，因为滚动很快，相关的判断不一定每次执行到。</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>直接写在dom上，相当于 <code>style : dom.css(&#39;color&#39;, &#39;red&#39;)</code></p><p>hasClass()   addClass()   removClass()   对dom类的控制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>node</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/node/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/node/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端</p><a id="more"></a><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><p>服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端</p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack把多种静态资源转换成一个静态文件</p><h3 id="的含义"><a href="#的含义" class="headerlink" title="@ 的含义"></a>@ 的含义</h3><p>在webpack的配置中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在需要导入组件的时候使用 <code>import A from &#39;@/components/a.vue&#39;</code> 就是给复杂了引用路径做个别名。</p><h3 id="修改编译路径"><a href="#修改编译路径" class="headerlink" title="修改编译路径"></a>修改编译路径</h3><p>编译路径修改（由于存在编译出来的文件相互依赖的，而你只导入其中几个，依赖就出问题了，为了不修改后端代码，修改通用编译路径是不错的解决方案）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">assetsRoot: path.resolve(__dirname, <span class="string">'../static/dist'</span>),</span><br><span class="line">assetsSubDirectory: <span class="string">''</span>,</span><br><span class="line">assetsPublicPath: <span class="string">'/static/dist/'</span>,</span><br><span class="line">productionSourceMap: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>一个转码器，将es6转es5，这个东西何用？node.js直接执行es6代码还存在问题，听说最新版本可以了。所以用es6来写js，这样可以利用它的新特性，然后转码，这样node.js就可以运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/categories/Nodejs/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nvm</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/nvm/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/nvm/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><a id="more"></a><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><p>nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Mac 下安装使用github提供的脚本安装，安装完成添加对应shell的配置</p><p>nvm 使用brew安装会有一些小问题 <a href="https://www.imooc.com/article/14617" target="_blank" rel="noopener">正确的安装和使用nvm(mac)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span></span><br><span class="line"><span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p>github 地址 <a href="https://github.com/creationix/nvm/blob/master/README.md" target="_blank" rel="noopener">https://github.com/creationix/nvm/blob/master/README.md</a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>nvm install stable</td><td style="text-align:center">安装最新稳定版            </td></tr><tr><td>nvm install \<version></version></td><td style="text-align:center">安装指定版本，可模糊安。如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4   </td></tr><tr><td>nvm uninstall \<version></version></td><td style="text-align:center">删除已安装的指定版本，语法与install类似  </td></tr><tr><td>nvm ls</td><td style="text-align:center">列出所有安装的版本</td></tr><tr><td>nvm ls-remote</td><td style="text-align:center">列出所有远程服务器的版本（官方node version list）</td></tr><tr><td>nvm current</td><td style="text-align:center">显示当前的版本</td></tr><tr><td>nvm alias \<name> \<version></version></name></td><td style="text-align:center">给不同的版本号添加别名</td></tr><tr><td>nvm unalias \<name></name></td><td style="text-align:center">删除已定义的别名</td></tr><tr><td>nvm reinstall-packages \<version></version></td><td style="text-align:center">在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/categories/Nodejs/"/>
    
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>JavaScriptUtil</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScriptUtil/JavaScriptUtil/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScriptUtil/JavaScriptUtil/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>常见的JavaScript 相关设计</p><a id="more"></a><h1 id="JavaScript-相关设计"><a href="#JavaScript-相关设计" class="headerlink" title="JavaScript 相关设计"></a>JavaScript 相关设计</h1><p>常见的JavaScript 相关设计</p><h2 id="自定义遮蔽罩"><a href="#自定义遮蔽罩" class="headerlink" title="自定义遮蔽罩"></a>自定义遮蔽罩</h2><p>使用了jQuery-WeUI，需要根据情况做调整</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自定义遮罩层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bg"</span> <span class="attr">class</span>=<span class="string">"weui-mask weui-mask--visible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"display: none;opacity: 1;visibility: visible;z-index: 100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简单示例 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>html 最简遮罩层<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showDiv</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'popDiv'</span>).style.display = <span class="string">'block'</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'bg'</span>).style.display = <span class="string">'block'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">closeDiv</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'popDiv'</span>).style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'bg'</span>).style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"popDiv"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"z-index:99;display:none;position:absolute;margin-top: 20%;margin-left: 40%;background-color: #FFF;"</span>&gt;</span>html</span><br><span class="line">    最简遮罩层<span class="tag">&lt;<span class="name">br</span>/&gt;</span>html 最简遮罩层<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:closeDiv()"</span>&gt;</span>关闭遮罩层<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"display:none;background-color: #ccc;width: 100%;position:absolute;height: 100%;opacity: 0.5;z-index: 1;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"padding-top: 10%;padding-left:40%;z-index:1;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"Submit"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"打开遮罩层"</span> <span class="attr">onclick</span>=<span class="string">"javascript:showDiv()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的JavaScript 相关设计&lt;/p&gt;
    
    </summary>
    
      <category term="Util" scheme="http://www.liuzhidream.com/categories/Util/"/>
    
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="Util" scheme="http://www.liuzhidream.com/tags/Util/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Nginx/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Nginx/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。</p><a id="more"></a><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx的配置, 一般就是配server模块，该模块的全局定义，location 定义了正则的解析（向服务器请求各种资源，nginx应该如何处理）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="linux" scheme="http://www.liuzhidream.com/tags/linux/"/>
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>npm</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/npm/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/npm/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><a id="more"></a><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，实在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。</p><h2 id="全局和局部"><a href="#全局和局部" class="headerlink" title="全局和局部"></a>全局和局部</h2><p>一般在全局安装的是工具，比如webpack，这样这些工具在构建项目或者执行项目的命令的时候由于是全局任何地方都能使用，而局部就是装模块的，这些模块可能因为依赖关系，你最好不要在全局装模块，如果你的项目引用全局模块，多个项目的时候，可能依赖不一样，这样你去更新全局模块的时候就可能由于依赖的问题影响其它项目了。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>npm list -g –depth 0</td><td style="text-align:center">查看全局安装包 </td></tr><tr><td>npm install packagename -g</td><td style="text-align:center">全局安装</td></tr><tr><td>npm uninstall package -g</td><td style="text-align:center">全局卸载</td></tr><tr><td>npm install pg –save</td><td style="text-align:center">项目依赖安装</td></tr><tr><td>npm install pg –save-dev</td><td style="text-align:center">项目非依赖安装</td></tr><tr><td>npm view jquery versions</td><td style="text-align:center">查看模块版本号，这里举例的是jQuery</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/categories/Nodejs/"/>
    
    
      <category term="Nodejs" scheme="http://www.liuzhidream.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>RESTFulAPI</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/RESTFulAPI/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/RESTFulAPI/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。</p><a id="more"></a><h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>使用一种通用的风格，在团队开发中，也便于沟通。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>REST风格5个约束：客户端-服务端，无状态，缓存，统一接口，分层系统</p><ol><li><p>使用名词表示资源，动词通过HTTP方法来实现，比如删除资源使用DELETE方法。</p></li><li><p>关注请求头，比如请求头Accept要求返回application/xml，如果服务器只能放回json格式的，应该返回406错误。</p></li><li><p>使用正确的请求方法和状态码</p></li></ol><p>不能一味的使用POST和GET方法，HTTP方法表</p><table><thead><tr><th>Name</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td>OPTIONS</td><td style="text-align:left">用于获取资源支持的所以HTTP方法 </td></tr><tr><td>HRAD</td><td style="text-align:left">用于只获取请求某个资源返回的头信息 </td></tr><tr><td>GET</td><td style="text-align:left">用于从服务器获取某个资源的信息：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被请求的资源详细信息 </td></tr><tr><td>POST</td><td style="text-align:left">用于创建新资源：1.创建完成后，返回状态码201 Created 2.完成请求后，需要返回被创建的资源详细信息 </td></tr><tr><td>PUT</td><td style="text-align:left">用于完整的替换资源或者创建指定身份的资源：1.如果是创建了资源，则返回201 Created 2.如果是替换了资源，则返回200 OK </td></tr><tr><td>PATCH</td><td style="text-align:left">用于局部更新资源：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被修改的资源详细信息 3.完成请求后，需返回被修改的资源详细信息 </td></tr><tr><td>DELETE</td><td style="text-align:left">用于删除某个资源，完成请求后返回状态码204 No Content </td></tr></tbody></table><p>对输出结果不在封装：通过状态码来判断请求，不应该把信息写在响应体中</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Redis/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Redis/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。<br>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><a id="more"></a><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h2 id="Database-Number"><a href="#Database-Number" class="headerlink" title="Database Number"></a>Database Number</h2><p>Redis 使用 DB number 实现类似关系型数据库中 schema 的功能。不同 DB number 表示的数据库是隔离的，但是目前只能使用数字来表示一个数据库，Ubuntu 默认的配置文件配置了16个数据库，DB number 是从0开始的，并且默认连接0号数据库。</p><p><code>redis-cli -n &lt;dbnumber&gt;</code> 连接指定数据库</p><h2 id="在docker中使用Redis"><a href="#在docker中使用Redis" class="headerlink" title="在docker中使用Redis"></a>在docker中使用Redis</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。&lt;br&gt;Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
      <category term="database" scheme="http://www.liuzhidream.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/RabbitMQ/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/RabbitMQ/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><a id="more"></a><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>需要了解一个协议：AMQP协议，协议的流程由消息发布者，交换机，队列，到消息订阅者。交换机做路由分发，将收到的消息根据路由规则分发给绑定的队列。</p><ol><li><p>消息：消息实际包含两部分内容，1是有效载荷，就是要传输的数据，数据类型可以是纯文本或JSON。2是标签，它包含交换机的名字和可选的主题(topic)标记等，AMQP仅仅描述了标签，而RabbitMQ决定了把这个消息发给哪个消费者。</p></li><li><p>发布者：也就是生产者，创建消息并设置标签</p></li><li><p>消费者：消费者连接到代理服务器上，接受有效载荷，消费者不需要消息中的标签</p></li></ol><p>消息投递失败会重发，保证消息正确取出和执行，AMQP模块包含了消息确认的概念，在收到消费者的确认回执前，消息代理不会将消息从队列中删除。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机拿到消息后，将路由给队列，使用哪种路由算法是由交换机类型和被称作“绑定（queue_bind）”的规则决定的。</p><p>可配置的队列如下：</p><ol><li>直连交换机（direct exchange）</li></ol><p>根据消息携带的<code>路由键(routing key)</code>将消息投递给对应的队列。将一个队列绑定到某个交换机的同时赋予该绑定一个路由键，当一个携带者路由键为XXX的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为XXX的队列。直连交换机用来处理消息的单播路由。</p><ol start="2"><li>主题交换机（topic exchange）</li></ol><p>通过对消息的<code>路由键</code>和队列到交换机的<code>绑定模式</code>之间的匹配，将消息路由给一个或多个队列。主题交换机通常用来实现消息的<code>多播路由</code>。发送到主题交换机的消息的路由键，必须是一个由 “.” 分隔的词语列表，这些词语应该和对应的业务关联，词语的个数可以随意，但是不要超过255字节。绑定键支持通配符：“*” 用来表示一个单词；“#” 用来表示任意数量(零个或多个)单词。</p><ol start="3"><li>扇形交换机（fanout exchange）</li></ol><p>将消息路由给绑定到它身上的所有队列，且不理会绑定的路由键。用来做消息的<code>广播路由</code>。它允许你对单条消息做不同的处理，在开发中一个操作可能要多个连带工作，比如用户创建一篇新的日记，需要更新用户的创建日记数，清除相关缓存，给关注这个用户的其他用户推消息，日记进审核后台，日记进最新日记池等等。可以使用扇形交换机把一个消息分发给多个任务队列，执行不一样的工作。尤其是业务改变时，使用扇形交换机<code>直接为新的消费者添加声明</code>，并绑定进来就可以了，否则需要修改发送方的代码来添加接收方。所以，使用扇形交换机可以有效地<code>解耦</code>发送者和消费者。</p><ol start="4"><li>头交换机（headers exchange）</li></ol><p>允许匹配AMQP的头而非路由键，其实使用起来和直接交换机差不多，但是性能却差很多，一般用不到这种类型。</p><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>通过创建新的虚拟主机，实现隔离，不同的虚拟主机直接完全隔离，拥有自己的队列，绑定和交换机。就像创建了一个新用户，服务A做订单的，链接对应的虚拟主机，服务B做消息推送的，链接对应的虚拟主机。默认是虚拟主机是 <code>/</code>，使用guest做默认用户和密码，通过命令创建新的虚拟主机：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user dongwm 123456</span><br><span class="line">sudo rabbitmqctl add_vhost web_develop</span><br><span class="line">sudo rabbitmqctl set_permissions -p web_develop dongwm <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure><p><code>rabbitmqctl set_permissions</code> 是配置权限，三个对应的权限是：配置（队列和交换的创建和删除）、写（发布消息）、读（消费消息）的权限。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>sudo rabbitmqctl list_vhosts</li><li>sudo rabbitmqctl list_queue -p web_develop</li><li>sudo rabbitmqctl list_users</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>http-protocol</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/http-protocol/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/http-protocol/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><a id="more"></a><h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。</p><h2 id="http-action"><a href="#http-action" class="headerlink" title="http action"></a>http action</h2><p>HTTP协议中GET、POST和HEAD的介绍  2008-05-10 14:15 </p><table><thead><tr><th>Name</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>GET</td><td style="text-align:center">请求指定的页面信息，并返回实体主体。 </td></tr><tr><td>HEAD</td><td style="text-align:center">只请求页面的首部。 </td></tr><tr><td>POST</td><td style="text-align:center">请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。 </td></tr><tr><td>PUT</td><td style="text-align:center">从客户端向服务器传送的数据取代指定的文档的内容。 </td></tr><tr><td>DELETE</td><td style="text-align:center">请求服务器删除指定的页面。 </td></tr><tr><td>OPTIONS</td><td style="text-align:center">允许客户端查看服务器的性能。 </td></tr><tr><td>TRACE</td><td style="text-align:center">请求服务器在响应中的实体主体部分返回所得到的内容。 </td></tr><tr><td>PATCH</td><td style="text-align:center">实体中包含一个表，表中说明与该URI所表示的原内容的区别。 </td></tr><tr><td>MOVE</td><td style="text-align:center">请求服务器将指定的页面移至另一个网络地址。 </td></tr><tr><td>COPY</td><td style="text-align:center">请求服务器将指定的页面拷贝至另一个网络地址。 </td></tr><tr><td>LINK</td><td style="text-align:center">请求服务器建立链接关系。 </td></tr><tr><td>UNLINK</td><td style="text-align:center">断开链接关系。 </td></tr><tr><td>WRAPPED</td><td style="text-align:center">允许客户端发送经过封装的请求。 </td></tr><tr><td>Extension-mothed</td><td style="text-align:center">在不改动协议的前提下，可增加另外的方法。 </td></tr></tbody></table><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p>三次握手：A向B发起连接，B收到，回一个给A，A也收到，连接确定</p><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><p>完成三次握手，客户端与服务器开始传送数据。</p><p>建立连接是三次握手，释放连接是四次挥手（关闭连接）</p><ol><li>第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。</li><li>第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。</li><li>第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。</li><li>第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><table><thead><tr><th>Name</th><th style="text-align:center">Description                     </th></tr></thead><tbody><tr><td>2xx</td><td style="text-align:center">成功 </td></tr><tr><td>3xx</td><td style="text-align:center">重定向 </td></tr><tr><td>4xx</td><td style="text-align:center">客户端问题</td></tr><tr><td>5xx</td><td style="text-align:center">服务端问题</td></tr></tbody></table><h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get 和 post"></a>get 和 post</h2><ol><li>get是从服务器上获取数据，post是向服务器传送数据。</li><li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li><li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li><li>get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li><li>get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 </li></ol><p>建议：<br>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；<br>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="http" scheme="http://www.liuzhidream.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>web相关</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/other/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/other/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>web相关学习笔记</p><a id="more"></a><h1 id="web相关"><a href="#web相关" class="headerlink" title="web相关"></a>web相关</h1><p>web相关学习笔记</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网关和路由器最大的区别是是否连接相似的网络。如果连接相似的网络，则称为路由器。而连接不相似的网络，称为网关。（个人认为这个关字可以从海关上来理解，出关，海关）</p><p>相似的网络和不相似的网络有两种不同的含义。</p><p>逻辑层面：</p><p>相似的网络：如果都是互联网上的两个网络，我们称为相似的网络。不相似的网络：如果一个是私网，一个是公网。我们称为不相似的网络。</p><p>物理层面：</p><p>相似的网络：都是以太网或者同一种介质的网络。<br>不相似的网络：一边是以太，一边是SDH或者ATM等</p><p>子网（Sub-net）出口路由器就叫网关了，后面还有很多中继路由器。所以网关一定是路由器，但路由器不一定用来做网关</p><p><code>TTL  Time to live</code> 域名解析在DNS服务器中存留时间        </p><p>实际指转发的最大跳数，主机发送ip包的时候，在网络中转发，转发一次该值减1，为了防止无限转发和循环而设置这个值。如果变成1还没到目标地址，即为超时。</p><p>内网映射</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;web相关学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/Vue/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/Vue/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。</p><a id="more"></a><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a href="https://www.jianshu.com/p/dc5057e7ad0d" target="_blank" rel="noopener">一个不错的“简书”入门</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/my-notebook/images/JavaScript/vue-1.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><ul><li><p>在通过ajax获取到数据需要赋值到data里面的时候，如果是不可变变量，可以直接赋值，但是如果是arrey，需要迭代每个值，加到data中。<code>Ajax.data.forEach(function(val, index){  vue.data.push(val) })</code>。</p></li><li><p>vue:在html中传递 this  ，在vue中this都是指向vue的组件，如果我们想使用原本的this指向这个dom,需要这样使用<code>dofunc($event)</code>。在函数里面 <code>dofunc(v){ v.target }</code>。如果转换为 jQuery 对象 <code>$(v.target)</code>  </p></li><li><p>vue:由于dom是由js去渲染的，所以你在渲染的时候去操作dom，是选不到的。这里涉及到了vue的生命周期的问题，实例创建完毕(挂载)，再去渲染dom。</p></li><li><p>vue:template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元，可以使html结构更加清晰，还可以改善一个标签过长的情况。</p></li><li><p>注册指令：全局注册，在new vue同块写Vue.directive局部注册，当前组件使用，作为vue实例的一个属性  directives  多了个 S<br>注册组件也是如此，和指令类似</p></li><li><p>在vue实例中的选择基本都是可以在组件里面使用的（vue实例怎么写组件就怎么写），但是data必须是函数，如果是一般的对象，你在组件里面使用这个对象会报错</p></li><li><p>单页面的VUE实例只有一个，组件化开了，要想从实例拿到data，只能是组件props向下传递，记得绑定想要的数据在你的模板上。向上使用events</p></li><li><p>props  data  是驼峰命名，绑定数据的写法 <code>&lt;child :msg-a=&quot;msgA&quot;&gt;&lt;/child&gt;  v-bind=&quot; a &quot;</code> 使用绑定，外部的引号不是想表达这个是个字符串，它应该当成一个变量，这也是在绑定url的时候，我们可以使用变量加上字符串，其中的字符串就用单引号。</p></li><li><p>props: 单项流数据，从父组件流向子组件，子组件试图修改它会报错，如果你要用它，应该把这个值给data，定义局部变量的方法。如果data是可变类型的，在子组件中修改了是会影响到父组件的。</p></li><li><p>props:验证，可以验证流进来的数据。验证在这个组件实例创建之前，所以你不能把这个组件里面的 option 诸如 data methods用在验证里面。</p></li><li><p>插槽：组件嵌套的时候使用，定义了如何进行内容分发</p></li><li><p>组件实例的作用域是孤立的</p></li><li><p>vue:自定义组件命名不要命名常见的（怕和框架冲突）</p></li><li><p>给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）。等同于在自组件中：子组件内部处理click事件然后向外发送click事件：<code>$emit(&quot;click&quot;.fn)</code></p></li></ul><h2 id="字符串模板和非字符串模板"><a href="#字符串模板和非字符串模板" class="headerlink" title="字符串模板和非字符串模板"></a>字符串模板和非字符串模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"component1"</span> <span class="attr">type</span>=<span class="string">"x-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实例中option使用 template 会把挂载元素的内容替换掉，在组件中 option 使用 template是HTML元素扩展被替换的内容，很像，都是替换。  </p><p>实例的模板字符串，执行元素的时候，此时元素应该是template标签或者 <code>script type=x-template</code> 都是把这两个的内容替换到实例挂载的元素上。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>vue指令类似 v-model 可以自定义指令，在创建实例的时候声明即可</p><p>目前的vue架构，对于一个vue文件来说，在里面使用其它组件（就是引用的各种组件），那么这些组件对于当前vue文件来说就是子组件，当前vue文件是父组件。这在理解一些概念的时候会有用，比如子组件 <code>双向绑定值</code> 使用 <code>sync</code> 来修饰，把子组件的某个属性绑定到父组件上，做到双向绑定。</p><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>v-bind</td><td style="text-align:center">动态绑定数据。简写为“:” =&gt; 以后的:class=”{red:boolean}” </td></tr><tr><td>v-on</td><td style="text-align:center">绑定时间监听器。简写为“@”，例：@click=”xxx”</td></tr><tr><td>v-text</td><td style="text-align:center">更新数据，会覆盖已有结构。类似 <code>{ {msg} }</code></td></tr><tr><td>v-show</td><td style="text-align:center">根据值的真假，切换元素的display属性</td></tr><tr><td>v-if</td><td style="text-align:center">根据值的真假，切换元素会被销毁、重建；=&gt; 在dom中已消失 </td></tr><tr><td>v-else-if</td><td style="text-align:center">多条件判断，为真则渲染</td></tr><tr><td>v-else</td><td style="text-align:center">条件都不符合时渲染</td></tr><tr><td>v-for</td><td style="text-align:center">基于源数据多次渲染元素或模块</td></tr><tr><td>v-model</td><td style="text-align:center">在表单控件元素（input等）上创建双向数据绑定（数据源）</td></tr><tr><td>v-pre</td><td style="text-align:center">跳过元素和子元素的编译过程</td></tr><tr><td>v-once</td><td style="text-align:center">只渲染一次，随后数据更新也不重新渲染</td></tr><tr><td>v-cloak</td><td style="text-align:center">隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;} </td></tr></tbody></table><h2 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>vue cli</td><td style="text-align:center">主要功能就是创建vue工程 </td></tr><tr><td>vue init webpack myproject</td><td style="text-align:center">构建vue项目 </td></tr></tbody></table><h2 id="ref-和-refs"><a href="#ref-和-refs" class="headerlink" title="ref 和 $refs"></a>ref 和 $refs</h2><p>ref 这个通常在元素上使用（组件自定义的元素也可以），比如现在有个组件 </p><ul><li><code>&lt;my-component&gt;&lt;/my-component&gt;</code></li><li>使用ref <code>&lt;my-component ref=&#39;new-name&#39; attr-a=&#39;hello&#39;&gt;&lt;/my-component&gt;</code></li><li>在 js  中 <code>this.$refs[&#39;new-name&#39;].attr  // res hello</code> 就可以通过别名获取到元素，并且拿到元素对应的属性。</li></ul><p>补充：</p><p>利用ref属性可以获取到dom元素或者是子组件，从而可以调用子组件的方法（注意2.0版本用ref取代了el）</p><ol><li>当ref直接定义在dom元素上时，则通过this.$refs.name可以获取到dom对dom进行原生的操作</li></ol><ul><li><code>&lt;div class=&quot;foods-wrapper&quot; ref=&quot;foods-wrapper&quot;&gt;</code></li><li>通过 <code>this.$refs</code> 获取到dom进行操作（注意ref属性的命名不能用驼峰，同时获取的时候也是）</li><li><code>let menuList=this.$refs[&#39;menu-wrapper&#39;].getElementsByClassName(&#39;menu-list-hook&#39;);</code> 此处如果用 <code>this.$refs[&quot;menuWrapper&quot;]</code> 将获取不到元素</li></ul><ol start="2"><li>通过在引用的子组件上使用ref属性实现父组件调用子组件的方法以及属性</li></ol><ul><li>在父组件中引用子组件并定义ref</li><li><code>&lt;v-food  ref=&quot;selectfood&quot;&gt;&lt;/v-food&gt;</code></li><li>调用定义在子组件中的方法show</li><li><code>this.$refs.selectfood.show();</code> 同时也可以调用子组件中的属性</li></ul><p>声明下上面说的是vue 2.0的</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>template是html5的一个新元素，主要用于保存客户端中的内容，表现为浏览器解析该内容但不渲染出来，可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。</p><h2 id="slot-插槽模板和非插槽模板"><a href="#slot-插槽模板和非插槽模板" class="headerlink" title="slot 插槽模板和非插槽模板"></a>slot 插槽模板和非插槽模板</h2><p>非插槽模板指的是html模板，比如 <code>div、span、ul、table</code> 这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制。</p><p>插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置确由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p><p>一般的用法就是在子组件里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 子组件名称：&lt;children&gt; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;solt&gt;<span class="xml"><span class="tag">&lt;/<span class="name">solt</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 父组件是这样的 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;children&gt;</span><br><span class="line">        &lt;span&gt;被插入的内容，这整个span便签都会替换子组件中的solt&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;children/</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure><p>这就是匿名插槽或叫做具名插槽，就是 <code>&lt;span solt=&#39;name&#39;&gt; &lt;/span&gt;</code> 在父组件上为要插入的内容取个名字，子组件<code>&lt;solt name=&#39;name&#39;&gt;&lt;/solt&gt;</code> 这样来和父组件对应起来。</p><p>作用域插槽：这个概念比较难理解，先看怎么用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 父组件： --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"father"</span>&gt;</span><br><span class="line">    &lt;h3&gt;这里是父组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!--第一次使用：用flex展示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div class="tmpl"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span v-for="item in user.data"&gt;&#123; &#123;item&#125; &#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第二次使用：用列表展示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li v-for="item in user.data"&gt;&#123; &#123;item&#125; &#125;&lt;/</span>li&gt;</span><br><span class="line">            &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第三次使用：直接显示数据--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">        &lt;template slot-scope="user"&gt;</span></span><br><span class="line"><span class="regexp">        &#123; &#123;user.data&#125; &#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>template&gt;</span><br><span class="line">    &lt;<span class="regexp">/child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;</span></span><br><span class="line"><span class="regexp">    &lt;child&gt;</span></span><br><span class="line"><span class="regexp">    我就是模板</span></span><br><span class="line"><span class="regexp">    &lt;/</span>child&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件： --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"child"</span>&gt;</span><br><span class="line">        &lt;h3&gt;这里是子组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 作用域插槽</span></span><br><span class="line"><span class="regexp">        &lt;slot :data="data"&gt;&lt;/</span>slot&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data: [<span class="string">'zhangsan'</span>,<span class="string">'lisi'</span>,<span class="string">'wanwu'</span>,<span class="string">'zhaoliu'</span>,<span class="string">'tianqi'</span>,<span class="string">'xiaoba'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，子组件写法是 <code>&lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt;</code> 把数据绑定给data属性，而且数据的来源是子组件，这点就很重要了。 在父组件会这么写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; &#123;scope.row.id&#125; &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时通过scope就可以拿到子组件绑定的data了，这个scope可以随便写。</p><p>在什么时候会用到呢？由于做研发比较少，但是用框架的时候你就要知道这种写法，通常会对子组件绑定父组件的数据，子组件拿到父组件的时候后，做了处理，得到自己的 data 就是上面插槽绑定的 data 这个时候你就可以去这个里面拿一些你像要的数据了。</p><p>像element UI 的table组件，通过给组件list数据，在 el-table-column 组件里面用作用域插槽就可以拿到赋值给list也就是表格的数据。</p><h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick"></a>this.$nextTick</h2><p>在vue中，当页面加载完成以后，dom还没有加载，是无法获取进行操作的，但是在vue2.0中提供了一个方法 <code>this.$nextTick</code>，在这个回调函数里面写dom操作即可，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do somthing</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实这里还有一个小技巧，就是用settimeout(fn,20),来取代this.$nextTick,（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。</p><p>现在vue都快要到3.o了，不要使用settimeout了，在使用 <code>this.$nextTick</code> 如果失败了，很可能是生命周期相关问题没处理好。</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>当我们需要跳转一个页面的时候，既然是单页面应用，可以使用路由会很方便，比如带很多的参数过去。如果是普通的url跳转只能在url里面带参数，限制较大</p><p>比如我们的跳转由方法来处理 <code>@click=&quot;getDescribe(article.id)&quot;</code></p><p>方法内容(三种情况)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">1.</span>基本使用 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path: <span class="string">`/describe/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 路由配置 --&gt;</span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/describe/:id'</span>,</span><br><span class="line">    name: <span class="string">'Describe'</span>,</span><br><span class="line">    component: Describe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">2.</span>通过路由配置的name来匹配 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    name: <span class="string">'Describe'</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">    id: id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 情况<span class="number">3.</span>通过path来匹配 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path: <span class="string">'/describe'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">    id: id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方案2要优雅的多，可以在params中传递参数，这里的id用来做路由传参了。 </p><p>在子组件中通过 <code>$route.params</code> 获取到参数。方案3为 <code>$route.query</code> 就是获取 <code>$route</code> 对象的属性了。</p><p>运用：通过方法查询接口，返回数据由路由来响应，把参数都传给子组件，子组件通过在created生命周期中 <code>this.$route</code> 获取传递给子组件的参数。</p><h2 id="v-html-与-深度作用选择器"><a href="#v-html-与-深度作用选择器" class="headerlink" title="v-html 与 深度作用选择器"></a>v-html 与 深度作用选择器</h2><p>vue 使用v-html指令渲染的页面样式处理问题</p><p>由于是动态加载的页面，在style中写的class不会作用于v-html渲染的内容，作者给出的解决方案是给外层容器加个类名, 然后用后代选择器，css的选择器可以是类选到类 <code>.classA .classB</code>， 选择元素的 <code>.classA a</code> (选择a标签)</p><p><code>.classA &gt; a</code> 只对一代a标签作用。直接这样写还不行，需要深度作用选择器 <code>.classA &gt;&gt;&gt; a</code>。 有些像 <code>Sass</code> 之类的预处理器无法正确解析 <code>&gt;&gt;&gt;</code>。这种情况下你可以使用 <code>/deep/</code> 操作符取而代之——这是一个 <code>&gt;&gt;&gt;</code> 的别名，同样可以正常工作。</p><p>总结：在使用指令的便签上加个类，用这个类选择后代（注意要用深度作用选择器）这样就可以解决问题了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'myclass'</span> <span class="attr">v-html</span>=<span class="string">'content'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .myclass /deep/ a&#123;</span></span><br><span class="line"><span class="undefined">    font-size: 10px</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者在被渲染的Html里面加style（没有测试过，感觉是可行的）</p><h2 id="子组件向父组件传递事件"><a href="#子组件向父组件传递事件" class="headerlink" title="子组件向父组件传递事件"></a>子组件向父组件传递事件</h2><p>子组件向父组件传递事件，通常用来实现子组件向父组件传递值，然后调用父组件的方法</p><ul><li>在子组件中对某个标签绑定点击事件 <code>v-on:click=&quot;$emit(&#39;click_event&#39;, data.guid)&quot;</code></li><li>这样在父组件中我们可以监听这个事件，<code>&lt;article-classify v-on:click_event=&quot;classifyHandler&quot;&gt;&lt;/article-classify&gt;</code> 方法 <code>classifyHandler</code> 会接受传递的参数，也就是 <code>data.guid</code>，这样我们就拿到子组件传递来的参数了，然后后面的逻辑也就可以去跟着执行方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
      <category term="framework" scheme="http://www.liuzhidream.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://www.liuzhidream.com/2018/10/22/JavaScript/javascript/"/>
    <id>http://www.liuzhidream.com/2018/10/22/JavaScript/javascript/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript学习笔记</p><a id="more"></a><h1 id="JavaScript-笔记"><a href="#JavaScript-笔记" class="headerlink" title="JavaScript 笔记"></a>JavaScript 笔记</h1><p>javascript学习笔记</p><h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><p>DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;<br>复制代码 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domObj = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>); <span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(<span class="string">"#id"</span>); <span class="comment">//jQuery对象;</span></span><br></pre></td></tr></table></figure><p>jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例:</p><p>$(“#foo”).html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法;</p><p>上面的那段代码等同于:</p><p>document.getElementById(“foo”).innerHTML;<br>$(“#foo”).innerHTML  是错误的</p><p>可以将jquery 和 dom  对象互相转换，这样dom对象就可以使用jquery的方法了，jquery对象亦如此。</p><h2 id="Json-方法"><a href="#Json-方法" class="headerlink" title="Json 方法"></a>Json 方法</h2><p>JSON.stringify(a) stringify()用于从一个对象解析出字符串</p><p>JSON.parse(str)  parse用于从一个字符串中解析出json对象</p><h2 id="取得url中get请求的参数"><a href="#取得url中get请求的参数" class="headerlink" title="取得url中get请求的参数"></a>取得url中get请求的参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line"><span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);  </span><br><span class="line"><span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">decodeURI</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ready-和-onload事件"><a href="#ready-和-onload事件" class="headerlink" title="ready 和 onload事件"></a>ready 和 onload事件</h2><p>页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！) 一般样式控制的，比如图片大小控制放在onload 里面加载。 </p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>JavaScript 关键字必须以字母、下划线（_）或美元符（$）开始。</p><p>后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开关键字和数字）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/JavaScript/keyword.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="BOM-amp-DOM"><a href="#BOM-amp-DOM" class="headerlink" title="BOM &amp; DOM"></a>BOM &amp; DOM</h2><ul><li>BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。</li><li>DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。</li><li>BOM的内容不多，主要还是DOM。</li></ul><h2 id="字面量，变量"><a href="#字面量，变量" class="headerlink" title="字面量，变量"></a>字面量，变量</h2><p>有时候会遇到字面量的概念，它和变量对应，字面量就是固定值的表示法。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>js也有异常，不过很少见人使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//错误判断</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x == <span class="string">""</span>) <span class="keyword">throw</span> <span class="string">"值为空"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">"不是数字"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x &gt; <span class="number">10</span>) <span class="keyword">throw</span> <span class="string">"太大"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (x &lt; <span class="number">5</span>) <span class="keyword">throw</span> <span class="string">"太小"</span>;</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">catch</span> (err) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">//发生错误时在此执行，err为自定义错误 throw 对应的值，</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> y = <span class="built_in">document</span>.getElementById(<span class="string">"mess"</span>);</span></span><br><span class="line"><span class="javascript">y.innerHTML = <span class="string">"错误："</span> + err + <span class="string">"。"</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个 JavaScript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请输出一个 5 到 10 之间的数字:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"demo"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"myFunction()"</span>&gt;</span>测试输入<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"mess"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的定义方式大体有以下两种，浏览器对于不同的方式有不同的解析顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“定义式”函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//“赋值式”函数定义</span></span><br><span class="line"><span class="keyword">var</span> Fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello wild!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速测试一段代码的执行时间"><a href="#快速测试一段代码的执行时间" class="headerlink" title="快速测试一段代码的执行时间"></a>快速测试一段代码的执行时间</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment">/* 这里运行待测代码 */</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><h2 id="对象总结"><a href="#对象总结" class="headerlink" title="对象总结"></a>对象总结</h2><p>对象</p><ol><li>javascript 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JS Array     JS Boolean   JS Date  </span><br><span class="line">JS Number    JS String    JS RegExp </span><br><span class="line">JS Functions JS Events    JS Math</span><br></pre></td></tr></table></figure><p>其它对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Browser  Window  Navigator </span><br><span class="line">Screen   History Location</span><br></pre></td></tr></table></figure><p>Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。</p><ol start="2"><li>HTML DOM 对象</li></ol><ul><li>每个载入浏览器的 HTML 文档都会成为 Document 对象。</li><li>Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</li></ul><p>Element 节点，文本节点，元素节点等。</p><p>Attribute 属性； Event 事件； HTML 对象；</p><p>标签即是HTML对象，标签和元素的区别，属性的定义：</p><pre><code>比如&lt;p&gt;这就是一个标签； &lt;p&gt;这里是内容&lt;/p&gt;这就是一个元素，也就是说元素由一个开始的标签和结束的标签组成，用来包含某些内容。</code></pre><p>属性：</p><p>为HTML元素提供各种附加信息的就是HTML属性，它总是以”属性名=属性值”这种名值对的形式出现，而且属性总是在HTML元素的开始标签中进行定义。</p><p>节点的作用：</p><p>在有了标签，元素，属性后，引申出节点的概念，标签的元素中可能会有更多的元素，将多个或一个元素看作节点，节点就是为了去操作元素的。</p><h2 id="virtual-DOM"><a href="#virtual-DOM" class="headerlink" title="virtual DOM"></a>virtual DOM</h2><p>一些理解：</p><p>虚拟DOM，是一个模拟DOM数的js对象。 就是当我们需要更改DOM的时候，如果用原始方法比较慢，这在多节点的页面中体现就更明显了，原因是dom设计的复杂，所以我们用一个虚拟的DOM，虚拟的DOM记录了要更改的DOM，它通常不是立刻执行的，等到需要的时候，计算最小的执行，把执行更新到DOM上。这里为什么会有最小的DOM执行，是应为不是所有的地方都需要变更。</p><p>总结：virtual DOM 通过计算最小的DOM执行，能更快的渲染DOM。</p><p>别人的讲解：</p><ul><li>Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。</li><li>React 主要的目标是提供一套不同的, 高效的方案来更新 DOM.不是通过直接把 DOM 变成可变的数据, 而是通过构建 “Virtual DOM”, 虚拟的 DOM, 随后 React 处- 理真实的 DOM 上的更新来进行模拟相应的更新。</li></ul><p>引入额外的一个层怎么就更快了呢?</p><ul><li>那不是意味着浏览器的 DOM 操作不是最优的, 如果在上边加上一层能让整体变快的话?是有这个意思, 只不过 virtual DOM 在语义上和真实的 DOM 有所差别.最主要的是, virtual DOM 的操作, 不保证马上就会产生真实的效果.这样就使得 React 能够等到事件循环的结尾, 而在之前完全不用操作真实的 DOM。在这基础上, React 计算出几乎最小的 diff, 以最小的步骤将 diff 作用到真实的 DOM 上。批量处理 DOM 操作和作用最少的 diff 是应用自身都能做到的.任何应用做了这个, 都能变得跟 React 一样地高效。但人工处理出来非常繁琐, 而且容易出错. React 可以替你做到。</li><li>前面提到 virtual DOM 和真实的 DOM 有着不用的语义, 但同时也有明显不同的 API。</li><li>DOM 树上的节点被称为元素, 而 virtual DOM 是完全不同的抽象, 叫做 components。</li><li>component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。</li></ul><p>简单的说就是：</p><p>当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p><p>React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 </p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>数组过滤。indexOf作用是返回字符串第一次出现在给定字符串的index，可以用来处理某个字符串有没有在给定字符串中。  给定 <code>str.indexOf(某个字符串) = 0</code> 说明第一个就匹配到，这个给定字符串。如果是空格分隔的，如几个单词，那么结果就不一定是0了，因为会在后面的位置。记住是给定来调用这个方法就行了</p><p>补充：</p><p>js array indexOf 参数是对象的时候，不一定能返回对应位置的index(有的时候可以，我查了资料，有人是这么说的：让数组去判断<code>一个新创建的对象</code>，所以会得到 -1。我在vue中，把循环出来的元素做为参数去在原数组中判断，是可以的，不是循环出来的对象，虽然对象和数组元素字面看起来一摸一样，但是不行，猜测这和底层有关) 所以这个东西的使用，要很小心<br>推荐使用 <code>Array.findIndex()</code></p><p>findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstLargeNumber</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> element &gt; <span class="number">13</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.findIndex(findFirstLargeNumber));</span><br><span class="line"><span class="comment">// expected output: 3</span></span><br></pre></td></tr></table></figure><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> found = array1.find(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> element &gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure><p>通过find，findIndex可以完成很多的事情，少用通过各种方法获取索引，然后再去 <code>array[index]</code>。find就可以了</p><p>更详细的使用查看文档。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find" target="_blank" rel="noopener">文档地址</a></p><p>我发现这个从列表中给出来的数据，你不段的引用，其中一个引用改了，也会影响到原数组。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`a<span class="subst">$&#123;<span class="keyword">var</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>如果var是1，result 为 a1。注意两边的符号为tab键上面的</p><h2 id="bject-keys-obj"><a href="#bject-keys-obj" class="headerlink" title="bject.keys(obj)"></a>bject.keys(obj)</h2><p>返回值: 一个表示给定对象的所有可枚举属性的字符串数组</p><ol><li><p>传入字符串，返回索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: ['0', '1', '2']</span></span><br></pre></td></tr></table></figure></li><li><p>传入对象，返回属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="string">'alive'</span>, <span class="attr">b</span>: <span class="string">'bike'</span>, <span class="attr">c</span>: <span class="string">'color'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p>只对字符串和数组有用，整形数字和对象返回未定义undefined</p><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>数组调用，监测数组是否包含给定的元素 <code>array.include(0)</code> 返回boolean</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>箭头函数与普通函数中的this指向不一样，前者基于定义时的上下文环境，后者则只是基于调用者。</p><h2 id="typeof-cb-“function”-amp-amp-cb"><a href="#typeof-cb-“function”-amp-amp-cb" class="headerlink" title="typeof cb == “function” &amp;&amp; cb()"></a>typeof cb == “function” &amp;&amp; cb()</h2><p>强大的js总有一些没见过的用法</p><p><code>function delay(time, cb) { typeof cb == &quot;function&quot; &amp;&amp; cb(time) }</code></p><p><code>cb&amp;&amp;cb(value)</code> 的意思是：</p><ul><li>如果cb为真（有值），那么执行cb(value)；</li><li>如果cb为假，&amp;&amp;短路，那么不执行cb(value)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/categories/javascript/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="javascript" scheme="http://www.liuzhidream.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ssl-credential</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/ssl-credential/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/ssl-credential/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的</p><a id="more"></a><h1 id="https-ssl-证书"><a href="#https-ssl-证书" class="headerlink" title="https ssl 证书"></a>https ssl 证书</h1><p>使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的。以下内容截取自网络。</p><p>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。</p><p>创建自签名证书的步骤<br>注意：以下步骤仅用于配置内部使用或测试需要的SSL证书。<br>第1步：生成私钥使用openssl工具生成一个RSA私钥<br>$ openssl genrsa -des3 -out server.key 2048<br>说明：生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。<br>注意：生成私钥，需要提供一个至少4位的密码。<br>第2步：生成CSR（证书签名请求）生成私钥之后，便可以创建csr文件了。<br>此时可以有两种选择。理想情况下，可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书（很贵）。另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名，具体操作如下：</p><p>$ openssl req -new -key server.key -out server.csr<br>说明：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。</p><p>Country Name (2 letter code) [AU]:CN<br>State or Province Name (full name) [Some-State]:Beijing<br>Locality Name (eg, city) []:Beijing<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:joyios<br>Organizational Unit Name (eg, section) []:info technology<br>Common Name (e.g. server FQDN or YOUR name) []:demo.joyios.com<br>Email Address []:<a href="mailto:liufan@joyios.com" target="_blank" rel="noopener">liufan@joyios.com</a></p><p>第3步：删除私钥中的密码在第1步创建私钥的过程中，由于必须要指定一个密码。而这个密码会带来一个副作用，那就是在每次Apache启动Web服务器时，都会要求输入密码，这显然非常不方便。要删除私钥中的密码，操作如下：</p><p>cp server.key server.key.org<br>openssl rsa -in server.key.org -out server.key</p><p>第4步：生成自签名证书如果你不想花钱让CA签名，或者只是测试SSL的具体实现。那么，现在便可以着手生成一个自签名的证书了。</p><p>$ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt<br>说明：crt上有证书持有人的信息，持有人的公钥，以及签署者的签名等信息。当用户安装了证书之后，便意味着信任了这份证书，同时拥有了其中的公钥。证书上会说明用途，例如服务器认证，客户端认证，或者签署其他证书。当系统收到一份新的证书的时候，证书会说明，是由谁签署的。如果这个签署者确实可以签署其他证书，并且收到证书上的签名和签署者的公钥可以对上的时候，系统就自动信任新的证书。<br>第5步：安装私钥和证书将私钥和证书文件复制到Apache的配置目录下即可，在Mac 10.10系统中，复制到/etc/apache2/目录中即可。<br>需要注意的是，在使用自签名证书时，浏览器会提示证书不受信任，如果你是对外网站使用，建议还是去CA机构申请可信的SSL证书，现在证书也很便宜，沃通CA超快SSL Pre才488元/年。</p><p>一般情况下，如果能找到可用的证书，就可以直接使用，只不过会因证书的某些信息不正确或与部署证书的主机不匹配而导致浏览器提示证书无效，但这并不影响使用。<br>需要手工生成证书的情况有：<br>找不到可用的证书<br>需要配置双向SSL，但缺少客户端证书<br>需要对证书作特别的定制<br>首先，无论是在Linux下还是在Windows下的Cygwin中，进行下面的操作前都须确认已安装OpenSSL软件包。</p><ol><li>创建根证书密钥文件(自己做CA)root.key：<br>openssl genrsa -des3 -out root.key<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out root.key<br>Generating RSA private key, 512 bit long modulus<br>……………..++++++++++++<br>..++++++++++++<br>e is 65537 (0×10001)<br>Enter pass phrase for root.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for root.key: ← 重新输入一遍密码</li><li>创建根证书的申请文件root.csr：<br>openssl req -new -key root.key -out root.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key root.key -out root.csr<br>Enter pass phrase for root.key: ← 输入前面创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市的全名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []: ← 此时不输入<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随意填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建一个自当前日期起为期十年的根证书root.crt：<br>openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./emailAddress=admin@mycompany.com</a><br>Getting Private key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建服务器证书密钥server.key：<br>openssl genrsa –des3 -out server.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -out server.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>….+++<br>…………………………………………..+++<br>e is 65537 (0×10001)<br>运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施!<br>去除key文件口令的命令:<br>openssl rsa -in server.key -out server.key<br>5.创建服务器证书的申请文件server.csr：<br>openssl req -new -key server.key -out server.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key server.key -out server.req<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不输入<br>Common Name (eg, YOUR name) []:<a href="http://www.mycompany.com" target="_blank" rel="noopener">www.mycompany.com</a> ← 服务器主机名，若填写不正确，浏览器会报告证书无效，但并不影响使用<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不输入<br>An optional company name []: ← 可以不输入</li><li>创建自当前日期起有效期为期两年的服务器证书server.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.csr -out server.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in server.csr -out server.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入前面创建的密码</li><li>创建客户端证书密钥文件client.key：<br>openssl genrsa -des3 -out client.key 2048<br>输出内容为：<br>[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048<br>Generating RSA private key, 2048 bit long modulus<br>……………………………………………………………………………..+++<br>……………………………………………………………………………………………………….+++<br>e is 65537 (0×10001)<br>Enter pass phrase for client.key: ← 输入一个新密码<br>Verifying – Enter pass phrase for client.key: ← 重新输入一遍密码</li><li>创建客户端证书的申请文件client.csr：<br>openssl req -new -key client.key -out client.csr<br>输出内容为：<br>[lenin@archer ~]$ openssl req -new -key client.key -out client.csr<br>Enter pass phrase for client.key: ← 输入上一步中创建的密码<br>You are about to be asked to enter information that will be incorporated<br>into your certificate request.<br>What you are about to enter is what is called a Distinguished Name or a DN.<br>There are quite a few fields but you can leave some blank<br>For some fields there will be a default value,<br>If you enter ‘.’, the field will be left blank.<br>—–<br>Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CN<br>State or Province Name (full name) [Some-State]:BeiJing ← 省名称，拼音<br>Locality Name (eg, city) []:BeiJing ← 市名称，拼音<br>Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名<br>Organizational Unit Name (eg, section) []: ← 可以不填<br>Common Name (eg, YOUR name) []:Lenin ← 自己的英文名，可以随便填<br>Email Address []:<a href="mailto:admin@mycompany.com" target="_blank" rel="noopener">admin@mycompany.com</a> ← 电子邮箱，可以随便填<br>Please enter the following ‘extra’ attributes<br>to be sent with your certificate request<br>A challenge password []: ← 可以不填<br>An optional company name []: ← 可以不填</li><li>创建一个自当前日期起有效期为两年的客户端证书client.crt：<br>openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.crt<br>输出内容为：<br>[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in client.csr -out client.crt<br>Signature ok<br>subject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany <a href="mailto:Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com" target="_blank" rel="noopener">Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.com</a><br>Getting CA Private Key<br>Enter pass phrase for root.key: ← 输入上面创建的密码</li><li>将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx：<br>openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>输出内容为：<br>[lenin@archer ~]$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx<br>Enter pass phrase for client.key: ← 输入上面创建的密码<br>Enter Export Password: ← 输入一个新的密码，用作客户端证书的保护密码，在客户端安装证书时需要输入此密码<br>Verifying – Enter Export Password: ← 确认密码</li><li>保存生成的文件备用，其中server.crt和server.key是配置单向SSL时需要使用的证书文件，client.crt是配置双向SSL时需要使用的证书文件，client.pfx是配置双向SSL时需要客户端安装的证书文件<br> .crt文件和.key可以合到一个文件里面，把2个文件合成了一个.pem文件（直接拷贝过去就行了）<br>参考：<a href="http://sinolog.it/?p=1460" target="_blank" rel="noopener">http://sinolog.it/?p=1460</a><br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br><a href="http://blog.sina.com.cn/s/blog_4fd50c390101891c.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4fd50c390101891c.html</a><br>x509证书一般会用到三类文，key，csr，crt。<br>Key是私用密钥openssl格，通常是rsa算法。<br>Csr是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。<br>crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。 </li></ol><p>1.key的生成<br>opensslgenrsa -des3 -out server.key 2048<br>这样是生成rsa私钥，des3算法，openssl格式，2048位强度。server.key是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。可以通过以下方法生成没有密码的key:<br>opensslrsa -in server.key -out server.key </p><p>server.key就是没有密码的版本了。 </p><p>2.生成CA的crt<br>opensslreq -new -x509 -key server.key -out ca.crt -days3650<br>生成的ca.crt文件是用来签署下面的server.csr文件。 </p><p>3.csr的生成方法<br>opensslreq -new -key server.key -outserver.csr<br>需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 </p><p>4.crt生成方法<br>CSR文件必须有CA的签名才可形成证书，可将此文件发送到verisign等地方由它验证，要交一大笔钱，何不自己做CA呢。<br>opensslx509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key-CAcreateserial -out server.crt<br>输入key的密钥后，完成证书生成。-CA选项指明用于被签名的csr证书，-CAkey选项指明用于签名的密钥，-CAserial指明序列号文件，而-CAcreateserial指明文件不存在时自动生成。<br>最后生成了私用密钥：server.key和自己认证的SSL证书：server.crt<br>证书合并：<br>catserver.key server.crt &gt; server.pem</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="http" scheme="http://www.liuzhidream.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Celery</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Web/Celery/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Web/Celery/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p><a id="more"></a><h1 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h1><p>Celery - Distributed Task Queue</p><p>要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过Python的包管理工具来安装，在我查到的一些资料中，celery和docker的配合不是很好，建议不要在单一容器中使用celery了。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>生产者(Celery client)。生产者(Celery client)发送消息。在Flask上工作时，生产者(Celery client)在Flask应用内运行。</li><li>消费者(Celery workers)。消费者用于处理后台任务。消费者(Celery client)可以是本地的也可以是远程的。我们可以在运行Flask的server上运行一个单一的消费者(Celery workers)，当业务量上涨之后再去添加更多消费者(Celery workers)。</li><li>消息传递者(message broker)。生产者(Celery client)和消费者(Celery workers)的信息的交互使用的是消息队列(message queue)。Celery支持若干方式的消息队列，其中最常用的是RabbitMQ和Redis.</li></ul><p>以上是最基本的架构，完整的组件还包括：</p><ol><li>Celery Beat：任务调度器</li><li>Celery Worker：执行任务的消费者</li><li>Broker：消息代理</li><li>Product：任务生产者（通过API，装饰器等产生任务并交个任务队列处理）</li><li>Result Backend：任务处理完成后，保存状态信息，以供查询</li></ol><p>1，4都是任务的生产者，只是方式不一样，1的方式是Beat进程读取配置文件，周期性的将到期的任务发给任务队列执行，就是定时任务。</p><h2 id="在flask中使用celery"><a href="#在flask中使用celery" class="headerlink" title="在flask中使用celery"></a>在flask中使用celery</h2><p>如何集成，并且很好的解耦模块是celery运用的关键。你总不能把代码都堆叠在一起吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>flask_celery不能支持celery4.0，所以弃用扩展模块，直接使用celery模块。使用扩展的好处是在扩展模块在一个文件初始化，并且全局保持一个实例对象，所以你的celery需要在app创建后才能创建，需要考虑是否使用了全局的celery对象</li><li>创建celery的实例对象的名字使用flask应用程序app的名字，通过 <code>app.name</code> 获取，如果你使用扩展插件，建议不要修改此名称，否则创建失败，不使用扩展插件也不建议修改</li><li>当有多个装饰器的时候，celery.task一定要在最外层</li></ul><p>init代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = create_app(CONFIG)</span><br><span class="line">celery = CeleryApp(app.name)</span><br><span class="line">celery.conf.update(app.config)</span><br></pre></td></tr></table></figure><p>首先创建Flask app的实例app，然后创建Celery的实例celery，这里需要传递一个名称，这个名称会作为celery task的前缀，例如 <code>flask_app.celery_app.task.long_task</code>，long_task是我们定义的任务，你要改创建实例的参数也可以，建议不要修改。这里的CeleryApp是自己编写的，继承Celery的一个类，目的是实现单实例，让其它模块通过CeleryApp创建的实例保持一样，然后调用celery.conf.update更新参数，<code>flask app.config</code> 是继承dict的Config类，这样就把需要的参数配置通过flask配置，作用于celery。</p><p>flask大多数的插件做的事情就是在单独的扩展文件中，先不传递参数实例化扩展，然后在创建app的时候初始化它，估计flask_celery也是做差不多的事情，不过实例化Celery必须要先传递参数，现在插件没有在更新了(有一些其他名称的扩展可以支持)，主要还是为了工程化。</p><p>这里记录一下扩展包的情况吧，在py3中，有：</p><p>Flask-Celery：这个其实不是扩展，而是装这个就把Celery相关的给安装了，这个是Celery的作者写的，他也说在4.0版本不再需要了，我也没看出来这个有什么用</p><p>Flask-Celery-Helper：这个就是扩展了，导入用flask_celery，不支持4.0</p><p>Flask-Celery-py3，Flask-Celery3：好像都是不支持4.0的</p><p>Flask-CeleryExt：在文档中写明可以支持4.0了，和大部分扩展使用方法一样，用懒加载的方式实例化</p><h3 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h3><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>pickle:</td><td style="text-align:center">二进制序列化方式；是标准库的一个模块，支持Python的内置数据结构，但是他是Python的专有协议，在celery3.2开始，出于安全考虑，不再采用此方案；</td></tr><tr><td>json:</td><td style="text-align:center">json支持多种语言，可用于跨语言方案，但好像不支持自定义的类对象； </td></tr><tr><td>XML:</td><td style="text-align:center">类似标签语言； </td></tr><tr><td>msgpack:</td><td style="text-align:center">二进制的类json序列化方案，但比json的数据结构更小，更快； </td></tr><tr><td>yaml:</td><td style="text-align:center">yaml表达能力更强，支持的数据类型较json多，但是python客户端的性能不如json; </td></tr></tbody></table><p>在自定义对象上，序列化方案我也出现过问题，pickle用了不行，可能就是不支持了，有待解决</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><code>celery = Celery(app.name)</code> 创建celery实例</li><li><code>celery.conf.update(app.config)</code> 更新配置</li><li>在需要后台运行的任务使用@celery.task</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello_world"</span></span><br></pre></td></tr></table></figure><p>需要注意的是，被装饰的任务需要调用才会加到任务队列，也就是通过hello_world.delay()调用，在官方的例子中，通过继承的方式，增加 <code>__call__</code> 方法，内部调用run，这样装饰器@celery.task()便会直接加入任务队列了，不过这样的功能应该是不需要的。</p><p>通过 <code>r = hello_world.delay()</code> 方法，返回的对象拥有以下方法：</p><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>r.ready()</td><td style="text-align:center">#查看任务状态，返回布尔值，任务执行完成，返回True，否则返回False. </td></tr><tr><td>r.wait()</td><td style="text-align:center">#等待任务完成,返回任务执行结果，很少使用； </td></tr><tr><td>r.get(timeout=1)</td><td style="text-align:center">#获取任务执行结果，可以设置等待时间 </td></tr><tr><td>r.result</td><td style="text-align:center">#任务执行结果. </td></tr><tr><td>r.state</td><td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td></tr><tr><td>r.status</td><td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td></tr><tr><td>r.successful</td><td style="text-align:center">#任务成功返回true </td></tr><tr><td>r.traceback</td><td style="text-align:center">#如果任务抛出了一个异常，你也可以获取原始的回溯信息</td></tr></tbody></table><h3 id="装饰器参数"><a href="#装饰器参数" class="headerlink" title="装饰器参数"></a>装饰器参数</h3><p><a href="mailto:`@celery.task" target="_blank" rel="noopener">`@celery.task</a>()`</p><ol><li><p>name：可以显示指定任务的名字；</p></li><li><p>serializer：指定序列化的方法；</p></li><li><p>bind：一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，具体属性可参照 <code>celery--app--task.py</code> 中的Task类，通过<code>self.request.__dict__</code>打印相关属性；</p></li><li><p>base：指定任务的基类，可以定义一个类，继承celery.Task，利用重写或扩展的类接口技术制定需求，例如on_success方法，默认是没有返回值的，就是提供这个钩子让开发者自定义的；</p></li></ol><h3 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h3><p>任务被装饰器装饰后，通过task.delay()，task.apply_async()把任务加入到队列中，send_task()，可以发送未被注册的异步任务，即没有被celery.task装饰的任务</p><h3 id="apply-async的参数"><a href="#apply-async的参数" class="headerlink" title="apply_async的参数"></a>apply_async的参数</h3><table><thead><tr><th>Command</th><th style="text-align:left">Description </th></tr></thead><tbody><tr><td>countdown</td><td style="text-align:left">设置该任务等待一段时间再执行，单位为s； </td></tr><tr><td>eta</td><td style="text-align:left">定义任务的开始时间；eta=time.time()+10; </td></tr><tr><td>expires</td><td style="text-align:left">设置任务时间，任务在过期时间后还没有执行则被丢弃； </td></tr><tr><td>retry</td><td style="text-align:left">如果任务失败后,是否重试;使用true或false，默认为true </td></tr><tr><td>shadow</td><td style="text-align:left">重新指定任务的名字str，覆盖其在日志中使用的任务名称； </td></tr><tr><td>retry_policy</td><td style="text-align:left">重试策略，为一个字典，各个键值配置：<code>max_retries</code>-最大重试次数，默认为 3 次. <code>interval_start</code>-重试等待的时间间隔秒数，默认为 0 ，表示直接重试不等待. <code>interval_step</code>-每次重试让重试间隔增加的秒数，可以是数字或浮点数，默认为 0.2. <code>interval_max</code>-重试间隔最大的秒数,即通过 interval_step 增大到多少秒之后，就不在增加了，可以是数字或者浮点数，默认为 0.2 .</td></tr><tr><td>routing_key</td><td style="text-align:left">自定义路由键； </td></tr><tr><td>queue</td><td style="text-align:left">指定发送到哪个队列； </td></tr><tr><td>exchang</td><td style="text-align:left">指定发送到哪个交换机； </td></tr><tr><td>priority</td><td style="text-align:left">任务队列的优先级，0-9之间； </td></tr><tr><td>serializer</td><td style="text-align:left">任务序列化方法；通常不设置； </td></tr><tr><td>compression</td><td style="text-align:left">压缩方案，通常有zlib,bzip2 </td></tr><tr><td>headers</td><td style="text-align:left">为任务添加额外的消息； </td></tr><tr><td>link</td><td style="text-align:left">任务成功执行后的回调方法；是一个signature对象；可以用作关联任务； </td></tr><tr><td>link_error</td><td style="text-align:left">任务失败后的回调方法，是一个signature对象；</td></tr></tbody></table><p>自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task.apply_async((<span class="number">2</span>,<span class="number">2</span>), </span><br><span class="line">    compression=<span class="string">'zlib'</span>,</span><br><span class="line">    serialize=<span class="string">'json'</span>,</span><br><span class="line">    queue=<span class="string">'priority.high'</span>,</span><br><span class="line">    routing_key=<span class="string">'web.add'</span>,</span><br><span class="line">    priority=<span class="number">0</span>,</span><br><span class="line">    exchange=<span class="string">'web_exchange'</span>)</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URL</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://username:passwd@host:port/虚拟主机名'</span></span><br><span class="line"><span class="comment"># 指定结果的接受地址</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://username:passwd@host:port/db'</span></span><br><span class="line"><span class="comment"># 指定任务序列化方式</span></span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'msgpack'</span> </span><br><span class="line"><span class="comment"># 指定结果序列化方式</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'msgpack'</span></span><br><span class="line"><span class="comment"># 任务过期时间,celery任务执行结果的超时时间</span></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">60</span> * <span class="number">20</span>   </span><br><span class="line"><span class="comment"># 指定任务接受的序列化类型.</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">"msgpack"</span>]   </span><br><span class="line"><span class="comment"># 任务发送完成是否需要确认，这一项对性能有一点影响     </span></span><br><span class="line">CELERY_ACKS_LATE = <span class="keyword">True</span>  </span><br><span class="line"><span class="comment"># 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据</span></span><br><span class="line">CELERY_MESSAGE_COMPRESSION = <span class="string">'zlib'</span> </span><br><span class="line"><span class="comment"># 规定完成任务的时间</span></span><br><span class="line">CELERYD_TASK_TIME_LIMIT = <span class="number">5</span>  <span class="comment"># 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程</span></span><br><span class="line"><span class="comment"># celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目</span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">4</span> </span><br><span class="line"><span class="comment"># celery worker 每次去rabbitmq预取任务的数量</span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">4</span> </span><br><span class="line"><span class="comment"># 每个worker执行了多少任务就会死掉，默认是无限的</span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">40</span> </span><br><span class="line"><span class="comment"># 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中</span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">"default"</span> </span><br><span class="line"><span class="comment"># 设置详细的队列</span></span><br><span class="line">CELERY_QUEUES = &#123;</span><br><span class="line">    <span class="string">"default"</span>: &#123; <span class="comment"># 这是上面指定的默认队列</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"direct"</span>,</span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"topicqueue"</span>: &#123; <span class="comment"># 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列</span></span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"topic.#"</span>,</span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"topic_exchange"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"topic"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"task_eeg"</span>: &#123; <span class="comment"># 设置扇形交换机</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"fanout"</span>,</span><br><span class="line">        <span class="string">"binding_key"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>celery worker -A auto_app.celery --loglevel=info</code> 启动Worker</p><h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><table><thead><tr><th>Command</th><th style="text-align:center">Description </th></tr></thead><tbody><tr><td>PENDING</td><td style="text-align:center">任务等待中 </td></tr><tr><td>STARTED</td><td style="text-align:center">任务已开始 </td></tr><tr><td>SUCCESS</td><td style="text-align:center">任务执行成功 </td></tr><tr><td>FAILURE</td><td style="text-align:center">任务执行失败 </td></tr><tr><td>RETRY</td><td style="text-align:center">任务将被重试 </td></tr><tr><td>REVOKED</td><td style="text-align:center">任务取消 </td></tr></tbody></table><p>通过 <code>r.get(&#39;status&#39;) == &#39;PENDING&#39;</code> 获取状态</p><h2 id="设置任务调度器"><a href="#设置任务调度器" class="headerlink" title="设置任务调度器"></a>设置任务调度器</h2><p>配置文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">Config = dict(</span><br><span class="line">    CELERYBEAT_SCHEDULE=&#123;</span><br><span class="line">        <span class="string">'ptask'</span>: &#123;</span><br><span class="line">            <span class="string">'task'</span>: <span class="string">'flask_app.celery_app.task.period_task'</span>,</span><br><span class="line">            <span class="string">'schedule'</span>: timedelta(seconds=<span class="number">5</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置中 schedule 就是间隔执行的时间，这里可以用 datetime.timedelta 或者 crontab，如果定时任务涉及到 datetime 需要在配置中加入时区信息，否则默认是以 utc 为准。例如中国可以加上：</p><p><code>CELERY_TIMEZONE = &#39;Asia/Shanghai&#39;</code></p><p>task的任务路径不能出错，在启动Worker进程的时候，可以看到task列表，这里指的的定时任务和其对应即可。</p><p>启动命令：</p><p>需要执行两个进程，一个是Worker进程，用来处理生成的任务，一个就是beat进程，启动任务调度器进程，定时生成任务</p><ul><li><code>celery beat -A auto_app.celery --loglevel=info</code></li><li><code>celery worker -A auto_app.celery --loglevel=info</code></li></ul><blockquote><p>任务调度会有需要动态添加任务，管理任务的情况，Django框架通过djang-celery实现在管理后台创建，删除，更新任务，它通过自定义调度类来实现，如果有类似的需求，可以参考源码实现</p></blockquote><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>Signature 对象，把任务通过签名的方法传递给其它任务，成为一个子任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [6]: task = signature(&apos;flask_app.celery_app.task.add&apos;, args=(2, 2), countdown=5)</span><br><span class="line">In [7]: task</span><br><span class="line">Out[7]: flask_app.celery_app.task.add(2, 2)</span><br><span class="line">In [8]: task.apply_async()</span><br><span class="line">Out[8]: &lt;AsyncResult: 0cbe319e-c3f6-48b9-b1e4-6a034711cf3a&gt;</span><br></pre></td></tr></table></figure><p><code>from celery import signature</code> 导入signature，可以看到，传递的第一个参数是已经存在的任务，也可以先把add导入，通过 <code>add.subtask((2, 2), countdown=5)</code>，或使用subtask的缩写s，add.s()。</p><p>子任务能支持偏函数的方式，利用它实现工作流。</p><p>支持原语实现工作流，原语表示由若干条指令组成的，用于完成一定功能的过程</p><p>1.chain - 调用链，任务的链式执行，前面的执行结果作为参数传递给后面，直到任务完成</p><p>chain 函数接受一个任务的列表，Celery 保证一个 chain 里的子任务会依次执行，在 AsynResult 上执行 get 会得到最后一个任务的返回值。和 link 功能类似，每一个任务执行结果会当作参数传入下一个任务，所以如果你不需要这种特性，采用 immutable signature 来取消。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> chain</span><br><span class="line">    part = add.s(<span class="number">1</span>, <span class="number">2</span>) | add.s(<span class="number">3</span>) | add.s(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># or part = (add.s(1, 2), add.s(3), add.s(5))</span></span><br><span class="line">    res = chain(part)()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure><p>2.group - 任务的并发执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> group</span><br><span class="line">    res = group([add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)])()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure><p>group 函数也接受一个任务列表，这些任务会同时加入到任务队列中，且执行顺序没有任何保证。在 AsynResult 上执行 get 会得到一个包含了所有返回值的列表。<code>意参数必须是list对象</code></p><ol start="3"><li>chord - 带回调的 group</li></ol><p>chord 基本功能和 group 类似，只是有一个额外的回调函数。回调函数会在前面的任务全部结束时执行，其参数是一个包含了所有任务返回值的列表。在 AsynResult 上执行 get 会得到回调函数的返回值。</p><ol start="4"><li><p>map/starmap - 每个参数都作为任务的参数执行一遍</p></li><li><p>chunks - 将任务分块</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在启动Worker进程后，可以看到被装饰的任务已经被列出来了，这说明Celery有读取文件的机制(你可以在任务模块的最外层使用print测试)，被装饰的函数应该要在最外层，而且，创建实例后，再去修改配置，似乎没有生效（在我的测试中是这样的），其实这也符合逻辑，在进程被创建了，却又动态的去修改配置，与之对应的风险也很高。</p><p>celery是队列管理工具，真正的队列是Broker，更深入一点要了解RabbitMQ，AMQP协议，一般在celery上关注Worker，可以使用多个Worker，任务的生成使用定时器或触发的机制，任务本身就要由Python来编写，也包括对执行结果的处理。</p><p>任务生成，处理有了，还有队列的管理，默认使用名为celery的队列，可以配置队列，比如队列A，队列B，进入A队列的任务优先级要高，会被先处理。可以在启动worker进程的时候指明队列(通过-Q指定队)，这样这个Worker只会处理指定的队列。</p><p>后续扩展内容：celery信号，分析任务执行情况。Worker管理，监控和管理celery。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.liuzhidream.com/categories/web/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-threading</title>
    <link href="http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/"/>
    <id>http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>python多线程相关笔记</p><a id="more"></a><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL）</p><p>可以通过time.sleep(3)来阻塞线程</p><p>一个简单例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 此时创建列表a占用了解释器，先hello world 再 sleep</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11111111111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器）</span></span><br></pre></td></tr></table></figure><h2 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h2><ul><li>current_thread()  # 返回当前线程对象.</li><li>main_thread()  # 返回主线程对象.</li><li>active_count()  # 当前处于alive状态的线程个数.</li><li>enumerate()  # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程.</li><li>get_ident()  # 返回当前线程ID，非0整数.</li></ul><p>看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># a = [i for i in range(1111)]</span></span><br><span class="line">    print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">    print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">    print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line">print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br></pre></td></tr></table></figure><p>运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。</p><h2 id="thread实例的属性和方法"><a href="#thread实例的属性和方法" class="headerlink" title="thread实例的属性和方法"></a>thread实例的属性和方法</h2><ul><li>name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。</li><li>ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。</li><li>is_alive(): 返回线程是否活着。</li></ul><p>通过threading.Thread()  我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性</p><p><code>t = threading.Thread(target=func, name=&#39;my_thread&#39;, args=(&#39;1&#39;, ), kwargs={&#39;a&#39;: 2})</code></p><ul><li>start(): 启动线程。每一个线程必须且只能执行该方法一次。</li></ul><p>开始线程活动。</p><p>对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。<br>当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。</p><ul><li>run(): 运行线程函数。</li></ul><p>代表了线程活动的方法。</p><p>你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。</p><p>start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。</p><p>而run只在当前线程中执行。</p><h2 id="多线程情况"><a href="#多线程情况" class="headerlink" title="多线程情况"></a>多线程情况</h2><p>继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line">        <span class="comment"># print(threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.main_thread())</span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.start()</span><br><span class="line">t2.start()</span><br><span class="line">t.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># &lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。</p><p>打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。</p><p>换成run()方法后，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        <span class="comment"># print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.run()</span><br><span class="line">t2.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，run就是去调用函数，谁来调用呢？当然是<code>当前线程</code>了，可以看到 <code>print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</code> 打印出来的都是主线程。</p><p><strong>没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。</strong></p><p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p><p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个<code>主线程</code>。其他线程称为<code>工作线程</code>。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。</p><p>print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。</p><p>说明print函数不是线程安全函数。</p><p>print函数还没执行换行符，就被其它线程打断了，在python3中：</p><p><code>def print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None)</code></p><p>print变成了函数，结尾默认加‘\n’，你可以去改变这个参数，比如改成’’, 打印结果就是一行的一串字符</p><p>线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。</p><h2 id="线程daemon"><a href="#线程daemon" class="headerlink" title="线程daemon"></a>线程daemon</h2><p>线程可以被标识为”Daemon线程”，<strong>Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出</strong>。该属性值继承自父线程，可通过setDaemon()函数设定该值。</p><p>daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)：</p><ul><li>进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。</li><li>主线程是第一个启动的线程。</li><li>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</li><li>子线程：B就是A的子线程。</li><li>python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。</li></ul><p>daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。</p><blockquote><p>daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完<br>daemon=True 运行发现主线程执行完程序立即结束了</p></blockquote><p>实例方法：</p><p>isDaemon()：是否是daemon线程。<br>setDaemon()：设置为daemon线程，必须在start方法之前设置。</p><p>总结:</p><p>线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。</p><p>如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。</p><p>主线程是non-daemon线程，即daemon=False。</p><p>从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。</p><p>python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p><ul><li>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束</li><li>如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。</li></ul><p>线程创建的时候<code>t = threading.Thread(target=func, daemon=False)</code>这个daemon不设置就是False</p><p>子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。</p><p>Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=foo, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line"><span class="comment"># t1.join()  # 设置join.</span></span><br><span class="line">print(<span class="string">'Main Thread Exiting'</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3…..</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul><li>使用了join方法后，daemon线程执行完了，主线程才退出。</li><li>join(timeout=None)，是线程的标准方法之一。</li><li>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。</li><li>一个线程可以被join多次。</li><li>timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。</li><li>调用谁的join方法，就是join谁，就要等谁。</li></ul><p>把上面例子的 <code>t1.join()  # 设置join.</code> 放开，<code>print(&#39;Main Thread Exiting&#39;)</code> 要等子线程执行完成才执行。</p><p>join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。</p><p>总结：</p><p>主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。</p><p>在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br></pre></td></tr></table></figure><p>利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列）</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制</code></p><ul><li>queue.qsize() 返回队列的大小</li><li>queue.empty() 如果队列为空，返回True，反之False</li><li>queue.full() 如果队列满了，返回True，反之False</li><li>queue.full 与 maxsize 大小对应</li><li>queue.get([block[, timeout]])获取队列，timeout等待时间</li><li>queue.get_nowait() 相当queue.get(False)</li><li>queue.put(item) 写入队列，timeout等待时间</li><li>queue.put_nowait(item) 相当queue.put(item, False)</li><li>queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号</li><li>queue.join() 实际上意味着等到队列为空，再执行别的操作</li></ul><h2 id="本地线程"><a href="#本地线程" class="headerlink" title="本地线程"></a>本地线程</h2><p>不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响，在flask框架中有使用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_data = threading.local()</span><br><span class="line">my_data.number = <span class="number">42</span></span><br><span class="line">print(my_data.number)</span><br><span class="line">log = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    my_data.number = <span class="number">11</span></span><br><span class="line">    log.append(my_data.number)</span><br><span class="line">    print(id(my_data.number))</span><br><span class="line"></span><br><span class="line">thread = threading.Thread(target=f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br><span class="line">print(log)</span><br><span class="line">print(my_data.number)</span><br><span class="line">print(id(my_data.number))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559721904</span></span><br><span class="line"><span class="comment"># [11]</span></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559722896</span></span><br></pre></td></tr></table></figure><h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>控制多线程同时访问资源，包括互斥锁，信号量，条件变量，事件</p><p>以房间为例子举例：</p><p>有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>还有些房间，可以同时容纳n个人。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用信号量做为同步机制，使用with进入上下文管理器，省略了acquire和release，信号量通过计数器来管理，这里计数器初始是3，获取acquire操作，计数器减1，release操作，计数器加1，当计数器为0的时候，阻塞其它线程的操作。</p><p>通过执行结果可以看到，创建了5个线程，前3个线程 0，1，2 执行了 acquire操作，使得信号量为0，阻塞了其它线程，通过sleep模拟<br>线程阻塞，等到线程 2 release的时候，线程 3 才执行 acquire 操作，4 线程也是等待 3 线程release后才执行 acquire。</p><p>通过使用信号量，实现了只能有3个线程并发，而锁其实就是信号量为1的情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"></span><br><span class="line">sema = Semaphore(<span class="number">3</span>) <span class="comment"># 创建信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(tid)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> sema:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> acquire sema'</span>)</span><br><span class="line">        time.sleep(random() * <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> release sema'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = Thread(target=foo, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">    i.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 acquire sema</span></span><br><span class="line"><span class="comment"># 1 acquire sema</span></span><br><span class="line"><span class="comment"># 2 acquire sema</span></span><br><span class="line"><span class="comment"># 2 release sema</span></span><br><span class="line"><span class="comment"># 3 acquire sema</span></span><br><span class="line"><span class="comment"># 3 release sema</span></span><br><span class="line"><span class="comment"># 4 acquire sema</span></span><br><span class="line"><span class="comment"># 1 release sema</span></span><br><span class="line"><span class="comment"># 0 release sema</span></span><br><span class="line"><span class="comment"># 4 release sema</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。</p><p>线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。</p><ol><li><p>协同式多任务处理<br>当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。</p></li><li><p>抢占式多任务处理<br>Python线程可以主动释放 GIL，也可以先发制人抓取 GIL 。</p></li></ol><p>让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python多线程相关笔记&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.liuzhidream.com/categories/python/"/>
    
    
      <category term="note" scheme="http://www.liuzhidream.com/tags/note/"/>
    
      <category term="python" scheme="http://www.liuzhidream.com/tags/python/"/>
    
  </entry>
  
</feed>
