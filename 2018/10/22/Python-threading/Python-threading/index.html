<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Python-threading | VanLiuZhi | 有梦想的人不睡觉</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#00e1ff">
    
    
    <meta name="keywords" content="note,python">
    <meta name="description" content="python多线程相关笔记">
<meta name="keywords" content="note,python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-threading">
<meta property="og:url" content="http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/index.html">
<meta property="og:site_name" content="VanLiuZhi">
<meta property="og:description" content="python多线程相关笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-01-09T15:52:04.697Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python-threading">
<meta name="twitter:description" content="python多线程相关笔记">
    
        <link rel="alternate" type="application/atom+xml" title="VanLiuZhi" href="/learn_programing/atom.xml">
    
    <link rel="shortcut icon" href="/learn_programing/favicon.ico">
    <link rel="stylesheet" href="/learn_programing/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/learn_programing/img/brand2.jpg)">
      <div class="brand">
        <a href="/learn_programing/" class="avatar waves-effect waves-circle waves-light">
          <img src="/learn_programing/img/me.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Liu Zhi</h5>
          <a href="mailto:vanliuzhi@qq.com" title="vanliuzhi@qq.com" class="mail">vanliuzhi@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/tags/note">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/categories/python">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/VanLiuZhi" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://segmentfault.com/u/justicelz" target="_blank">
                <i class="icon icon-lg icon-link"></i>
                SegmentFault
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python-threading</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python-threading</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-10-21T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2018-10-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/learn_programing/categories/python/">python</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程"><span class="post-toc-number">1.</span> <span class="post-toc-text">线程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#threading的属性和方法"><span class="post-toc-number">2.</span> <span class="post-toc-text">threading的属性和方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#thread实例的属性和方法"><span class="post-toc-number">3.</span> <span class="post-toc-text">thread实例的属性和方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多线程情况"><span class="post-toc-number">4.</span> <span class="post-toc-text">多线程情况</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程安全"><span class="post-toc-number">5.</span> <span class="post-toc-text">线程安全</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程daemon"><span class="post-toc-number">6.</span> <span class="post-toc-text">线程daemon</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#join"><span class="post-toc-number">7.</span> <span class="post-toc-text">join</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#原子性"><span class="post-toc-number">8.</span> <span class="post-toc-text">原子性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#队列"><span class="post-toc-number">9.</span> <span class="post-toc-text">队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实例方法"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">实例方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#本地线程"><span class="post-toc-number">10.</span> <span class="post-toc-text">本地线程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步原语"><span class="post-toc-number">11.</span> <span class="post-toc-text">同步原语</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#信号量"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">信号量</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">12.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Python-threading/Python-threading" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python-threading</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-10-22 00:00:00" datetime="2018-10-21T16:00:00.000Z" itemprop="datePublished">2018-10-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/learn_programing/categories/python/">python</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>python多线程相关笔记</p>
<a id="more"></a>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL）</p>
<p>可以通过time.sleep(3)来阻塞线程</p>
<p>一个简单例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 此时创建列表a占用了解释器，先hello world 再 sleep</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算密集型任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11111111111</span>)]</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line"><span class="comment"># 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器）</span></span><br></pre></td></tr></table></figure>
<h2 id="threading的属性和方法"><a href="#threading的属性和方法" class="headerlink" title="threading的属性和方法"></a>threading的属性和方法</h2><ul>
<li>current_thread()  # 返回当前线程对象.</li>
<li>main_thread()  # 返回主线程对象.</li>
<li>active_count()  # 当前处于alive状态的线程个数.</li>
<li>enumerate()  # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程.</li>
<li>get_ident()  # 返回当前线程ID，非0整数.</li>
</ul>
<p>看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># a = [i for i in range(1111)]</span></span><br><span class="line">    print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">    print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">    print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=func)</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'sleep'</span>)</span><br><span class="line">print(<span class="string">'current thread = &#123;&#125;'</span>.format(threading.current_thread()))</span><br><span class="line">print(<span class="string">'main thread = &#123;&#125;'</span>.format(threading.main_thread()), <span class="string">'"主线程对象"'</span>)</span><br><span class="line">print(<span class="string">'active count = &#123;&#125;'</span>.format(threading.active_count()), <span class="string">'"alive"'</span>)</span><br></pre></td></tr></table></figure>
<p>运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。</p>
<h2 id="thread实例的属性和方法"><a href="#thread实例的属性和方法" class="headerlink" title="thread实例的属性和方法"></a>thread实例的属性和方法</h2><ul>
<li>name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。</li>
<li>ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。</li>
<li>is_alive(): 返回线程是否活着。</li>
</ul>
<p>通过threading.Thread()  我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性</p>
<p><code>t = threading.Thread(target=func, name=&#39;my_thread&#39;, args=(&#39;1&#39;, ), kwargs={&#39;a&#39;: 2})</code></p>
<ul>
<li>start(): 启动线程。每一个线程必须且只能执行该方法一次。</li>
</ul>
<p>开始线程活动。</p>
<p>对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。<br>当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。</p>
<ul>
<li>run(): 运行线程函数。</li>
</ul>
<p>代表了线程活动的方法。</p>
<p>你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。</p>
<p>start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。</p>
<p>而run只在当前线程中执行。</p>
<h2 id="多线程情况"><a href="#多线程情况" class="headerlink" title="多线程情况"></a>多线程情况</h2><p>继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line">        <span class="comment"># print(threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(threading.main_thread())</span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.start()</span><br><span class="line">t2.start()</span><br><span class="line">t.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># &lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># start~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。</p>
<p>打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。</p>
<p>换成run()方法后，结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.NOTSET)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print("worker running")</span></span><br><span class="line">        <span class="comment"># print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</span></span><br><span class="line">        logging.info(<span class="string">"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;"</span>.format(threading.current_thread().name, threading.current_thread().ident,</span><br><span class="line">                                        threading.main_thread()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'start~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'run~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">        super().run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = MyThread(name=<span class="string">'worker'</span>, target=worker)</span><br><span class="line">t2 = MyThread(name=<span class="string">'not worker'</span>, target=worker)</span><br><span class="line">t.run()</span><br><span class="line">t2.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># run~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br><span class="line"><span class="comment"># INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，run就是去调用函数，谁来调用呢？当然是<code>当前线程</code>了，可以看到 <code>print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident)</code> 打印出来的都是主线程。</p>
<p><strong>没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。</strong></p>
<p>当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。</p>
<p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个<code>主线程</code>。其他线程称为<code>工作线程</code>。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。</p>
<p>print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。</p>
<p>说明print函数不是线程安全函数。</p>
<p>print函数还没执行换行符，就被其它线程打断了，在python3中：</p>
<p><code>def print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None)</code></p>
<p>print变成了函数，结尾默认加‘\n’，你可以去改变这个参数，比如改成’’, 打印结果就是一行的一串字符</p>
<p>线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。</p>
<h2 id="线程daemon"><a href="#线程daemon" class="headerlink" title="线程daemon"></a>线程daemon</h2><p>线程可以被标识为”Daemon线程”，<strong>Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出</strong>。该属性值继承自父线程，可通过setDaemon()函数设定该值。</p>
<p>daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)：</p>
<ul>
<li>进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。</li>
<li>主线程是第一个启动的线程。</li>
<li>父线程：如果线程A中启动了一个线程B，A就是B的父线程。</li>
<li>子线程：B就是A的子线程。</li>
<li>python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。</li>
</ul>
<p>daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。</p>
<blockquote><p>daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完<br>daemon=True 运行发现主线程执行完程序立即结束了</p>
</blockquote>
<p>实例方法：</p>
<p>isDaemon()：是否是daemon线程。<br>setDaemon()：设置为daemon线程，必须在start方法之前设置。</p>
<p>总结:</p>
<p>线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。</p>
<p>如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。</p>
<p>主线程是non-daemon线程，即daemon=False。</p>
<p>从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。</p>
<p>python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。</p>
<ul>
<li>如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束</li>
<li>如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。</li>
</ul>
<p>线程创建的时候<code>t = threading.Thread(target=func, daemon=False)</code>这个daemon不设置就是False</p>
<p>子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。</p>
<p>Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        print(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=foo, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line"><span class="comment"># t1.join()  # 设置join.</span></span><br><span class="line">print(<span class="string">'Main Thread Exiting'</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3…..</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><ul>
<li>使用了join方法后，daemon线程执行完了，主线程才退出。</li>
<li>join(timeout=None)，是线程的标准方法之一。</li>
<li>一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。</li>
<li>一个线程可以被join多次。</li>
<li>timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。</li>
<li>调用谁的join方法，就是join谁，就要等谁。</li>
</ul>
<p>把上面例子的 <code>t1.join()  # 设置join.</code> 放开，<code>print(&#39;Main Thread Exiting&#39;)</code> 要等子线程执行完成才执行。</p>
<p>join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。</p>
<p>总结：</p>
<p>主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。</p>
<p>在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br></pre></td></tr></table></figure>
<p>利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列）</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制</code></p>
<ul>
<li>queue.qsize() 返回队列的大小</li>
<li>queue.empty() 如果队列为空，返回True，反之False</li>
<li>queue.full() 如果队列满了，返回True，反之False</li>
<li>queue.full 与 maxsize 大小对应</li>
<li>queue.get([block[, timeout]])获取队列，timeout等待时间</li>
<li>queue.get_nowait() 相当queue.get(False)</li>
<li>queue.put(item) 写入队列，timeout等待时间</li>
<li>queue.put_nowait(item) 相当queue.put(item, False)</li>
<li>queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号</li>
<li>queue.join() 实际上意味着等到队列为空，再执行别的操作</li>
</ul>
<h2 id="本地线程"><a href="#本地线程" class="headerlink" title="本地线程"></a>本地线程</h2><p>不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响，在flask框架中有使用到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">my_data = threading.local()</span><br><span class="line">my_data.number = <span class="number">42</span></span><br><span class="line">print(my_data.number)</span><br><span class="line">log = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    my_data.number = <span class="number">11</span></span><br><span class="line">    log.append(my_data.number)</span><br><span class="line">    print(id(my_data.number))</span><br><span class="line"></span><br><span class="line">thread = threading.Thread(target=f)</span><br><span class="line">thread.start()</span><br><span class="line">thread.join()</span><br><span class="line">print(log)</span><br><span class="line">print(my_data.number)</span><br><span class="line">print(id(my_data.number))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559721904</span></span><br><span class="line"><span class="comment"># [11]</span></span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line"><span class="comment"># 4559722896</span></span><br></pre></td></tr></table></figure>
<h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>控制多线程同时访问资源，包括互斥锁，信号量，条件变量，事件</p>
<p>以房间为例子举例：</p>
<p>有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p>
<p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p>
<p>还有些房间，可以同时容纳n个人。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p>
<p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量（Semaphore），用来保证多个线程不会互相冲突。</p>
<p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>使用信号量做为同步机制，使用with进入上下文管理器，省略了acquire和release，信号量通过计数器来管理，这里计数器初始是3，获取acquire操作，计数器减1，release操作，计数器加1，当计数器为0的时候，阻塞其它线程的操作。</p>
<p>通过执行结果可以看到，创建了5个线程，前3个线程 0，1，2 执行了 acquire操作，使得信号量为0，阻塞了其它线程，通过sleep模拟<br>线程阻塞，等到线程 2 release的时候，线程 3 才执行 acquire 操作，4 线程也是等待 3 线程release后才执行 acquire。</p>
<p>通过使用信号量，实现了只能有3个线程并发，而锁其实就是信号量为1的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"></span><br><span class="line">sema = Semaphore(<span class="number">3</span>) <span class="comment"># 创建信号量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(tid)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> sema:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> acquire sema'</span>)</span><br><span class="line">        time.sleep(random() * <span class="number">2</span>)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;tid&#125;</span> release sema'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = Thread(target=foo, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> threads:</span><br><span class="line">    i.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 acquire sema</span></span><br><span class="line"><span class="comment"># 1 acquire sema</span></span><br><span class="line"><span class="comment"># 2 acquire sema</span></span><br><span class="line"><span class="comment"># 2 release sema</span></span><br><span class="line"><span class="comment"># 3 acquire sema</span></span><br><span class="line"><span class="comment"># 3 release sema</span></span><br><span class="line"><span class="comment"># 4 acquire sema</span></span><br><span class="line"><span class="comment"># 1 release sema</span></span><br><span class="line"><span class="comment"># 0 release sema</span></span><br><span class="line"><span class="comment"># 4 release sema</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。</p>
<p>线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。</p>
<ol>
<li><p>协同式多任务处理<br>当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。</p>
</li>
<li><p>抢占式多任务处理<br>Python线程可以主动释放 GIL，也可以先发制人抓取 GIL 。</p>
</li>
</ol>
<p>让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-01-09T15:52:04.697Z" itemprop="dateUpdated">2019-01-09 23:52:04</time>
</span><br>


        
        今天也是充满希望的一天！
        
    </div>
    
    <footer>
        <a href="http://www.liuzhidream.com">
            <img src="/learn_programing/img/me.jpg" alt="Liu Zhi">
            Liu Zhi
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/learn_programing/tags/note/">note</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/learn_programing/tags/python/">python</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&title=《Python-threading》 — VanLiuZhi&pic=http://www.liuzhidream.com/img/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&title=《Python-threading》 — VanLiuZhi&source=python多线程相关笔记" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python-threading》 — VanLiuZhi&url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&via=http://www.liuzhidream.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/learn_programing/2018/10/22/Collect/collect/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Collect</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/learn_programing/2018/10/22/Python-asyncio/README/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Python-异步与协程</h4>
      </a>
    </div>
  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: '',
            repo: '',
            oauth: {
                client_id: '',
                client_secret: '',
            },
        })
        gitment.render('comments')
    </script>
</section>










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/learn_programing/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Liu Zhi &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&title=《Python-threading》 — VanLiuZhi&pic=http://www.liuzhidream.com/img/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&title=《Python-threading》 — VanLiuZhi&source=python多线程相关笔记" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python-threading》 — VanLiuZhi&url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/&via=http://www.liuzhidream.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.liuzhidream.com/2018/10/22/Python-threading/Python-threading/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACr0lEQVR42u3a0WojMQwF0P7/T2dhnwrdtPdKdtKF46dhOnF8pmApsj4+4vH4Oz5ff77z9cmvf/3+zuPL+P7+4YGHh4c3Wvqz8WzR7aeSl7Kf+R/z4+Hh4V3jJV+ZvJRk5tkz36/n6X08PDy8t/Jmd/aJOB4eHt7/ztuQEl7+vXh4eHjv5SU//pPrJBHP53lprQUPDw8v5s0OwN57ff18Dw8PD290qp6MvCw72+4368TDw8O7wcuLDvti62a2WSkEDw8P7wYv3+jbhSZ32oJs3ZqAh4eHd42Xk9qCafKp9nisaA7Dw8PDu8ZrSwP5Jj5bVhJOoh8DeHh4eBd4s028TW3bV3aldQAPDw/vAm+TOrf4PI1uGxrw8PDwXsNrGav3FweSJMmO1oyHh4d3lJdPtAHM2rPaoPK03QoPDw/vKG+T1J49Etu0HfywEjw8PLxrvGFLaBkYZi1cm6IGHh4e3g1ecuSfJN9tWpy3BRwr/uLh4eFd4yWlhzylzo/5Z08W5V08PDy8Q7xN0pwvtC3jtmn30+fx8PDwjvI2jaHDPoV14bgITnh4eHgv5OWl2E3RIX9ZbaqNh4eH9xre5jiqPf6fhaI8BcfDw8N7F69NcPNNf5PQF2VfPDw8vGu8fZNo/pWb+dtiLh4eHt4N3uZQqm2u2jROtek1Hh4e3j3eJvHNG7b2ISRvYI1+MeDh4eEteLPiQh4e2iOuWTtClFjj4eHhHeI9yrFvXf3hyGrRWFB0RuDh4eEtePnYbNz560iCStvigIeHh3eDNzusmh35z1oE2s8W0Q8PDw9vwdsEg1moaA/b2tCFh4eH93t4bem2bQLIA9KVwICHh4d3lLe5boutScGiKEbg4eHhXeC1xYg8UZ4VF07NhoeHh3eDd6pwsEp8gy3+1D8ADw8Pb8H7A1wMNyvPG/eTAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/learn_programing/', SHARE: true, REWARD: false };


</script>

<script src="/learn_programing/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/learn_programing/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
