<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Celery | VanLiuZhi | 有梦想的人不睡觉</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#00e1ff">
    
    
    <meta name="keywords" content="note,python">
    <meta name="description" content="Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。">
<meta name="keywords" content="note,python">
<meta property="og:type" content="article">
<meta property="og:title" content="Celery">
<meta property="og:url" content="http://www.liuzhidream.com/2018/10/22/Web/Celery/index.html">
<meta property="og:site_name" content="VanLiuZhi">
<meta property="og:description" content="Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-21T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Celery">
<meta name="twitter:description" content="Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。">
    
        <link rel="alternate" type="application/atom+xml" title="VanLiuZhi" href="/learn_programing/atom.xml">
    
    <link rel="shortcut icon" href="/learn_programing/favicon.ico">
    <link rel="stylesheet" href="/learn_programing/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/learn_programing/img/brand2.jpg)">
      <div class="brand">
        <a href="/learn_programing/" class="avatar waves-effect waves-circle waves-light">
          <img src="/learn_programing/img/me.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Liu Zhi</h5>
          <a href="mailto:vanliuzhi@qq.com" title="vanliuzhi@qq.com" class="mail">vanliuzhi@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/tags/note">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/learn_programing/categories/python">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/VanLiuZhi" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://segmentfault.com/u/justicelz" target="_blank">
                <i class="icon icon-lg icon-link"></i>
                SegmentFault
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Celery</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Celery</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-10-21T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2018-10-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/learn_programing/categories/web/">web</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Celery"><span class="post-toc-number">1.</span> <span class="post-toc-text">Celery</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#安装"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#架构"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">架构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#在flask中使用celery"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">在flask中使用celery</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注意事项"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">注意事项</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据序列化"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">数据序列化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用步骤"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">使用步骤</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#装饰器参数"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">装饰器参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#调用任务"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">调用任务</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#apply-async的参数"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">apply_async的参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本配置"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">基本配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#命令"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#任务状态"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">任务状态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#设置任务调度器"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">设置任务调度器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#工作流"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">工作流</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">总结</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Web/Celery" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Celery</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-10-22 00:00:00" datetime="2018-10-21T16:00:00.000Z" itemprop="datePublished">2018-10-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/learn_programing/categories/web/">web</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p>
<a id="more"></a>
<h1 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h1><p>Celery - Distributed Task Queue</p>
<p>要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>通过Python的包管理工具来安装，在我查到的一些资料中，celery和docker的配合不是很好，建议不要在单一容器中使用celery了。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>生产者(Celery client)。生产者(Celery client)发送消息。在Flask上工作时，生产者(Celery client)在Flask应用内运行。</li>
<li>消费者(Celery workers)。消费者用于处理后台任务。消费者(Celery client)可以是本地的也可以是远程的。我们可以在运行Flask的server上运行一个单一的消费者(Celery workers)，当业务量上涨之后再去添加更多消费者(Celery workers)。</li>
<li>消息传递者(message broker)。生产者(Celery client)和消费者(Celery workers)的信息的交互使用的是消息队列(message queue)。Celery支持若干方式的消息队列，其中最常用的是RabbitMQ和Redis.</li>
</ul>
<p>以上是最基本的架构，完整的组件还包括：</p>
<ol>
<li>Celery Beat：任务调度器</li>
<li>Celery Worker：执行任务的消费者</li>
<li>Broker：消息代理</li>
<li>Product：任务生产者（通过API，装饰器等产生任务并交个任务队列处理）</li>
<li>Result Backend：任务处理完成后，保存状态信息，以供查询</li>
</ol>
<p>1，4都是任务的生产者，只是方式不一样，1的方式是Beat进程读取配置文件，周期性的将到期的任务发给任务队列执行，就是定时任务。</p>
<h2 id="在flask中使用celery"><a href="#在flask中使用celery" class="headerlink" title="在flask中使用celery"></a>在flask中使用celery</h2><p>如何集成，并且很好的解耦模块是celery运用的关键。你总不能把代码都堆叠在一起吧。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>flask_celery不能支持celery4.0，所以弃用扩展模块，直接使用celery模块。使用扩展的好处是在扩展模块在一个文件初始化，并且全局保持一个实例对象，所以你的celery需要在app创建后才能创建，需要考虑是否使用了全局的celery对象</li>
<li>创建celery的实例对象的名字使用flask应用程序app的名字，通过 <code>app.name</code> 获取，如果你使用扩展插件，建议不要修改此名称，否则创建失败，不使用扩展插件也不建议修改</li>
<li>当有多个装饰器的时候，celery.task一定要在最外层</li>
</ul>
<p>init代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = create_app(CONFIG)</span><br><span class="line">celery = CeleryApp(app.name)</span><br><span class="line">celery.conf.update(app.config)</span><br></pre></td></tr></table></figure>
<p>首先创建Flask app的实例app，然后创建Celery的实例celery，这里需要传递一个名称，这个名称会作为celery task的前缀，例如 <code>flask_app.celery_app.task.long_task</code>，long_task是我们定义的任务，你要改创建实例的参数也可以，建议不要修改。这里的CeleryApp是自己编写的，继承Celery的一个类，目的是实现单实例，让其它模块通过CeleryApp创建的实例保持一样，然后调用celery.conf.update更新参数，<code>flask app.config</code> 是继承dict的Config类，这样就把需要的参数配置通过flask配置，作用于celery。</p>
<p>flask大多数的插件做的事情就是在单独的扩展文件中，先不传递参数实例化扩展，然后在创建app的时候初始化它，估计flask_celery也是做差不多的事情，不过实例化Celery必须要先传递参数，现在插件没有在更新了(有一些其他名称的扩展可以支持)，主要还是为了工程化。</p>
<p>这里记录一下扩展包的情况吧，在py3中，有：</p>
<p>Flask-Celery：这个其实不是扩展，而是装这个就把Celery相关的给安装了，这个是Celery的作者写的，他也说在4.0版本不再需要了，我也没看出来这个有什么用</p>
<p>Flask-Celery-Helper：这个就是扩展了，导入用flask_celery，不支持4.0</p>
<p>Flask-Celery-py3，Flask-Celery3：好像都是不支持4.0的</p>
<p>Flask-CeleryExt：在文档中写明可以支持4.0了，和大部分扩展使用方法一样，用懒加载的方式实例化</p>
<h3 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h3><table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Description </th>
</tr>
</thead>
<tbody>
<tr>
<td>pickle:</td>
<td style="text-align:center">二进制序列化方式；是标准库的一个模块，支持Python的内置数据结构，但是他是Python的专有协议，在celery3.2开始，出于安全考虑，不再采用此方案；</td>
</tr>
<tr>
<td>json:</td>
<td style="text-align:center">json支持多种语言，可用于跨语言方案，但好像不支持自定义的类对象； </td>
</tr>
<tr>
<td>XML:</td>
<td style="text-align:center">类似标签语言； </td>
</tr>
<tr>
<td>msgpack:</td>
<td style="text-align:center">二进制的类json序列化方案，但比json的数据结构更小，更快； </td>
</tr>
<tr>
<td>yaml:</td>
<td style="text-align:center">yaml表达能力更强，支持的数据类型较json多，但是python客户端的性能不如json; </td>
</tr>
</tbody>
</table>
<p>在自定义对象上，序列化方案我也出现过问题，pickle用了不行，可能就是不支持了，有待解决</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><code>celery = Celery(app.name)</code> 创建celery实例</li>
<li><code>celery.conf.update(app.config)</code> 更新配置</li>
<li>在需要后台运行的任务使用@celery.task</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@celery.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello_world"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，被装饰的任务需要调用才会加到任务队列，也就是通过hello_world.delay()调用，在官方的例子中，通过继承的方式，增加 <code>__call__</code> 方法，内部调用run，这样装饰器@celery.task()便会直接加入任务队列了，不过这样的功能应该是不需要的。</p>
<p>通过 <code>r = hello_world.delay()</code> 方法，返回的对象拥有以下方法：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Description </th>
</tr>
</thead>
<tbody>
<tr>
<td>r.ready()</td>
<td style="text-align:center">#查看任务状态，返回布尔值，任务执行完成，返回True，否则返回False. </td>
</tr>
<tr>
<td>r.wait()</td>
<td style="text-align:center">#等待任务完成,返回任务执行结果，很少使用； </td>
</tr>
<tr>
<td>r.get(timeout=1)</td>
<td style="text-align:center">#获取任务执行结果，可以设置等待时间 </td>
</tr>
<tr>
<td>r.result</td>
<td style="text-align:center">#任务执行结果. </td>
</tr>
<tr>
<td>r.state</td>
<td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td>
</tr>
<tr>
<td>r.status</td>
<td style="text-align:center">#PENDING,START,SUCCESS，任务当前的状态 </td>
</tr>
<tr>
<td>r.successful</td>
<td style="text-align:center">#任务成功返回true </td>
</tr>
<tr>
<td>r.traceback</td>
<td style="text-align:center">#如果任务抛出了一个异常，你也可以获取原始的回溯信息</td>
</tr>
</tbody>
</table>
<h3 id="装饰器参数"><a href="#装饰器参数" class="headerlink" title="装饰器参数"></a>装饰器参数</h3><p><a href="mailto:`@celery.task" target="_blank" rel="noopener">`@celery.task</a>()`</p>
<ol>
<li><p>name：可以显示指定任务的名字；</p>
</li>
<li><p>serializer：指定序列化的方法；</p>
</li>
<li><p>bind：一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，具体属性可参照 <code>celery--app--task.py</code> 中的Task类，通过<code>self.request.__dict__</code>打印相关属性；</p>
</li>
<li><p>base：指定任务的基类，可以定义一个类，继承celery.Task，利用重写或扩展的类接口技术制定需求，例如on_success方法，默认是没有返回值的，就是提供这个钩子让开发者自定义的；</p>
</li>
</ol>
<h3 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h3><p>任务被装饰器装饰后，通过task.delay()，task.apply_async()把任务加入到队列中，send_task()，可以发送未被注册的异步任务，即没有被celery.task装饰的任务</p>
<h3 id="apply-async的参数"><a href="#apply-async的参数" class="headerlink" title="apply_async的参数"></a>apply_async的参数</h3><table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:left">Description </th>
</tr>
</thead>
<tbody>
<tr>
<td>countdown</td>
<td style="text-align:left">设置该任务等待一段时间再执行，单位为s； </td>
</tr>
<tr>
<td>eta</td>
<td style="text-align:left">定义任务的开始时间；eta=time.time()+10; </td>
</tr>
<tr>
<td>expires</td>
<td style="text-align:left">设置任务时间，任务在过期时间后还没有执行则被丢弃； </td>
</tr>
<tr>
<td>retry</td>
<td style="text-align:left">如果任务失败后,是否重试;使用true或false，默认为true </td>
</tr>
<tr>
<td>shadow</td>
<td style="text-align:left">重新指定任务的名字str，覆盖其在日志中使用的任务名称； </td>
</tr>
<tr>
<td>retry_policy</td>
<td style="text-align:left">重试策略，为一个字典，各个键值配置：<code>max_retries</code>-最大重试次数，默认为 3 次. <code>interval_start</code>-重试等待的时间间隔秒数，默认为 0 ，表示直接重试不等待. <code>interval_step</code>-每次重试让重试间隔增加的秒数，可以是数字或浮点数，默认为 0.2. <code>interval_max</code>-重试间隔最大的秒数,即通过 interval_step 增大到多少秒之后，就不在增加了，可以是数字或者浮点数，默认为 0.2 .</td>
</tr>
<tr>
<td>routing_key</td>
<td style="text-align:left">自定义路由键； </td>
</tr>
<tr>
<td>queue</td>
<td style="text-align:left">指定发送到哪个队列； </td>
</tr>
<tr>
<td>exchang</td>
<td style="text-align:left">指定发送到哪个交换机； </td>
</tr>
<tr>
<td>priority</td>
<td style="text-align:left">任务队列的优先级，0-9之间； </td>
</tr>
<tr>
<td>serializer</td>
<td style="text-align:left">任务序列化方法；通常不设置； </td>
</tr>
<tr>
<td>compression</td>
<td style="text-align:left">压缩方案，通常有zlib,bzip2 </td>
</tr>
<tr>
<td>headers</td>
<td style="text-align:left">为任务添加额外的消息； </td>
</tr>
<tr>
<td>link</td>
<td style="text-align:left">任务成功执行后的回调方法；是一个signature对象；可以用作关联任务； </td>
</tr>
<tr>
<td>link_error</td>
<td style="text-align:left">任务失败后的回调方法，是一个signature对象；</td>
</tr>
</tbody>
</table>
<p>自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task.apply_async((<span class="number">2</span>,<span class="number">2</span>), </span><br><span class="line">    compression=<span class="string">'zlib'</span>,</span><br><span class="line">    serialize=<span class="string">'json'</span>,</span><br><span class="line">    queue=<span class="string">'priority.high'</span>,</span><br><span class="line">    routing_key=<span class="string">'web.add'</span>,</span><br><span class="line">    priority=<span class="number">0</span>,</span><br><span class="line">    exchange=<span class="string">'web_exchange'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URL</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://username:passwd@host:port/虚拟主机名'</span></span><br><span class="line"><span class="comment"># 指定结果的接受地址</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://username:passwd@host:port/db'</span></span><br><span class="line"><span class="comment"># 指定任务序列化方式</span></span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'msgpack'</span> </span><br><span class="line"><span class="comment"># 指定结果序列化方式</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'msgpack'</span></span><br><span class="line"><span class="comment"># 任务过期时间,celery任务执行结果的超时时间</span></span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">60</span> * <span class="number">20</span>   </span><br><span class="line"><span class="comment"># 指定任务接受的序列化类型.</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">"msgpack"</span>]   </span><br><span class="line"><span class="comment"># 任务发送完成是否需要确认，这一项对性能有一点影响     </span></span><br><span class="line">CELERY_ACKS_LATE = <span class="keyword">True</span>  </span><br><span class="line"><span class="comment"># 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据</span></span><br><span class="line">CELERY_MESSAGE_COMPRESSION = <span class="string">'zlib'</span> </span><br><span class="line"><span class="comment"># 规定完成任务的时间</span></span><br><span class="line">CELERYD_TASK_TIME_LIMIT = <span class="number">5</span>  <span class="comment"># 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程</span></span><br><span class="line"><span class="comment"># celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目</span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">4</span> </span><br><span class="line"><span class="comment"># celery worker 每次去rabbitmq预取任务的数量</span></span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">4</span> </span><br><span class="line"><span class="comment"># 每个worker执行了多少任务就会死掉，默认是无限的</span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">40</span> </span><br><span class="line"><span class="comment"># 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中</span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">"default"</span> </span><br><span class="line"><span class="comment"># 设置详细的队列</span></span><br><span class="line">CELERY_QUEUES = &#123;</span><br><span class="line">    <span class="string">"default"</span>: &#123; <span class="comment"># 这是上面指定的默认队列</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"direct"</span>,</span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"topicqueue"</span>: &#123; <span class="comment"># 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列</span></span><br><span class="line">        <span class="string">"routing_key"</span>: <span class="string">"topic.#"</span>,</span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"topic_exchange"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"topic"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"task_eeg"</span>: &#123; <span class="comment"># 设置扇形交换机</span></span><br><span class="line">        <span class="string">"exchange"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">        <span class="string">"exchange_type"</span>: <span class="string">"fanout"</span>,</span><br><span class="line">        <span class="string">"binding_key"</span>: <span class="string">"tasks"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>celery worker -A auto_app.celery --loglevel=info</code> 启动Worker</p>
<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Description </th>
</tr>
</thead>
<tbody>
<tr>
<td>PENDING</td>
<td style="text-align:center">任务等待中 </td>
</tr>
<tr>
<td>STARTED</td>
<td style="text-align:center">任务已开始 </td>
</tr>
<tr>
<td>SUCCESS</td>
<td style="text-align:center">任务执行成功 </td>
</tr>
<tr>
<td>FAILURE</td>
<td style="text-align:center">任务执行失败 </td>
</tr>
<tr>
<td>RETRY</td>
<td style="text-align:center">任务将被重试 </td>
</tr>
<tr>
<td>REVOKED</td>
<td style="text-align:center">任务取消 </td>
</tr>
</tbody>
</table>
<p>通过 <code>r.get(&#39;status&#39;) == &#39;PENDING&#39;</code> 获取状态</p>
<h2 id="设置任务调度器"><a href="#设置任务调度器" class="headerlink" title="设置任务调度器"></a>设置任务调度器</h2><p>配置文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">Config = dict(</span><br><span class="line">    CELERYBEAT_SCHEDULE=&#123;</span><br><span class="line">        <span class="string">'ptask'</span>: &#123;</span><br><span class="line">            <span class="string">'task'</span>: <span class="string">'flask_app.celery_app.task.period_task'</span>,</span><br><span class="line">            <span class="string">'schedule'</span>: timedelta(seconds=<span class="number">5</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>配置中 schedule 就是间隔执行的时间，这里可以用 datetime.timedelta 或者 crontab，如果定时任务涉及到 datetime 需要在配置中加入时区信息，否则默认是以 utc 为准。例如中国可以加上：</p>
<p><code>CELERY_TIMEZONE = &#39;Asia/Shanghai&#39;</code></p>
<p>task的任务路径不能出错，在启动Worker进程的时候，可以看到task列表，这里指的的定时任务和其对应即可。</p>
<p>启动命令：</p>
<p>需要执行两个进程，一个是Worker进程，用来处理生成的任务，一个就是beat进程，启动任务调度器进程，定时生成任务</p>
<ul>
<li><code>celery beat -A auto_app.celery --loglevel=info</code></li>
<li><code>celery worker -A auto_app.celery --loglevel=info</code></li>
</ul>
<blockquote><p>任务调度会有需要动态添加任务，管理任务的情况，Django框架通过djang-celery实现在管理后台创建，删除，更新任务，它通过自定义调度类来实现，如果有类似的需求，可以参考源码实现</p>
</blockquote>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>Signature 对象，把任务通过签名的方法传递给其它任务，成为一个子任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [6]: task = signature(&apos;flask_app.celery_app.task.add&apos;, args=(2, 2), countdown=5)</span><br><span class="line">In [7]: task</span><br><span class="line">Out[7]: flask_app.celery_app.task.add(2, 2)</span><br><span class="line">In [8]: task.apply_async()</span><br><span class="line">Out[8]: &lt;AsyncResult: 0cbe319e-c3f6-48b9-b1e4-6a034711cf3a&gt;</span><br></pre></td></tr></table></figure>
<p><code>from celery import signature</code> 导入signature，可以看到，传递的第一个参数是已经存在的任务，也可以先把add导入，通过 <code>add.subtask((2, 2), countdown=5)</code>，或使用subtask的缩写s，add.s()。</p>
<p>子任务能支持偏函数的方式，利用它实现工作流。</p>
<p>支持原语实现工作流，原语表示由若干条指令组成的，用于完成一定功能的过程</p>
<p>1.chain - 调用链，任务的链式执行，前面的执行结果作为参数传递给后面，直到任务完成</p>
<p>chain 函数接受一个任务的列表，Celery 保证一个 chain 里的子任务会依次执行，在 AsynResult 上执行 get 会得到最后一个任务的返回值。和 link 功能类似，每一个任务执行结果会当作参数传入下一个任务，所以如果你不需要这种特性，采用 immutable signature 来取消。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> chain</span><br><span class="line">    part = add.s(<span class="number">1</span>, <span class="number">2</span>) | add.s(<span class="number">3</span>) | add.s(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># or part = (add.s(1, 2), add.s(3), add.s(5))</span></span><br><span class="line">    res = chain(part)()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure>
<p>2.group - 任务的并发执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtask</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> celery <span class="keyword">import</span> group</span><br><span class="line">    res = group([add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)])()</span><br><span class="line">    print(res.get())</span><br></pre></td></tr></table></figure>
<p>group 函数也接受一个任务列表，这些任务会同时加入到任务队列中，且执行顺序没有任何保证。在 AsynResult 上执行 get 会得到一个包含了所有返回值的列表。<code>意参数必须是list对象</code></p>
<ol start="3">
<li>chord - 带回调的 group</li>
</ol>
<p>chord 基本功能和 group 类似，只是有一个额外的回调函数。回调函数会在前面的任务全部结束时执行，其参数是一个包含了所有任务返回值的列表。在 AsynResult 上执行 get 会得到回调函数的返回值。</p>
<ol start="4">
<li><p>map/starmap - 每个参数都作为任务的参数执行一遍</p>
</li>
<li><p>chunks - 将任务分块</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在启动Worker进程后，可以看到被装饰的任务已经被列出来了，这说明Celery有读取文件的机制(你可以在任务模块的最外层使用print测试)，被装饰的函数应该要在最外层，而且，创建实例后，再去修改配置，似乎没有生效（在我的测试中是这样的），其实这也符合逻辑，在进程被创建了，却又动态的去修改配置，与之对应的风险也很高。</p>
<p>celery是队列管理工具，真正的队列是Broker，更深入一点要了解RabbitMQ，AMQP协议，一般在celery上关注Worker，可以使用多个Worker，任务的生成使用定时器或触发的机制，任务本身就要由Python来编写，也包括对执行结果的处理。</p>
<p>任务生成，处理有了，还有队列的管理，默认使用名为celery的队列，可以配置队列，比如队列A，队列B，进入A队列的任务优先级要高，会被先处理。可以在启动worker进程的时候指明队列(通过-Q指定队)，这样这个Worker只会处理指定的队列。</p>
<p>后续扩展内容：celery信号，分析任务执行情况。Worker管理，监控和管理celery。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-10-21T16:00:00.000Z" itemprop="dateUpdated">2018-10-22 00:00:00</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/learn_programing/2018/10/22/Web/Celery/" target="_blank" rel="external">http://www.liuzhidream.com/2018/10/22/Web/Celery/</a>
        
    </div>
    
    <footer>
        <a href="http://www.liuzhidream.com">
            <img src="/learn_programing/img/me.jpg" alt="Liu Zhi">
            Liu Zhi
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/learn_programing/tags/note/">note</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/learn_programing/tags/python/">python</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&title=《Celery》 — VanLiuZhi&pic=http://www.liuzhidream.com/img/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&title=《Celery》 — VanLiuZhi&source=Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.liuzhidream.com/2018/10/22/Web/Celery/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Celery》 — VanLiuZhi&url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&via=http://www.liuzhidream.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/learn_programing/2018/10/22/Python-threading/Python-threading/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Python-threading</h4>
      </a>
    </div>
  

  
</nav>



    








<section class="comments" id="comments">
    <div id="gitment_thread"></div>
    <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <script>
        var gitment = new Gitment({
            owner: '',
            repo: '',
            oauth: {
                client_id: '',
                client_secret: '',
            },
        })
        gitment.render('comments')
    </script>
</section>










</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/learn_programing/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Liu Zhi &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&title=《Celery》 — VanLiuZhi&pic=http://www.liuzhidream.com/img/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&title=《Celery》 — VanLiuZhi&source=Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.liuzhidream.com/2018/10/22/Web/Celery/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Celery》 — VanLiuZhi&url=http://www.liuzhidream.com/2018/10/22/Web/Celery/&via=http://www.liuzhidream.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.liuzhidream.com/2018/10/22/Web/Celery/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACL0lEQVR42u3aQY6DMAwF0N7/0p1tpSnw7YRKJI/ViJbBrwvLsf16xdf74zq6//np0f3/zyZvmXZhYGA8lvE+vY5eMHIniSGPDQMDYx/GeULMQ5n1A1XfhYGBgZGUcdU7vfdiYGBgjDN6x+BeKYmBgbEbIyngzl+cXHkReeNZHAMD44GMvOv++79vmW9gYGA8itFLlz1qXjiWo8LAwFiakSe45AjaC7qXcDEwMPZhVJv4czHTFsUwMDA2YPQSX7V9n48t89i+VLgYGBhLM86TabXpn6fmaun55VMMDIylGfkD+fpF0kqrLmcUFsswMDCWZvTOhtXiMk/uzaAxMDA2YFTHkPmwM2/nJT/iRcrGwMBYjpE/nI8nk9BHmnoXk1gMDIyFGOcpLD+U3vFUoazEwMBYmjFriDhy+KyOQifsa2BgYDyKMV72VceQ1VWzcmmIgYGxKGNknaLaVkuOpvnPWt4HwcDAeCxj1jFyfGksX93AwMDYh5GHOx5Qb3WjkIgxMDC2YSSlWPL6pHzMkVG0GBgY2zDyQ+ms42h1/BmthWFgYCzKSJr1yT8dWafIR62HmyMYGBjLMXqDgXwMMHK4zRM9BgbG2oxemut9p5eIJww4MTAwlmDkY4C8NBwZTDZjwMDA2IDR27aqDh2rpWchrWNgYGC0DpMjLblyew4DAwMj+E4vUebrHRdpGgMDYwNGkgqrCXFkSJCXmxgYGDsw8nRZLRPzZlmv3MTAwNiA8QeaLfoIGbMmjgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/learn_programing/', SHARE: true, REWARD: false };


</script>

<script src="/learn_programing/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/learn_programing/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
