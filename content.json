[{"title":"element-UI","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/element-UI/","text":"饿了么前端团队出品的Vue UI框架 element UI饿了么前端团队出品的Vue UI框架 from rulesfrom rules 是表单组件中用于在表单验证规则的属性，把rules绑定给一个对象，对象的属性即为需要做验证的字段，属性值为验证规则 12345rules: &#123;type: [&#123; required: true, message: 'type is required', trigger: 'change' &#125;],timestamp: [&#123; type: 'date', required: true, message: 'timestamp is required', trigger: 'change' &#125;]&#125; 对表单的type字段做规则验证，该字段是必须的。 Loading关于 Loading 拥有指令调用，服务调用（在需要的地方手动触发），指令的话就是 v-loading=’true’即可。可以通过修饰符把效果的遮蔽罩覆盖到DOM的body上。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"farmework","slug":"farmework","permalink":"http://www.liuzhidream.com/tags/farmework/"}]},{"title":"ECMAScript","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/ECMAScript/","text":"ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等 ECMAScript6ECMAScript6 是 JavaScript 的第六版本，是一个标准，主要增加了面向对象的支持等 扩展运算符（ spread ）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')] 箭头函数12345678910const Person = &#123; 'name': 'little bear', 'age': 18, 'sayHello': function () &#123; setInterval(function () &#123; console.log('我叫' + this.Person + '我今年' + this.age + '岁!') &#125;, 1000) &#125;&#125;Person.sayHello() 基础语法 (参数1, 参数2, …, 参数N) =&gt; {函数声明} (参数1, 参数2, …, 参数N) =&gt; 表达式（单一） 相当于：(参数1, 参数2, …, 参数N) =&gt;{ return表达式} 当只有一个参数时，圆括号是可选的： (单一参数) =&gt; {函数声明} 单一参数 =&gt; {函数声明} 没有参数的函数应该写成一对圆括号。 () =&gt; {函数声明} 在上面的代码里面，谁调用，this指向谁，所以this指向的是setInterval, 就是window（因为setInterval）是window就注入的函数。 所以在setInterval 上一行，我们可以var self = this此时的this是sayHello 由Person来调用，这样才能得到我们想要的结果。 箭头函数最大特点： 不绑定this 不绑定arguments es6箭头函数，这个是原来定义函数的缩写。let 和原来的 var 类似，var是声明变量，它所处的位置决定了变量的作用域，比如在函数里面就是函数的作用于，在外部就是全局作用域。let也是这样，但是它的位置决定的是最接近的块的作用域，作用域比var更细，除了函数全局外，如果你用在for，if里面，那么在整个函数里面是不可见的。所以可以用let声明作用域更细的变量。 继承理解继承的机制 123function DOG(name)&#123;this.name = name&#125; 这个函数我们称为构造函数，js通过对构造函数使用new 关键字创建实例（构造函数相当于Class），这样我们就从原型对象生产了一个实例对象。 共有属性： 这样创建的实例没有共有属性，于是通过为构造函数设置prototype属性，来让从这个构造函数创建的实例都有共有属性。 这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。 实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。 这个prototype是大家共同引用的，修改它会影响实例。 constructor： 通过构造函数创建的实例，访问这个属性就可以知道实例的构造函数是谁。 cat1 instanceof Cat 判断实例cat1是否是通过构造函数Cat来的，类似python的isinstance。 1234567891011121314156.1 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。 alert(Cat.prototype.isPrototypeOf(cat1)); //true alert(Cat.prototype.isPrototypeOf(cat2)); //true6.2 hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。 alert(cat1.hasOwnProperty(&quot;name&quot;)); // true alert(cat1.hasOwnProperty(&quot;type&quot;)); // false 12prototype constructor__proto__ 普通对象 最普通的对象：有proto属性（指向其原型链），没有prototype属性。 原型对象(person.prototype 原型对象还有constructor属性（指向构造函数对象）)。 函数对象： 凡是通过new Function()创建的都是函数对象。 拥有proto、prototype属性（指向原型对象）。 Function、Object、Array、Date、String、自定义函数。 特例： Function.prototype(是原型对象，却是函数对象，下面会有解释) 如何判断是什么对象 typeof 对象 其实原型对象就是构造函数的一个实例对象。person.prototype就是person的一个实例对象。相当于在person创建的时候，自动创建了一个它的实例，并且把这个实例赋值给了prototype。 早绑定和晚绑定所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。 早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。 另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。 文件导入export default 和 export 区别： export与export default均可用于导出常量、函数、文件、模块等 你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用 在一个文件或模块中，export、import可以有多个，export default仅有一个 通过export方式导出，在导入时要加{ }，export default则不需要 export 12345//a.jsexport const str = \"blablabla~\";export function log(sth) &#123; return sth;&#125; 对应的导入方式： 12//b.jsimport &#123; str, log &#125; from 'a'; //也可以分开写两次，导入的时候带花括号 export default 123//a.jsconst str = \"blablabla~\";export default str; 对应的导入方式： 12//b.jsimport str from 'a'; //导入的时候没有花括号 Object.assignObject.assign({}, row) 拷贝对象 import和require的区别node编程中最重要的思想就是模块化，import和require都是被模块化所使用。 遵循规范 require 是 AMD规范引入方式 import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，所以必须放在文件开头 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require 引用同级文件 a.js，b.js 都在一起，应该 import ./b 不要直接 import b 1，给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）2，等同于在自组件中： 子组件内部处理click事件然后向外发送click事件：$emit(“click”.fn)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"}]},{"title":"jQuery","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/jQuery/","text":"javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了 jQuery 方法javascript封装，快速编写前端代码，不过在MVVM框架的势头下，jQuery慢慢的不再需要了 each( )如果是去迭代数组 类似 Inpute标签组成的 a:1,b:2： 使用 $.each(对象，function（index,value）{ }); 这样可以拿到数组的键和值 如果是迭代元素 类似p标签的集合： 使用 $(&quot;p&quot;).eache(function(index){ }); 在函数中，使用this得到当前迭代的元素 is()is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。 parseFloat()解析一个字符串，并返回一个浮点数，参数必须且是一个字符 该函数先去判断第一个字符串是否是数字，不是，函数返回 NaN，是，继续执行。如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。 NaN 属性是JS的Number对象，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。比如月份用数字5代表5月份，var number=5; number.NaN,number现在就不是数字了。 isNaN() 该一个要检测的参数（必须）看是不是NaN，是就返回True 其它值返回False。 parseInt() 函数可解析一个字符串，并返回一个整数。 indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。即索引值。 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 othertext（）用来设置或返回值，val()返回value的值 attr() 方法设置或返回被选元素的属性值。该方法不同的参数会有不同的效果 attr(“id”,123) 选择器得到的JQuery对象的attr方法，将对象的id 改变为 “123”（没有id直接添加一个id） appendto() append() append() 方法在被选元素的结尾（仍然在内部）插入指定内容。提示：append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容的位置和选择器。例子： 123456p标签原来的内容 &lt;p&gt;This is a paragraph.&lt;/p&gt;$(&quot;p&quot;).append(&quot; &lt;b&gt;Hello world!&lt;/b&gt;&quot;); 执行方法后 This is a paragraph. Hello world!$(&quot;&lt;b&gt; Hello World!&lt;/b&gt;&quot;).appendTo(&quot;p&quot;);p标签原内容和执行结果同上。 find（）方法 由给定表达式去匹配满足条件的后代元素，返回jquery对象。 1var b=$(\"#id\").find('[name=id]'); window.location.href=”url” 当前页面打开URL 当点击元素时，会发生 click 事件。 当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click。 click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数。 on 为元素绑定事件，比如click事件，然后加个函数，这个元素点击后就会去执行这个函数。 html()jquery渲染页面方法，$.html() 对dom执行html方法，会将dom的内容给替换了，比如 &lt;div class=123&gt;&lt;/div&gt; 对这个dom执行方法html(&lt;p&gt;123&lt;/p&gt;) 结果是&lt;div class=123&gt;&lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 元素切换sildeup sildedown，show hide 元素切换隐藏 jQuery遍历 siblings：dom.siblings(.class).addClass() 对选择对象执行遍历，找到所有class类，并给他们添加样式。 scroll()dom调用，可以在滚动条滚动的时候触发，只要有滚动就触发。这里注意如果逻辑涉及到滚动的数值判断，使用比较不要使用相等，因为滚动很快，相关的判断不一定每次执行到。 样式直接写在dom上，相当于 style : dom.css(&#39;color&#39;, &#39;red&#39;) hasClass() addClass() removClass() 对dom类的控制","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"}]},{"title":"git-command","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Git/git-command/","text":"Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git使用GitHub，给出的地址我们一般用ssh。使用ssh需要https，如果不支持只能使用http，但是每次都要输口令。 分支Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch \\ 切换分支：git checkout \\ 创建+切换分支：git checkout -b \\ 合并某分支到当前分支：git merge \\ 删除分支：git branch -d \\ 主要理解分支，克隆远程仓库，将本地和远程仓库关联，搭建git服务器 git pull 命令作用：取回远程主机某个分支的更新，再与本地的指定分支合并 格式：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果与当前分支合并，则可省略本地分支名git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 相当于：git fetch &lt;远程主机名&gt; &lt;远分支名&gt; git merge &lt;远程主机名&gt;/&lt;远程分支名&gt; 如果当前分支与远程分支存在追踪关系 git pull &lt;远程主机名&gt; 如果当前分支只有一个追踪关系 git pull 手动建立追踪关系 git branch –set-upstream master origin/next 清理远程已删除本地还存在的分支 git fetch –prune origin 或者 git fetch -p 或者 git pull -p 如何上传GitHub 在用户目录下 .ssh ssh-keygen -t rsa -C “1441765847@qq.com“ 把 id_rsa.pub 添加到GitHub的ssh上 git init 把当前目录变为仓库 git add 把文件添加进仓库 git commit 把文件提交到仓库 git add –all 当我们在一个不是空目录下init需要把所有文件添加到仓库的时候使用 文件的标记解释：A: 你本地新增的文件（服务器上没有）. C: 文件的一个新拷贝. D: 你本地删除的文件（服务器上还在）. M: 文件的内容或者mode被修改了. R: 文件名被修改了。 T: 文件的类型被修改了。 U: 文件没有被合并(你需要完成合并才能进行提交)。 X: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)。 git pull git pull origin master git pull origin master –allow-unrelated-histories git的hook(钩子)为了防止一些不规范的代码 commit 并 push 到远端，我们可以在 git 命令执行前用一些钩子来检测并阻止。在node中，安装需要的模块：husky, pre-commit 配置package.json在提交代码前执行自定义的脚本。 12cd .git/hooksls -l 该目录提供了git的各个钩子的脚步案例。","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"linux","slug":"linux","permalink":"http://www.liuzhidream.com/tags/linux/"}]},{"title":"npm","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/npm/","text":"npm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，是在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。 npmnpm是node的包管理工具，不建议使用任何第三方的工具，也不建议换源，这些操作解决一时问题也带来其它问题。关于网络问题，实在不行用手机热点，如果你们公司的网络都下不了，那公司不用待了。第三方工具也是，开始npm确实比不上第三方工具，不过现在渐渐好多了，官方也意识到这些问题了。 全局和局部一般在全局安装的是工具，比如webpack，这样这些工具在构建项目或者执行项目的命令的时候由于是全局任何地方都能使用，而局部就是装模块的，这些模块可能因为依赖关系，你最好不要在全局装模块，如果你的项目引用全局模块，多个项目的时候，可能依赖不一样，这样你去更新全局模块的时候就可能由于依赖的问题影响其它项目了。 命令 Command Description npm list -g –depth 0 查看全局安装包 npm install packagename -g 全局安装 npm uninstall package -g 全局卸载 npm install pg –save 项目依赖安装 npm install pg –save-dev 项目非依赖安装 npm view jquery versions 查看模块版本号，这里举例的是jQuery","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://www.liuzhidream.com/tags/Nodejs/"}]},{"title":"JavaScriptUtil","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScriptUtil/JavaScriptUtil/","text":"常见的JavaScript 相关设计 JavaScript 相关设计常见的JavaScript 相关设计 自定义遮蔽罩使用了jQuery-WeUI，需要根据情况做调整 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--自定义遮罩层--&gt;&lt;div id=\"bg\" class=\"weui-mask weui-mask--visible\" style=\"display: none;opacity: 1;visibility: visible;z-index: 100\"&gt;&lt;/div&gt;&lt;!-- 简单示例 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;html 最简遮罩层&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function showDiv() &#123; document.getElementById('popDiv').style.display = 'block'; document.getElementById('bg').style.display = 'block'; &#125; function closeDiv() &#123; document.getElementById('popDiv').style.display = 'none'; document.getElementById('bg').style.display = 'none'; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"popDiv\" style=\"z-index:99;display:none;position:absolute;margin-top: 20%;margin-left: 40%;background-color: #FFF;\"&gt;html 最简遮罩层&lt;br/&gt;html 最简遮罩层&lt;br/&gt; &lt;a href=\"javascript:closeDiv()\"&gt;关闭遮罩层&lt;/a&gt;&lt;/div&gt;&lt;div id=\"bg\" style=\"display:none;background-color: #ccc;width: 100%;position:absolute;height: 100%;opacity: 0.5;z-index: 1;\"&gt;&lt;/div&gt;&lt;div style=\"padding-top: 10%;padding-left:40%;z-index:1;\"&gt; &lt;input type=\"Submit\" name=\"\" value=\"打开遮罩层\" onclick=\"javascript:showDiv()\"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"Util","slug":"Util","permalink":"http://www.liuzhidream.com/tags/Util/"}]},{"title":"nvm","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/nvm/","text":"nvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。 nvmnvm 是 node的环境管理工具，可以同时安装多个node版本，具体实现是通过修改环境变量切换到对应的node上，不同的node版本拥有独立的包文件。 安装Mac 下安装使用github提供的脚本安装，安装完成添加对应shell的配置 nvm 使用brew安装会有一些小问题 正确的安装和使用nvm(mac) 1234export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\"# This loads nvm bash_completion github 地址 https://github.com/creationix/nvm/blob/master/README.md 命令 Command Description nvm install stable 安装最新稳定版 nvm install \\ 安装指定版本，可模糊安。如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4 nvm uninstall \\ 删除已安装的指定版本，语法与install类似 nvm ls 列出所有安装的版本 nvm ls-remote 列出所有远程服务器的版本（官方node version list） nvm current 显示当前的版本 nvm alias \\ \\ 给不同的版本号添加别名 nvm unalias \\ 删除已定义的别名 nvm reinstall-packages \\ 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://www.liuzhidream.com/tags/Nodejs/"}]},{"title":"node","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/node/","text":"服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端 node.js服务端的javascript，Nodejs是一个Javascript运行环境(runtime environment)，让js可以运行在服务端 webpackwebpack把多种静态资源转换成一个静态文件 @ 的含义在webpack的配置中 1234567resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), &#125;&#125; 这样在需要导入组件的时候使用 import A from &#39;@/components/a.vue&#39; 就是给复杂了引用路径做个别名。 修改编译路径编译路径修改（由于存在编译出来的文件相互依赖的，而你只导入其中几个，依赖就出问题了，为了不修改后端代码，修改通用编译路径是不错的解决方案） 12345assetsRoot: path.resolve(__dirname, '../static/dist'),assetsSubDirectory: '',assetsPublicPath: '/static/dist/',productionSourceMap: false, Babel一个转码器，将es6转es5，这个东西何用？node.js直接执行es6代码还存在问题，听说最新版本可以了。所以用es6来写js，这样可以利用它的新特性，然后转码，这样node.js就可以运行了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://www.liuzhidream.com/tags/Nodejs/"}]},{"title":"RESTFulAPI","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/RESTFulAPI/","text":"一种接口风格，使用一种通用的风格，在团队开发中，也便于沟通。 RESTful API使用一种通用的风格，在团队开发中，也便于沟通。 概念REST风格5个约束：客户端-服务端，无状态，缓存，统一接口，分层系统 使用名词表示资源，动词通过HTTP方法来实现，比如删除资源使用DELETE方法。 关注请求头，比如请求头Accept要求返回application/xml，如果服务器只能放回json格式的，应该返回406错误。 使用正确的请求方法和状态码 不能一味的使用POST和GET方法，HTTP方法表 Name Description OPTIONS 用于获取资源支持的所以HTTP方法 HRAD 用于只获取请求某个资源返回的头信息 GET 用于从服务器获取某个资源的信息：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被请求的资源详细信息 POST 用于创建新资源：1.创建完成后，返回状态码201 Created 2.完成请求后，需要返回被创建的资源详细信息 PUT 用于完整的替换资源或者创建指定身份的资源：1.如果是创建了资源，则返回201 Created 2.如果是替换了资源，则返回200 OK PATCH 用于局部更新资源：1.完成请求后，返回状态码200 OK 2.完成请求后，需要返回被修改的资源详细信息 3.完成请求后，需返回被修改的资源详细信息 DELETE 用于删除某个资源，完成请求后返回状态码204 No Content 对输出结果不在封装：通过状态码来判断请求，不应该把信息写在响应体中","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"python","slug":"python","permalink":"http://www.liuzhidream.com/tags/python/"}]},{"title":"Nginx","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/Nginx/","text":"Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。 NginxNginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。 配置nginx的配置, 一般就是配server模块，该模块的全局定义，location 定义了正则的解析（向服务器请求各种资源，nginx应该如何处理）","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"linux","slug":"linux","permalink":"http://www.liuzhidream.com/tags/linux/"}]},{"title":"Redis","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/Redis/","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 RedisREmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Database NumberRedis 使用 DB number 实现类似关系型数据库中 schema 的功能。不同 DB number 表示的数据库是隔离的，但是目前只能使用数字来表示一个数据库，Ubuntu 默认的配置文件配置了16个数据库，DB number 是从0开始的，并且默认连接0号数据库。 redis-cli -n &lt;dbnumber&gt; 连接指定数据库 在docker中使用Redis","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"python","slug":"python","permalink":"http://www.liuzhidream.com/tags/python/"},{"name":"database","slug":"database","permalink":"http://www.liuzhidream.com/tags/database/"}]},{"title":"RabbitMQ","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/RabbitMQ/","text":"MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。 RabbitMQMQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。 概念需要了解一个协议：AMQP协议，协议的流程由消息发布者，交换机，队列，到消息订阅者。交换机做路由分发，将收到的消息根据路由规则分发给绑定的队列。 消息：消息实际包含两部分内容，1是有效载荷，就是要传输的数据，数据类型可以是纯文本或JSON。2是标签，它包含交换机的名字和可选的主题(topic)标记等，AMQP仅仅描述了标签，而RabbitMQ决定了把这个消息发给哪个消费者。 发布者：也就是生产者，创建消息并设置标签 消费者：消费者连接到代理服务器上，接受有效载荷，消费者不需要消息中的标签 消息投递失败会重发，保证消息正确取出和执行，AMQP模块包含了消息确认的概念，在收到消费者的确认回执前，消息代理不会将消息从队列中删除。 交换机交换机拿到消息后，将路由给队列，使用哪种路由算法是由交换机类型和被称作“绑定（queue_bind）”的规则决定的。 可配置的队列如下： 直连交换机（direct exchange） 根据消息携带的路由键(routing key)将消息投递给对应的队列。将一个队列绑定到某个交换机的同时赋予该绑定一个路由键，当一个携带者路由键为XXX的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为XXX的队列。直连交换机用来处理消息的单播路由。 主题交换机（topic exchange） 通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机通常用来实现消息的多播路由。发送到主题交换机的消息的路由键，必须是一个由 “.” 分隔的词语列表，这些词语应该和对应的业务关联，词语的个数可以随意，但是不要超过255字节。绑定键支持通配符：“*” 用来表示一个单词；“#” 用来表示任意数量(零个或多个)单词。 扇形交换机（fanout exchange） 将消息路由给绑定到它身上的所有队列，且不理会绑定的路由键。用来做消息的广播路由。它允许你对单条消息做不同的处理，在开发中一个操作可能要多个连带工作，比如用户创建一篇新的日记，需要更新用户的创建日记数，清除相关缓存，给关注这个用户的其他用户推消息，日记进审核后台，日记进最新日记池等等。可以使用扇形交换机把一个消息分发给多个任务队列，执行不一样的工作。尤其是业务改变时，使用扇形交换机直接为新的消费者添加声明，并绑定进来就可以了，否则需要修改发送方的代码来添加接收方。所以，使用扇形交换机可以有效地解耦发送者和消费者。 头交换机（headers exchange） 允许匹配AMQP的头而非路由键，其实使用起来和直接交换机差不多，但是性能却差很多，一般用不到这种类型。 虚拟主机通过创建新的虚拟主机，实现隔离，不同的虚拟主机直接完全隔离，拥有自己的队列，绑定和交换机。就像创建了一个新用户，服务A做订单的，链接对应的虚拟主机，服务B做消息推送的，链接对应的虚拟主机。默认是虚拟主机是 /，使用guest做默认用户和密码，通过命令创建新的虚拟主机： 123sudo rabbitmqctl add_user dongwm 123456sudo rabbitmqctl add_vhost web_developsudo rabbitmqctl set_permissions -p web_develop dongwm \".*\" \".*\" \".*\" rabbitmqctl set_permissions 是配置权限，三个对应的权限是：配置（队列和交换的创建和删除）、写（发布消息）、读（消费消息）的权限。 常用命令 sudo rabbitmqctl list_vhosts sudo rabbitmqctl list_queue -p web_develop sudo rabbitmqctl list_users","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"}]},{"title":"web相关","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/other/","text":"web相关学习笔记 web相关web相关学习笔记 网络网关和路由器最大的区别是是否连接相似的网络。如果连接相似的网络，则称为路由器。而连接不相似的网络，称为网关。（个人认为这个关字可以从海关上来理解，出关，海关） 相似的网络和不相似的网络有两种不同的含义。 逻辑层面： 相似的网络：如果都是互联网上的两个网络，我们称为相似的网络。不相似的网络：如果一个是私网，一个是公网。我们称为不相似的网络。 物理层面： 相似的网络：都是以太网或者同一种介质的网络。不相似的网络：一边是以太，一边是SDH或者ATM等 子网（Sub-net）出口路由器就叫网关了，后面还有很多中继路由器。所以网关一定是路由器，但路由器不一定用来做网关 TTL Time to live 域名解析在DNS服务器中存留时间 实际指转发的最大跳数，主机发送ip包的时候，在网络中转发，转发一次该值减1，为了防止无限转发和循环而设置这个值。如果变成1还没到目标地址，即为超时。 内网映射","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"}]},{"title":"http-protocol","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/http-protocol/","text":"超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 http actionHTTP协议中GET、POST和HEAD的介绍 2008-05-10 14:15 Name Description GET 请求指定的页面信息，并返回实体主体。 HEAD 只请求页面的首部。 POST 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 OPTIONS 允许客户端查看服务器的性能。 TRACE 请求服务器在响应中的实体主体部分返回所得到的内容。 PATCH 实体中包含一个表，表中说明与该URI所表示的原内容的区别。 MOVE 请求服务器将指定的页面移至另一个网络地址。 COPY 请求服务器将指定的页面拷贝至另一个网络地址。 LINK 请求服务器建立链接关系。 UNLINK 断开链接关系。 WRAPPED 允许客户端发送经过封装的请求。 Extension-mothed 在不改动协议的前提下，可增加另外的方法。 三次握手，四次挥手三次握手：A向B发起连接，B收到，回一个给A，A也收到，连接确定 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据。 建立连接是三次握手，释放连接是四次挥手（关闭连接） 第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。 第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。 第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。 第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。 状态码 Name Description 2xx 成功 3xx 重定向 4xx 客户端问题 5xx 服务端问题 get 和 post get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 建议：1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"http","slug":"http","permalink":"http://www.liuzhidream.com/tags/http/"}]},{"title":"Vue","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/Vue/","text":"Vue是MVVM框架，一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。 Vue一个不错的“简书”入门 image 基本 在通过ajax获取到数据需要赋值到data里面的时候，如果是不可变变量，可以直接赋值，但是如果是arrey，需要迭代每个值，加到data中。Ajax.data.forEach(function(val, index){ vue.data.push(val) })。 vue:在html中传递 this ，在vue中this都是指向vue的组件，如果我们想使用原本的this指向这个dom,需要这样使用dofunc($event)。在函数里面 dofunc(v){ v.target }。如果转换为 jQuery 对象 $(v.target) vue:由于dom是由js去渲染的，所以你在渲染的时候去操作dom，是选不到的。这里涉及到了vue的生命周期的问题，实例创建完毕(挂载)，再去渲染dom。 vue:template不会渲染成元素，用div的话会被渲染成元素。把if,show,for等语句抽取出来放在template上面，把绑定的事件放在temlpate里面的元，可以使html结构更加清晰，还可以改善一个标签过长的情况。 注册指令：全局注册，在new vue同块写Vue.directive局部注册，当前组件使用，作为vue实例的一个属性 directives 多了个 S注册组件也是如此，和指令类似 在vue实例中的选择基本都是可以在组件里面使用的（vue实例怎么写组件就怎么写），但是data必须是函数，如果是一般的对象，你在组件里面使用这个对象会报错 单页面的VUE实例只有一个，组件化开了，要想从实例拿到data，只能是组件props向下传递，记得绑定想要的数据在你的模板上。向上使用events props data 是驼峰命名，绑定数据的写法 &lt;child :msg-a=&quot;msgA&quot;&gt;&lt;/child&gt; v-bind=&quot; a &quot; 使用绑定，外部的引号不是想表达这个是个字符串，它应该当成一个变量，这也是在绑定url的时候，我们可以使用变量加上字符串，其中的字符串就用单引号。 props: 单项流数据，从父组件流向子组件，子组件试图修改它会报错，如果你要用它，应该把这个值给data，定义局部变量的方法。如果data是可变类型的，在子组件中修改了是会影响到父组件的。 props:验证，可以验证流进来的数据。验证在这个组件实例创建之前，所以你不能把这个组件里面的 option 诸如 data methods用在验证里面。 插槽：组件嵌套的时候使用，定义了如何进行内容分发 组件实例的作用域是孤立的 vue:自定义组件命名不要命名常见的（怕和框架冲突） 给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 .native 修饰符）。等同于在自组件中：子组件内部处理click事件然后向外发送click事件：$emit(&quot;click&quot;.fn) 字符串模板和非字符串模板123&lt;script id=\"component1\" type=\"x-template\"&gt;&lt;/script&gt; 在实例中option使用 template 会把挂载元素的内容替换掉，在组件中 option 使用 template是HTML元素扩展被替换的内容，很像，都是替换。 实例的模板字符串，执行元素的时候，此时元素应该是template标签或者 script type=x-template 都是把这两个的内容替换到实例挂载的元素上。 指令vue指令类似 v-model 可以自定义指令，在创建实例的时候声明即可 目前的vue架构，对于一个vue文件来说，在里面使用其它组件（就是引用的各种组件），那么这些组件对于当前vue文件来说就是子组件，当前vue文件是父组件。这在理解一些概念的时候会有用，比如子组件 双向绑定值 使用 sync 来修饰，把子组件的某个属性绑定到父组件上，做到双向绑定。 Command Description v-bind 动态绑定数据。简写为“:” =&gt; 以后的:class=”{red:boolean}” v-on 绑定时间监听器。简写为“@”，例：@click=”xxx” v-text 更新数据，会覆盖已有结构。类似 { {msg} } v-show 根据值的真假，切换元素的display属性 v-if 根据值的真假，切换元素会被销毁、重建；=&gt; 在dom中已消失 v-else-if 多条件判断，为真则渲染 v-else 条件都不符合时渲染 v-for 基于源数据多次渲染元素或模块 v-model 在表单控件元素（input等）上创建双向数据绑定（数据源） v-pre 跳过元素和子元素的编译过程 v-once 只渲染一次，随后数据更新也不重新渲染 v-cloak 隐藏未编译的Mustache语法，在css中设置[v-cloak]{display:none;} 交互命令 Command Description vue cli 主要功能就是创建vue工程 vue init webpack myproject 构建vue项目 ref 和 $refsref 这个通常在元素上使用（组件自定义的元素也可以），比如现在有个组件 &lt;my-component&gt;&lt;/my-component&gt; 使用ref &lt;my-component ref=&#39;new-name&#39; attr-a=&#39;hello&#39;&gt;&lt;/my-component&gt; 在 js 中 this.$refs[&#39;new-name&#39;].attr // res hello 就可以通过别名获取到元素，并且拿到元素对应的属性。 补充： 利用ref属性可以获取到dom元素或者是子组件，从而可以调用子组件的方法（注意2.0版本用ref取代了el） 当ref直接定义在dom元素上时，则通过this.$refs.name可以获取到dom对dom进行原生的操作 &lt;div class=&quot;foods-wrapper&quot; ref=&quot;foods-wrapper&quot;&gt; 通过 this.$refs 获取到dom进行操作（注意ref属性的命名不能用驼峰，同时获取的时候也是） let menuList=this.$refs[&#39;menu-wrapper&#39;].getElementsByClassName(&#39;menu-list-hook&#39;); 此处如果用 this.$refs[&quot;menuWrapper&quot;] 将获取不到元素 通过在引用的子组件上使用ref属性实现父组件调用子组件的方法以及属性 在父组件中引用子组件并定义ref &lt;v-food ref=&quot;selectfood&quot;&gt;&lt;/v-food&gt; 调用定义在子组件中的方法show this.$refs.selectfood.show(); 同时也可以调用子组件中的属性 声明下上面说的是vue 2.0的 templatetemplate是html5的一个新元素，主要用于保存客户端中的内容，表现为浏览器解析该内容但不渲染出来，可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。 slot 插槽模板和非插槽模板非插槽模板指的是html模板，比如 div、span、ul、table 这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制。 插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置确由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。 一般的用法就是在子组件里面： 12345678910111213141516&lt;!-- 子组件名称：&lt;children&gt; --&gt;&lt;template&gt; &lt;div&gt; &lt;solt&gt;&lt;/solt&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 父组件是这样的 --&gt;&lt;template&gt; &lt;children&gt; &lt;span&gt;被插入的内容，这整个span便签都会替换子组件中的solt&lt;/span&gt; &lt;children/&gt;&lt;/template&gt; 这就是匿名插槽或叫做具名插槽，就是 &lt;span solt=&#39;name&#39;&gt; &lt;/span&gt; 在父组件上为要插入的内容取个名字，子组件&lt;solt name=&#39;name&#39;&gt;&lt;/solt&gt; 这样来和父组件对应起来。 作用域插槽：这个概念比较难理解，先看怎么用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 父组件： --&gt;&lt;template&gt;&lt;div class=\"father\"&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;!--第一次使用：用flex展示数据--&gt; &lt;child&gt; &lt;template slot-scope=\"user\"&gt; &lt;div class=\"tmpl\"&gt; &lt;span v-for=\"item in user.data\"&gt;&#123; &#123;item&#125; &#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第二次使用：用列表展示数据--&gt; &lt;child&gt; &lt;template slot-scope=\"user\"&gt; &lt;ul&gt; &lt;li v-for=\"item in user.data\"&gt;&#123; &#123;item&#125; &#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第三次使用：直接显示数据--&gt; &lt;child&gt; &lt;template slot-scope=\"user\"&gt; &#123; &#123;user.data&#125; &#125; &lt;/template&gt; &lt;/child&gt; &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt; &lt;child&gt; 我就是模板 &lt;/child&gt;&lt;/div&gt;&lt;/template&gt;&lt;!-- 子组件： --&gt;&lt;template&gt; &lt;div class=\"child\"&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 作用域插槽 &lt;slot :data=\"data\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data: function()&#123; return &#123; data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba'] &#125; &#125;&#125; 可以看到，子组件写法是 &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt; 把数据绑定给data属性，而且数据的来源是子组件，这点就很重要了。 在父组件会这么写： 1234&lt;template slot-scope=\"scope\"&gt; &lt;span&gt;&#123; &#123;scope.row.id&#125; &#125;&lt;/span&gt;&lt;/template&gt; 此时通过scope就可以拿到子组件绑定的data了，这个scope可以随便写。 在什么时候会用到呢？由于做研发比较少，但是用框架的时候你就要知道这种写法，通常会对子组件绑定父组件的数据，子组件拿到父组件的时候后，做了处理，得到自己的 data 就是上面插槽绑定的 data 这个时候你就可以去这个里面拿一些你像要的数据了。 像element UI 的table组件，通过给组件list数据，在 el-table-column 组件里面用作用域插槽就可以拿到赋值给list也就是表格的数据。 this.$nextTick在vue中，当页面加载完成以后，dom还没有加载，是无法获取进行操作的，但是在vue2.0中提供了一个方法 this.$nextTick，在这个回调函数里面写dom操作即可，如下代码： 12345created() &#123; this.$nextTick(() =&gt; &#123; //do somthing&#125;); 其实这里还有一个小技巧，就是用settimeout(fn,20),来取代this.$nextTick,（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。 现在vue都快要到3.o了，不要使用settimeout了，在使用 this.$nextTick 如果失败了，很可能是生命周期相关问题没处理好。 路由跳转当我们需要跳转一个页面的时候，既然是单页面应用，可以使用路由会很方便，比如带很多的参数过去。如果是普通的url跳转只能在url里面带参数，限制较大 比如我们的跳转由方法来处理 @click=&quot;getDescribe(article.id)&quot; 方法内容(三种情况)： 123456789101112131415161718192021222324252627282930&lt;!-- 情况1.基本使用 --&gt;this.$router.push(&#123; path: `/describe/$&#123;id&#125;`,&#125;)&lt;!-- 路由配置 --&gt;&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125;&lt;!-- 情况2.通过路由配置的name来匹配 --&gt;this.$router.push(&#123; name: 'Describe', params: &#123; id: id &#125;&#125;)&lt;!-- 情况3.通过path来匹配 --&gt;this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125;&#125;) 方案2要优雅的多，可以在params中传递参数，这里的id用来做路由传参了。 在子组件中通过 $route.params 获取到参数。方案3为 $route.query 就是获取 $route 对象的属性了。 运用：通过方法查询接口，返回数据由路由来响应，把参数都传给子组件，子组件通过在created生命周期中 this.$route 获取传递给子组件的参数。 v-html 与 深度作用选择器vue 使用v-html指令渲染的页面样式处理问题 由于是动态加载的页面，在style中写的class不会作用于v-html渲染的内容，作者给出的解决方案是给外层容器加个类名, 然后用后代选择器，css的选择器可以是类选到类 .classA .classB， 选择元素的 .classA a (选择a标签) .classA &gt; a 只对一代a标签作用。直接这样写还不行，需要深度作用选择器 .classA &gt;&gt;&gt; a。 有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 操作符取而代之——这是一个 &gt;&gt;&gt; 的别名，同样可以正常工作。 总结：在使用指令的便签上加个类，用这个类选择后代（注意要用深度作用选择器）这样就可以解决问题了。 1234567&lt;div class='myclass' v-html='content'&gt;&lt;/div&gt;&lt;style&gt; .myclass /deep/ a&#123; font-size: 10px &#125;&lt;/style&gt; 或者在被渲染的Html里面加style（没有测试过，感觉是可行的） 子组件向父组件传递事件子组件向父组件传递事件，通常用来实现子组件向父组件传递值，然后调用父组件的方法 在子组件中对某个标签绑定点击事件 v-on:click=&quot;$emit(&#39;click_event&#39;, data.guid)&quot; 这样在父组件中我们可以监听这个事件，&lt;article-classify v-on:click_event=&quot;classifyHandler&quot;&gt;&lt;/article-classify&gt; 方法 classifyHandler 会接受传递的参数，也就是 data.guid，这样我们就拿到子组件传递来的参数了，然后后面的逻辑也就可以去跟着执行方法","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"framework","slug":"framework","permalink":"http://www.liuzhidream.com/tags/framework/"}]},{"title":"JavaScript","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/JavaScript/javascript/","text":"javascript学习笔记 JavaScript 笔记javascript学习笔记 DOM对象DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;复制代码 代码如下: 12var domObj = document.getElementById(\"id\"); //DOM对象var $obj = $(\"#id\"); //jQuery对象; jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例: $(“#foo”).html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法; 上面的那段代码等同于: document.getElementById(“foo”).innerHTML;$(“#foo”).innerHTML 是错误的 可以将jquery 和 dom 对象互相转换，这样dom对象就可以使用jquery的方法了，jquery对象亦如此。 Json 方法JSON.stringify(a) stringify()用于从一个对象解析出字符串 JSON.parse(str) parse用于从一个字符串中解析出json对象 取得url中get请求的参数12345function getUrlParam(name)&#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return decodeURI(r[2]); return null;&#125; ready 和 onload事件页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页 面包含图片等文件在内的所有元素都加载完成。(可以说：ready 在onload 前加载！！！) 一般样式控制的，比如图片大小控制放在onload 里面加载。 关键字JavaScript 关键字必须以字母、下划线（_）或美元符（$）开始。 后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开关键字和数字）。 image BOM &amp; DOM BOM是浏览器对象模型，用来获取或设置浏览器的属性、行为，例如：新建窗口、获取屏幕分辨率、浏览器版本号等。 DOM是文档对象模型，用来获取或设置文档中标签的属性，例如获取或者设置input表单的value值。 BOM的内容不多，主要还是DOM。 字面量，变量有时候会遇到字面量的概念，它和变量对应，字面量就是固定值的表示法。 异常js也有异常，不过很少见人使用。 123456789101112131415161718192021222324252627282930&lt;html&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script&gt; function myFunction() &#123; try &#123; //错误判断 var x = document.getElementById(\"demo\").value; if (x == \"\") throw \"值为空\"; if (isNaN(x)) throw \"不是数字\"; if (x &gt; 10) throw \"太大\"; if (x &lt; 5) throw \"太小\"; &#125; catch (err) &#123; //发生错误时在此执行，err为自定义错误 throw 对应的值， var y = document.getElementById(\"mess\"); y.innerHTML = \"错误：\" + err + \"。\"; &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;h1&gt;我的第一个 JavaScript&lt;/h1&gt; &lt;p&gt;请输出一个 5 到 10 之间的数字:&lt;/p&gt; &lt;input id=\"demo\" type=\"text\"&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;测试输入&lt;/button&gt; &lt;p id=\"mess\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 函数函数的定义方式大体有以下两种，浏览器对于不同的方式有不同的解析顺序。 12345678//“定义式”函数定义function Fn1()&#123;alert(\"Hello World!\");&#125;//“赋值式”函数定义var Fn2 = function()&#123;alert(\"Hello wild!\");&#125; 快速测试一段代码的执行时间123console.time('test')/* 这里运行待测代码 */console.timeEnd('test') 对象总结对象 javascript 对象 123JS Array JS Boolean JS Date JS Number JS String JS RegExp JS Functions JS Events JS Math 其它对象 12Browser Window Navigator Screen History Location Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript 中，Window 对象是全局对象，所有的表达式都在当前的环境中计算。也就是说，要引用当前窗口根本不需要特殊的语法，可以把那个窗口的属性作为全局变量来使用。 HTML DOM 对象 每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 Element 节点，文本节点，元素节点等。 Attribute 属性； Event 事件； HTML 对象； 标签即是HTML对象，标签和元素的区别，属性的定义： 比如&lt;p&gt;这就是一个标签； &lt;p&gt;这里是内容&lt;/p&gt;这就是一个元素， 也就是说元素由一个开始的标签和结束的标签组成，用来包含某些内容。 属性： 为HTML元素提供各种附加信息的就是HTML属性，它总是以”属性名=属性值”这种名值对的形式出现，而且属性总是在HTML元素的开始标签中进行定义。 节点的作用： 在有了标签，元素，属性后，引申出节点的概念，标签的元素中可能会有更多的元素，将多个或一个元素看作节点，节点就是为了去操作元素的。 virtual DOM一些理解： 虚拟DOM，是一个模拟DOM数的js对象。 就是当我们需要更改DOM的时候，如果用原始方法比较慢，这在多节点的页面中体现就更明显了，原因是dom设计的复杂，所以我们用一个虚拟的DOM，虚拟的DOM记录了要更改的DOM，它通常不是立刻执行的，等到需要的时候，计算最小的执行，把执行更新到DOM上。这里为什么会有最小的DOM执行，是应为不是所有的地方都需要变更。 总结：virtual DOM 通过计算最小的DOM执行，能更快的渲染DOM。 别人的讲解： Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。 React 主要的目标是提供一套不同的, 高效的方案来更新 DOM.不是通过直接把 DOM 变成可变的数据, 而是通过构建 “Virtual DOM”, 虚拟的 DOM, 随后 React 处- 理真实的 DOM 上的更新来进行模拟相应的更新。 引入额外的一个层怎么就更快了呢? 那不是意味着浏览器的 DOM 操作不是最优的, 如果在上边加上一层能让整体变快的话?是有这个意思, 只不过 virtual DOM 在语义上和真实的 DOM 有所差别.最主要的是, virtual DOM 的操作, 不保证马上就会产生真实的效果.这样就使得 React 能够等到事件循环的结尾, 而在之前完全不用操作真实的 DOM。在这基础上, React 计算出几乎最小的 diff, 以最小的步骤将 diff 作用到真实的 DOM 上。批量处理 DOM 操作和作用最少的 diff 是应用自身都能做到的.任何应用做了这个, 都能变得跟 React 一样地高效。但人工处理出来非常繁琐, 而且容易出错. React 可以替你做到。 前面提到 virtual DOM 和真实的 DOM 有着不用的语义, 但同时也有明显不同的 API。 DOM 树上的节点被称为元素, 而 virtual DOM 是完全不同的抽象, 叫做 components。 component 的使用在 React 里极为重要, 因为 components 的存在让计算 DOM diff 更高效。 简单的说就是： 当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。 React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 indexOf数组过滤。indexOf作用是返回字符串第一次出现在给定字符串的index，可以用来处理某个字符串有没有在给定字符串中。 给定 str.indexOf(某个字符串) = 0 说明第一个就匹配到，这个给定字符串。如果是空格分隔的，如几个单词，那么结果就不一定是0了，因为会在后面的位置。记住是给定来调用这个方法就行了 补充： js array indexOf 参数是对象的时候，不一定能返回对应位置的index(有的时候可以，我查了资料，有人是这么说的：让数组去判断一个新创建的对象，所以会得到 -1。我在vue中，把循环出来的元素做为参数去在原数组中判断，是可以的，不是循环出来的对象，虽然对象和数组元素字面看起来一摸一样，但是不行，猜测这和底层有关) 所以这个东西的使用，要很小心推荐使用 Array.findIndex() findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 123456789var array1 = [5, 12, 8, 130, 44];function findFirstLargeNumber(element) &#123; return element &gt; 13;&#125;console.log(array1.findIndex(findFirstLargeNumber));// expected output: 3 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 123456789var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123;return element &gt; 10;&#125;);console.log(found);// expected output: 12 通过find，findIndex可以完成很多的事情，少用通过各种方法获取索引，然后再去 array[index]。find就可以了 更详细的使用查看文档。文档地址 我发现这个从列表中给出来的数据，你不段的引用，其中一个引用改了，也会影响到原数组。 格式化字符串1`a$&#123;var&#125;` 如果var是1，result 为 a1。注意两边的符号为tab键上面的 bject.keys(obj)返回值: 一个表示给定对象的所有可枚举属性的字符串数组 传入字符串，返回索引 12var arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2'] 传入对象，返回属性名 12var obj = &#123; a: 'alive', b: 'bike', c: 'color' &#125;;console.log(Object.keys(obj)); // console: ['a', 'b', 'c'] length只对字符串和数组有用，整形数字和对象返回未定义undefined includes数组调用，监测数组是否包含给定的元素 array.include(0) 返回boolean this箭头函数与普通函数中的this指向不一样，前者基于定义时的上下文环境，后者则只是基于调用者。 typeof cb == “function” &amp;&amp; cb()强大的js总有一些没见过的用法 function delay(time, cb) { typeof cb == &quot;function&quot; &amp;&amp; cb(time) } cb&amp;&amp;cb(value) 的意思是： 如果cb为真（有值），那么执行cb(value)； 如果cb为假，&amp;&amp;短路，那么不执行cb(value)。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.liuzhidream.com/tags/javascript/"},{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"}]},{"title":"ssl-credential","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/ssl-credential/","text":"使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的 https ssl 证书使用https协议需要证书，可以自己创建，不足之处是不被认可，加密效果是一样的。以下内容截取自网络。 需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 创建自签名证书的步骤注意：以下步骤仅用于配置内部使用或测试需要的SSL证书。第1步：生成私钥使用openssl工具生成一个RSA私钥$ openssl genrsa -des3 -out server.key 2048说明：生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。注意：生成私钥，需要提供一个至少4位的密码。第2步：生成CSR（证书签名请求）生成私钥之后，便可以创建csr文件了。此时可以有两种选择。理想情况下，可以将证书发送给证书颁发机构（CA），CA验证过请求者的身份之后，会出具签名证书（很贵）。另外，如果只是内部或者测试需求，也可以使用OpenSSL实现自签名，具体操作如下： $ openssl req -new -key server.key -out server.csr说明：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，可以写自己的名字或者域名，如果要支持https，Common Name应该与域名保持一致，否则会引起浏览器警告。 Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:BeijingLocality Name (eg, city) []:BeijingOrganization Name (eg, company) [Internet Widgits Pty Ltd]:joyiosOrganizational Unit Name (eg, section) []:info technologyCommon Name (e.g. server FQDN or YOUR name) []:demo.joyios.comEmail Address []:liufan@joyios.com 第3步：删除私钥中的密码在第1步创建私钥的过程中，由于必须要指定一个密码。而这个密码会带来一个副作用，那就是在每次Apache启动Web服务器时，都会要求输入密码，这显然非常不方便。要删除私钥中的密码，操作如下： cp server.key server.key.orgopenssl rsa -in server.key.org -out server.key 第4步：生成自签名证书如果你不想花钱让CA签名，或者只是测试SSL的具体实现。那么，现在便可以着手生成一个自签名的证书了。 $ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt说明：crt上有证书持有人的信息，持有人的公钥，以及签署者的签名等信息。当用户安装了证书之后，便意味着信任了这份证书，同时拥有了其中的公钥。证书上会说明用途，例如服务器认证，客户端认证，或者签署其他证书。当系统收到一份新的证书的时候，证书会说明，是由谁签署的。如果这个签署者确实可以签署其他证书，并且收到证书上的签名和签署者的公钥可以对上的时候，系统就自动信任新的证书。第5步：安装私钥和证书将私钥和证书文件复制到Apache的配置目录下即可，在Mac 10.10系统中，复制到/etc/apache2/目录中即可。需要注意的是，在使用自签名证书时，浏览器会提示证书不受信任，如果你是对外网站使用，建议还是去CA机构申请可信的SSL证书，现在证书也很便宜，沃通CA超快SSL Pre才488元/年。 一般情况下，如果能找到可用的证书，就可以直接使用，只不过会因证书的某些信息不正确或与部署证书的主机不匹配而导致浏览器提示证书无效，但这并不影响使用。需要手工生成证书的情况有：找不到可用的证书需要配置双向SSL，但缺少客户端证书需要对证书作特别的定制首先，无论是在Linux下还是在Windows下的Cygwin中，进行下面的操作前都须确认已安装OpenSSL软件包。 创建根证书密钥文件(自己做CA)root.key：openssl genrsa -des3 -out root.key输出内容为：[lenin@archer ~]$ openssl genrsa -des3 -out root.keyGenerating RSA private key, 512 bit long modulus……………..++++++++++++..++++++++++++e is 65537 (0×10001)Enter pass phrase for root.key: ← 输入一个新密码Verifying – Enter pass phrase for root.key: ← 重新输入一遍密码 创建根证书的申请文件root.csr：openssl req -new -key root.key -out root.csr输出内容为：[lenin@archer ~]$ openssl req -new -key root.key -out root.csrEnter pass phrase for root.key: ← 输入前面创建的密码You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter ‘.’, the field will be left blank.—–Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音Locality Name (eg, city) []:BeiJing ← 市的全名，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不输入Common Name (eg, YOUR name) []: ← 此时不输入Email Address []:admin@mycompany.com ← 电子邮箱，可随意填Please enter the following ‘extra’ attributesto be sent with your certificate requestA challenge password []: ← 可以不输入An optional company name []: ← 可以不输入 创建一个自当前日期起为期十年的根证书root.crt：openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.req -out root.crt输出内容为：[lenin@archer ~]$ openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey root.key -in root.csr -out root.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./emailAddress=admin@mycompany.comGetting Private keyEnter pass phrase for root.key: ← 输入前面创建的密码 创建服务器证书密钥server.key：openssl genrsa –des3 -out server.key 2048输出内容为：[lenin@archer ~]$ openssl genrsa -out server.key 2048Generating RSA private key, 2048 bit long modulus….+++…………………………………………..+++e is 65537 (0×10001)运行时会提示输入密码,此密码用于加密key文件(参数des3便是指加密算法,当然也可以选用其他你认为安全的算法.),以后每当需读取此文件(通过openssl提供的命令或API)都需输入口令.如果觉得不方便,也可以去除这个口令,但一定要采取其他的保护措施!去除key文件口令的命令:openssl rsa -in server.key -out server.key5.创建服务器证书的申请文件server.csr：openssl req -new -key server.key -out server.csr输出内容为：[lenin@archer ~]$ openssl req -new -key server.key -out server.reqYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter ‘.’, the field will be left blank.—–Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省名，拼音Locality Name (eg, city) []:BeiJing ← 市名，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不输入Common Name (eg, YOUR name) []:www.mycompany.com ← 服务器主机名，若填写不正确，浏览器会报告证书无效，但并不影响使用Email Address []:admin@mycompany.com ← 电子邮箱，可随便填Please enter the following ‘extra’ attributesto be sent with your certificate requestA challenge password []: ← 可以不输入An optional company name []: ← 可以不输入 创建自当前日期起有效期为期两年的服务器证书server.crt：openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in server.csr -out server.crt输出内容为：[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in server.csr -out server.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.comGetting CA Private KeyEnter pass phrase for root.key: ← 输入前面创建的密码 创建客户端证书密钥文件client.key：openssl genrsa -des3 -out client.key 2048输出内容为：[lenin@archer ~]$ openssl genrsa -des3 -out client.key 2048Generating RSA private key, 2048 bit long modulus……………………………………………………………………………..+++……………………………………………………………………………………………………….+++e is 65537 (0×10001)Enter pass phrase for client.key: ← 输入一个新密码Verifying – Enter pass phrase for client.key: ← 重新输入一遍密码 创建客户端证书的申请文件client.csr：openssl req -new -key client.key -out client.csr输出内容为：[lenin@archer ~]$ openssl req -new -key client.key -out client.csrEnter pass phrase for client.key: ← 输入上一步中创建的密码You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter ‘.’, the field will be left blank.—–Country Name (2 letter code) [AU]:CN ← 国家名称，中国输入CNState or Province Name (full name) [Some-State]:BeiJing ← 省名称，拼音Locality Name (eg, city) []:BeiJing ← 市名称，拼音Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名Organizational Unit Name (eg, section) []: ← 可以不填Common Name (eg, YOUR name) []:Lenin ← 自己的英文名，可以随便填Email Address []:admin@mycompany.com ← 电子邮箱，可以随便填Please enter the following ‘extra’ attributesto be sent with your certificate requestA challenge password []: ← 可以不填An optional company name []: ← 可以不填 创建一个自当前日期起有效期为两年的客户端证书client.crt：openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAserial root.srl -CAcreateserial -in client.csr -out client.crt输出内容为：[lenin@archer ~]$ openssl x509 -req -days 730 -sha1 -extensions v3_req -CA root.crt -CAkey root.key -CAcreateserial -in client.csr -out client.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=MyCompany Corp./CN=www.mycompany.com/emailAddress=admin@mycompany.comGetting CA Private KeyEnter pass phrase for root.key: ← 输入上面创建的密码 将客户端证书文件client.crt和客户端证书密钥文件client.key合并成客户端证书安装包client.pfx：openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfx输出内容为：[lenin@archer ~]$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.pfxEnter pass phrase for client.key: ← 输入上面创建的密码Enter Export Password: ← 输入一个新的密码，用作客户端证书的保护密码，在客户端安装证书时需要输入此密码Verifying – Enter Export Password: ← 确认密码 保存生成的文件备用，其中server.crt和server.key是配置单向SSL时需要使用的证书文件，client.crt是配置双向SSL时需要使用的证书文件，client.pfx是配置双向SSL时需要客户端安装的证书文件 .crt文件和.key可以合到一个文件里面，把2个文件合成了一个.pem文件（直接拷贝过去就行了）参考：http://sinolog.it/?p=1460////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////http://blog.sina.com.cn/s/blog_4fd50c390101891c.htmlx509证书一般会用到三类文，key，csr，crt。Key是私用密钥openssl格，通常是rsa算法。Csr是证书请求文件，用于申请证书。在制作csr文件的时，必须使用自己的私钥来签署申，还可以设定一个密钥。crt是CA认证后的证书文，（windows下面的，其实是crt），签署人用自己的key给你签署的凭证。 1.key的生成opensslgenrsa -des3 -out server.key 2048这样是生成rsa私钥，des3算法，openssl格式，2048位强度。server.key是密钥文件名。为了生成这样的密钥，需要一个至少四位的密码。可以通过以下方法生成没有密码的key:opensslrsa -in server.key -out server.key server.key就是没有密码的版本了。 2.生成CA的crtopensslreq -new -x509 -key server.key -out ca.crt -days3650生成的ca.crt文件是用来签署下面的server.csr文件。 3.csr的生成方法opensslreq -new -key server.key -outserver.csr需要依次输入国家，地区，组织，email。最重要的是有一个common name，可以写你的名字或者域名。如果为了https申请，这个必须和域名吻合，否则会引发浏览器警报。生成的csr文件交给CA签名后形成服务端自己的证书。 4.crt生成方法CSR文件必须有CA的签名才可形成证书，可将此文件发送到verisign等地方由它验证，要交一大笔钱，何不自己做CA呢。opensslx509 -req -days 3650 -in server.csr -CA ca.crt -CAkey server.key-CAcreateserial -out server.crt输入key的密钥后，完成证书生成。-CA选项指明用于被签名的csr证书，-CAkey选项指明用于签名的密钥，-CAserial指明序列号文件，而-CAcreateserial指明文件不存在时自动生成。最后生成了私用密钥：server.key和自己认证的SSL证书：server.crt证书合并：catserver.key server.crt &gt; server.pem","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"http","slug":"http","permalink":"http://www.liuzhidream.com/tags/http/"}]},{"title":"Collect","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Collect/collect/","text":"常用内容收集整理，内容来自网络与个人整理 收藏内容内容来自某位大佬，网络收集与个人整理 注册码IntelliJ IDEA 后端申请Let’s Encrypt永久免费SSL证书(来自简书)Netlify 是一个提供网络托管的综合平台 前端consola 优雅命令行 console vuepress 也使用了 webpackbar webpack 打包进度可视化 jarvis webpack dashboard popmotion 一个函数式声明前端动画库 merge-images 图片合成 direction-reveal 一个根据鼠标进入方向展现 hover 描述的库 micron 通过动画属性绑定动画效果的库 sweetalert2 一个自适应优美自定义性强的弹出框 phaser 这是一个为桌面和移动浏览器开发 HTML5 游戏的快速开源框架。你可以为 iOS、 Android 和不同的本地应用程序创建游戏。 vue-sauce 一个可以展示 vue 源码的指令 tippy.js tooltip/popover library vue-smooth-dnd Vue wrappers components for smooth-dnd text-mask 一个可以让 input 按照规则输入(如电话,email,日期等) codesandbox-client 在线 web 开发容器 astexplorer 一个在线 ast 生成器 dinero.js 一个钱计算的库 crate 一个 react 全栈练习(pc,mobile,rn,api)demo Jasonette一个用 json 来构建 hybrid 的框架 vuegg 一个 vue 可视化拖拽界面生成器 refined-github 优化 github 默认功能的 chrome 插件 lerna 大项目版本控制工具，项目中可以有多个 package.json 文件 git-labelmaker 命令行快速创建 github react-in-patterns 一本开源叫你写 react 的书 picojs js 人脸识别库 img-2 一个提高图片加载性能和体验的库，懒加载使用 web worker 模糊预览 fingerprintjs 是一个快速的浏览器指纹库 ajv 一个 json schema 验证的库 dayjs 一个轻量级类 moment.js API 时间库 live-server 一个建议快速 dev 开发自动刷新的 http server serve快速起本地静态服务 primjs 代码高亮 ReLaXed 一个将 document html 转成 PDF 的工具 fabric.js 基于 canvas 创建交互式的图片编辑界面非常适合用来做图片合成类工作。 tabler 高颜值 ui 模板 matter-js web 物理引擎 rough 基于 Canvas 的手绘风格图形库 wired-elements 基于 rough.js 分装 button input raido 等组件 真正特别之处在于它的底层是 Web components uppy 一个很好看的也很好用的 前端上传库 tui-calendar 功能全面的日程安排日历控件，还支持拖拽。 tabler 基于 Bootstrap 4 的 Dashboard UI Kit 和美观 vee-validate 基于 vue 的验证，能验证的内容比较全 x-chart 我就是觉得颜色挺好看的 vuesax 一个很漂亮的基于 vue 的 ui 框架 vue-virtual-scroller 基于 vue 的虚拟列表无限滚动 particles.js 一个前端画颗粒 粒子的库 pulltorefresh.js 下个下拉刷新插件 lulu 腾讯阅文基于 jQuery，针对 PC 网站 IE8+（peak 主题）的前端 UI 框架 chancejs 生成随机数据的库 spritejs 360 奇舞团出的跨平台绘图对象模型 workbox 让你的网站更方便的变成 pwa tui.image-editor 一个功能齐全的在线图片编辑，基于 canvas hocs react 相关 hoc 收集库 nanoid 前端轻量 unique string ID 生成库 rxdb 一款开源的快速、灵活的客户端数据库，支持各种浏览器以及 NodeJS，Electron、React 等等，是 PouthDB 之上的一个封装库 vue-analytics 基于 vue 的 谷歌统计封装 percollate 命令行工具 能将网页转换成 pdf Nodechokidar node 监听文件变化的库 fs-extra fs-extra 模块是系统 fs 模块的扩展，提供了更多便利的 API，并继承了 fs 模块的 API globby 用于模式匹配目录文件 node-semver node 版本验证库 npm-run-all 一个 CLI 工具可以并行或者串行执行 script live-server 一个简单的 http server 带有 reload 功能 node-portfinder 一个端口嗅探工具 update-notifier Update notifications for your CLI app y18n yargs 基于 i18n 的一个包 signale Hackable console logger execa A better child_process listr Terminal task commander.js 自动的解析命令和参数，合并多选项，处理短参，等等，功能强大，上手简单 Inquirer.js A collection of common interactive command line user interfaces. 命令行询问库 ora Elegant terminal spinner 命令行 loaidng chalk 命令行着色美化库 hygen 快速方便的创建代码 可以命令行创建预设的 template ndb node 调试 got http 请求库 如果你觉得 request 太多的话 这是一个不错的选择 dumper.js 能让你的 node console 更加的规整，方便调试 node-in-debugging node.js 调试指南 nodebestpractices node 最佳实践 fastscan node 敏感词库 GraphQLprisma 让前端也能快速的写出 Apollo GraphQL 是基于 GraphQL 的全栈解决方案集合。从后端到前端提供了对应的 lib 使得开发使用 GraphQL 更加的方便 有趣1the-bread-code 使用程序员的思维制作面包 ，比如制作中使用 A/B test,来比较那种做法更好。 build-your-own-x 教你用各种语言实现 Bot Database Neural Network javascript-algorithms 教你用前端知识认识各种算法 工具high-speed-downloader 百度网盘不限速下载 支持 Windows 和 Mac hyper 前端命令行 yapi 是一个可本地部署的、打通前后端及 QA 的、可视化的接口管理平台 sway 一个微软自己出的在线 ppt 很强大 bigjpg 放大图片的神器 通过神经网络可以放大图片并能降噪 Ascii Art Generator 在线生成 Ascii 图案 Winds 开源 RSS JSUI 一个用来控制管理前端项目的客户端 docz 让你能快速写文档的一个库 hiper 性能统计分析工具 verdaccio 私有 npm git-guide git 入门指南 git-tips git 进阶 bit 实现了项目之间的代码共享 可以自建私有 simpread 简悦 ( SimpRead ) - 让你瞬间进入沉浸式阅读的扩展 mkcert 一键命令 让本地也支持 https termtosvg 录制 命令操作转成 svg 基于 python gh-polls 可以在 github issue 中添加投票 eruda 移动端调试工具 vConsole 也是一个移动端调试工具 腾讯出品 terminalizer 命令行录制工具 基于 node badgen 快速构建和 shields 一样的 svg badge 但速度更快 readability 移除页面非正文部分 基于 jsdom WeChatPlugin-MacOS 一款功能强大的 macOS 版微信小助手 puppeteer-recorder 一个 chrome 插件 能够根据你的操作 自动生成 puppeteer 相关代码 mdx-deck 用 markdown 编写演示文稿 code-surfer 基于 mdx-deck 的一个插件让你更好的在文稿中展示 code Progressive Tooling 前端性能优化工具集合 https://github.com/artf/grapesjs 可视化建站工具 不需要写代码就能写一个页面，前端再次再次要下岗了 image-charts 该服务通过 URL 接受参数，然后生成图表，以图片形式返回 eagle.js 一个用 vue 来制作 PPT 的库 Optimizely A/B Test appadhoc 一个国内的 A/B Test 服务 Macget-plain-text 能清除剪贴板里的格式 很实用 IINA mac 平台感觉免费最好的播放器 强推 Githubgithub 短域名服务 shields Github README 里面的装逼小图标 Emoji 方便平时写查找 emoji emoji.muan 同上 而且更全 git-awards github ranking 没事可以查着玩玩 http://githubrank.com/ github 按照 followers 排名 开发zeplin 前端和设计师神器，有标注、Style Guide、版本管理、简单的团队协作，重点是前端不用写 css 了，复制就可以了。 iconfont 阿里出的图标库，非常实用，支持 svg、font、png 多种格式，基本现在所有图标都在上面找。 cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多 智图 腾讯出品 在线图片压缩 支持转成 webP 处理静态图片时候很好用 picdiet 另一个图片压缩网站 CSS triangle generator 帮你快速用 css 做出三角形 cssarrowplease 帮你做对话框三角的 clippy 在线帮你使用 css clip-path 做出各种形状的图形 Regular Expressions 在线正则网站 jex 正则可视化网站，配合上面的 Regular Expressions，写正则方便很多 jsfiddle 在线运行代码网站 很不错，可惜要翻墙 codepan 在线运行代码网站 不用翻墙，可以自己部署 fiddle.md 一个方便的在线共享 markdown 在线笔试题一般都用这个 jsdelivr cdn 服务 unpkg cdn 服务 coderpad 远程面试的神器，可以让面试者远程写代码 不过需要翻墙 icode 有赞团队出品的 coderpad 可以互补，它不需要翻墙 snipper 一个代码协同的网站。你新建一个代码片段，然后把网址分享给其他人，就可以看到他们的实时编辑。 codesandbox 一个可以在线编辑且提供在线 demo 的网站 支持 vue react angular 多种框架 神器 codrops 上面的交互都非常酷炫 bgremover 在线图片去底工具 photopea 一个网页端 Photoshop 很变态 设计uimovement 能从这个网站找到不少动画交互的灵感 awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站 dribbble 经常能在上面找到很多有创意好看的 gif 或者图片，基本上我所有的图都是上面招的 Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客 Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。 brandmark 另一个在线制作 logo 网站(这个不打水印，很良心) instant 有一个 logo 制作网站 coolors 帮你在线配色的网站 你能找到不少配色灵感 colorhunt 另一个配色网站 uigradients 渐变色网站 有趣帮你百度一下 可以 点我测试一下 国际版 同帮我百度一下 点我测试一下 wallhaven 壁纸网站 交互微交互 里面收集了市面上很多很好的微交互例子 值得学习 Little Big Details 同上，一个国外微交互汇集网站 cruip 登录页的各种页面设计，可以免费下载模板 Csscss-tricks 一个学习 css 不错的网站 有很多有意思的 demo 教程npx 教你怎么合理的使用 npx 产品产品大牛 什么有很多完整的产品原型可以借鉴 磨刀 快速出 ui 原型","tags":[{"name":"water","slug":"water","permalink":"http://www.liuzhidream.com/tags/water/"}]},{"title":"Docker","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Docker/Docker/","text":"docker 容器技术学习笔记 Docker 笔记 image 命令docker ps 列出容器列表 docker container ls 管理容器 两个命令都是查看正在运行的容器，加 -a 参数可以查看更多的信息 docker run docker container run 都是运行容器(但是本质还是不同的，可以深入研究下) Ctrl+P+Q 退出容器不关闭 docker start goofy_almeida 启动容器在后台运行 docker attach goofy_almeida 后台容器进入终端 docker network create &lt;name&gt; docker network inspect &lt;name&gt; docker stats 容器ID 查看容器状态 docker logs 把容器运行后产生的输入都打印出来，不要轻易尝试 多个终端访问容器有时候需要开启多个终端来访问容器，通过容器ID，执行命令 docker exec -it 40c330755e61 /bin/bash 就可以了，这个终端的退出不会影响到已经开启的终端 创建容器的参数 -d：后台运行容器，并返回容器ID -i：以交互模式运行容器，通常与 -t 同时使用 -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用 容器连接容器连接就是把容器接到一起，让它们可以相互通信，如果你使用一个容器运行一个软件的方式，容器连接就是很有必要的，比如你的服务和数据库进行通信，那么你的容器就要连接在一起。使用到的命令有 --link ，不过新的特性推荐使用 network ，network把容器都加到一个网络中，实现之间的互相通信。 相关命令 创建网络，my_network 是网络的名称。创建完网络，把容器加入到网络就行了。1docker network create my_network tip 加入网络示例： docker run -it --name=web_django --network web_network --network-alias django -v /root/py_web_vadmin/:/root/web_work -p 8080:8080 debian:v2 bash docker run -it --name=web_nginx --network web_network --network-alias nginx -v /root/py_web_vadmin/:/root/web_work -p 80:80 nginx bash 把debian和nginx加入到一个已创建的网络中。 查看网络1docker network ls 查看已创建的网络，默认有服务自己创建的网络 效果如下：1234NETWORK ID NAME DRIVER SCOPE9872c9881f6e bridge bridge local6fc119c0ceda host host localc3fdf8d5c56e none null local bridge：默认网络，所有容器默认连接到它 none：没有网络接口 host：连接到主机的网络栈，主机和容器间的网络没有隔离 数据卷数据卷用来做数据持久化，如果你的数据在容器中，比如数据库文件，日志文件等，这些文件是会不断生成的，当你关闭容器，再次启动容器，数据倒是不会丢失，如果你从镜像启动新的容器，数据就没了（出现这种情况是因为：通常使用run命令来启动容器，如果没有定义name，那么每次使用run命令都会从镜像创建新的容器，这样上次容器的操作都没了，应该养成定义容器name的习惯，创建同名的容器是不允许的）。数据要想保持，除非你不断的提交镜像，当然这种做法是不可取的，所以要用到数据卷技术。数据可以让容器和宿主主机共享一个目录，通常把程序，数据库文件等放在宿主机上，通过创建数据卷，让容器可以操作到宿主机文件，并把新的数据写到此。 1docker container run -v /root/data:/root/PythonProjects/GitTest -it -p 8080:8080 debian:v2 bash 上面命令的含意是：本机目录/root/data映射到容器目录/root/PythonProjects/GitTest（在启动容器的时候就得使用-v 命令，容器和主机共用一个目录，关闭容器，在启动容器也得带-v命令）一般会把程序放在宿主机上，更新修改都在这，不过修改了代码后，记得进入容器中去重启项目。 文件操作12从主机复制到容器 sudo docker cp host_path containerID:container_path从容器复制到主机 sudo docker cp containerID:container_path host_path 操作流程：先把容器运行起来，宿主主机执行 docker container 查询正在运行的container 的containerID 然后去执行上面的命令 保存容器修改： pull 了一个新的image后，或操作已有的容器，并对容器做了修改，退出容器后 执行 docker ps -l 得到 容器的ID 执行 docker commit 容器ID 镜像名称 该操作将覆盖现有进行为修改后的容器 docker commit 容器ID 镜像名称:v2 保存修改为tag为v2的镜像 容器容器(container)是docker一个很重要的概念，通过镜像我们就可以创建容器。这里记录一些相关命令。 123456789101112131415161718192021222324252627282930查看docker container ls 等同于 docker ps -a 查看更多的信息删除docker rm container iddocker rmi image id杀死所有正在运行的容器docker kill $(docker ps -a -q)删除所有已经停止的容器(容器不再使用了，可以使用此命令把它们都清空了)docker rm $(docker ps -a -q)删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling=true)删除所有镜像docker rmi $(docker images -q)强制删除镜像名称中包含“doss-api”的镜像docker rmi --force $(docker images | grep doss-api | awk '&#123;print $3&#125;')删除所有未使用数据docker system prune只删除未使用的volumesdocker volume prunedocker start goofy_almeida 启动容器在后台运行docker attach goofy_almeida 后台容器进入终端 docker ps –选项 Name, shorthand Default Description –all , -a Show all containers (default shows just running) –filter , -f Filter output based on conditions provided –format Pretty-print containers using a Go template –last , -n -1 Show n last created containers (includes all states) –latest , -l Show the latest created container (includes all states) –no-trunc Don’t truncate output –quiet , -q Only display numeric IDs –size , -s Display total file sizes 使用 docker attach 命令进入container（容器）有一个缺点，那就是每次从container中退出到前台时，container也跟着退出了。要想退出container时，让container仍然在后台运行着，可以使用 docker exec -it 命令。每次使用这个命令进入container，当退出container后，container仍然在后台运行，命令使用方法：12345docker exec -it goofy_almeida /bin/bashgoofy_almeida：要启动的container的名称/bin/bash：在container中启动一个bash shell 这样输入“exit”或者按键“Ctrl + C”退出container时，这个container仍然在后台运行。 ::: tip关于容器的运行，我本人的做法会使用 screen (linux的一个软件)，一般没有做后台运行。::: container总结run 命令后从镜像创建container(容器)，此时的容器是新的，如果修改了内容，用exit退出，这个容器被关闭了（进入了Exited状态），如果想留着修改，最好是Ctrl+P+Q 退出容器不关闭 这样docker ps 可以查看容器还在，这样就可以通过start 容器name再次进入容器了。（这里我感觉容器的状态是有用的，具体就要看文档了，因为run新容器后，通过exit命令退出了，再次run，此时ps命令应该是创建了一次，然后关闭，又创建了一次，出现过两个name, 但是第二次run的容器是新的，上次修改的拿不到。 但是修改后，exit退出，通过docker ps -l，可以看到容器id, 这里可以进行提交。所以像保持容器的修改，最好用上面的流程，等理清楚了生命周期，就比较清楚整个流程了）经测试，docker ps -l列不出的容器，通过docker ps -a找到，即使状态不是update也可以去commit。::: tip 容器的statusOne of created, restarting, running, removing, paused, exited, or dead::: 容器导入导出docker save imageID &gt; filename.tar docker load &lt; filename.tar docker export imageID &gt; filename.tar docker import &lt; filename.tar 镜像和容器导出和导入的区别 镜像导入和容器导入的区别： 容器导入 是将当前容器 变成一个新的镜像 镜像导入 是复制的过程 save 和 export区别： save 保存镜像所有的信息-包含历史 export 只导出当前的信息 Dockerfile 使用除了通过拉取官方镜像的方式外，使用Dockerfile可以定制镜像，使其更加灵活。整个Dockerfile文件就是执行的脚本，由特定的命令组成，一个redis镜像Dockerfile文件大概是这样的。 123456789101112131415FROM centos:latestRUN yum -y update; yum clean allRUN yum -y install epel-release; yum clean allRUN yum -y install redis; yum clean all# 设置挂载点VOLUME [\"/data/redis\"]# Define working directory.WORKDIR /dataEXPOSE 6379CMD [\"redis-server\"] 上述Dockerfile文件是基于基础镜像CentOS来制作Redis。 docker build -t centos:v2 . 在文件所在目录下执行构建命令 指令Dockerfile指令就是上述文件中开头的FROM，RUN等。Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像。 FROM scratch 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 12345678910ADDCOPYENVEXPOSEFROMLABELSTOPSIGNALUSERVOLUMEWORKDIR docker-compose这个工具是用来做容器编排的，简单来说就是可以一次启动多个容器，包括了设置端口映射，数据卷，容器连接等。在使用docker部署项目时，还是应该一个软件对应一个容器，而不是基于一个容器安装多个软件（这样就搞成一个虚拟机了），你要依次启动4，5个容器，设置端口映射，容器连接等会很麻烦，使用docker-compose只需要编写一个 docker-compose.yaml 文件就可以了。 使用了docker-compose，最好再配合一下Dockerfile，这样很快速就可以搭建一个环境。 以Python语言为例，流程应该是编写Dockerfile，在Dockerfile中基于一个基本容器（ubuntu，或者是Python3等容器），设置一些参数，然后安装依赖 RUN pip install -r requirements.txt，这样语言环境就有了，下面就是各个服务，比如MySQL，Redis等，这些不是太复杂的情况，直接在Dockerfile中指定image就行了。 总结： Dockerfile 定义应用的运行环境 docker-compose.yml 定义组成应用的各服务 docker-compose up 启动整个应用 编写yaml文件这个编写很简单，就是把各个容器怎么运行，参数配置组织在一起 来看一个简单的官方例子： 123456789101112131415version: '3'services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: &#123;&#125; 官方文档总结： 一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，官方这里的例子使用links，而没有使用新的networks特性。configs配置在3.3及以上版本使用，用于配置文件的访问权限。 version：用来指定版本，依照官方的例子，现在可以使用3版本了，不同版本对一些配置的支持不同，比如配置参数从字符串到对象的变化，这里不再深入了 services：就是需要运行的容器，容器通过build或image指定，build就是使用Dockerfile文件，image就是使用镜像，本地有的使用本地的，否则下载仓库的。build后面还可以加参数，例如context，args，用来设置上下文，参数等，这属于Dockerfile相关的内容，一般情况，直接在build指定当前目录就行了。ports指定端口映射，volums指定数据卷（使用数据卷，修改代码不用重启容器），在这个官方例子中，在最外层也就是顶级定义了volumes，这是为服务定义的，使用一个单机开发环境在services中定义就行了。标签有两种情况，在服务上（部署集群的时候）deploy: labels: ’标签内容‘，在容器上只需要用labels。看到deploy，它下面的配置都是和部署有关的。depends_on依赖关系，依赖的容器会先启动。command命令，类似python3 manage.py runserver 0.0.0.0:8000。pid: “host” 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的–add-host类似。 命令 Command Description build 构建或重建服务，这会把Dockerfile再执行一次 help 命令帮助 kill 杀掉容器 logs 显示容器的输出内容 port 打印绑定的开放端口 ps 显示容器 pull 拉取服务镜像 restart 重启服务 rm 删除停止的容器 run 运行一个一次性命令，run web bash exec Execute a command in a running container，感觉run差不多 scale 设置服务的容器数目 start 开启服务 stop 停止服务 up 创建并启动容器 version 查看版本，如果你是2版本的，就不要在yaml里面使用3版本的写法了 使用总结： 个人心得，大致浏览了一下官方文档，docker-compose最大的用处应该是集群，它提供了很多功能，不过对于单机来说仍然有它的价值，省去了很多命令，同样作为单机来用，不需要学的很深入，很多配置都是用不到的 启动容器：使用up命令来启动容器，同时也会把build配置生成镜像，在我使用的版本中，给出了警告，对于需要使用Dockerfile构建的镜像，警告说应该先使用 docker-compose up --build，不过这对容器的启动到是没什么影响（不知道这里官方想表达什么）。build命令只会构建镜像，并不会去启动容器，up命令启动容器后，会把容器的输出打印到终端，要想在后台运行，应该 up -d name：使用image的，镜像名称就是指定的，使用build，镜像名称为当前目录加上在services中的配置，在容器中的name也是当前目录加上在services中的配置。使用docker-compose需要在yaml文件目录执行，这样在services中的配置，比如一个叫做web的配置，第一次使用镜像（或用build构建）是Python，生成的容器也是 当前目录_web_1，修改了web配置，image变成Redis，那么上次创建的容器会被删除，创建新的容器，容器的名称是一样的，因为修改的是image，而不是web。使用container_name可以自定义容器name，不过通过ps命令可以看到系统的缺省名称是web_1，如果自定义了，那么在集群上因为名称相同导致错误 exited with code 0：我用自定义的dockerfile启动容器，结果返回这么一个信息容器就停止了，我分析了官方例子做了一些测试后发现，如果你的容器启动后，什么都不做，那就会退出了，一些情况也是会退出的，比如你用 command echo $HOME 终端会打印这个信息，然后退出容器，我写了一个Python循环，用logging打印信息，终端一直在打印信息，没有退出。也就是说启动容器不能什么也不做 使用command，推荐绝对路径 :sunny:docker-compose应该这么来理解，它把多个容器组织在一起，并默认加到一个网络中（如果你没有定义网络或把容器分到不同的网络），通过run命令可以向整个环境发送命令(docker-compose run dev /bin/zsh 进入交互环境)，同时也可以使用docker的命令。体现了一个整体的概念。","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"linux","slug":"linux","permalink":"http://www.liuzhidream.com/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://www.liuzhidream.com/tags/docker/"}]},{"title":"Celery","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Web/Celery/","text":"Celery - Distributed Task Queue。要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。 CeleryCelery - Distributed Task Queue 要理解 Celery 本身不是任务队列，它是管理分布式任务队列的工具，或者换一种说法，它封装好了操作常见任务队列的各种操作，我们用它可以快速进行任务队列的使用与管理，当然你也可以自己看 rabbitmq 等队列的文档然后自己实现相关操作都是没有问题的。 安装通过Python的包管理工具来安装，在我查到的一些资料中，celery和docker的配合不是很好，建议不要在单一容器中使用celery了。 架构 生产者(Celery client)。生产者(Celery client)发送消息。在Flask上工作时，生产者(Celery client)在Flask应用内运行。 消费者(Celery workers)。消费者用于处理后台任务。消费者(Celery client)可以是本地的也可以是远程的。我们可以在运行Flask的server上运行一个单一的消费者(Celery workers)，当业务量上涨之后再去添加更多消费者(Celery workers)。 消息传递者(message broker)。生产者(Celery client)和消费者(Celery workers)的信息的交互使用的是消息队列(message queue)。Celery支持若干方式的消息队列，其中最常用的是RabbitMQ和Redis. 以上是最基本的架构，完整的组件还包括： Celery Beat：任务调度器 Celery Worker：执行任务的消费者 Broker：消息代理 Product：任务生产者（通过API，装饰器等产生任务并交个任务队列处理） Result Backend：任务处理完成后，保存状态信息，以供查询 1，4都是任务的生产者，只是方式不一样，1的方式是Beat进程读取配置文件，周期性的将到期的任务发给任务队列执行，就是定时任务。 在flask中使用celery如何集成，并且很好的解耦模块是celery运用的关键。你总不能把代码都堆叠在一起吧。 注意事项 flask_celery不能支持celery4.0，所以弃用扩展模块，直接使用celery模块。使用扩展的好处是在扩展模块在一个文件初始化，并且全局保持一个实例对象，所以你的celery需要在app创建后才能创建，需要考虑是否使用了全局的celery对象 创建celery的实例对象的名字使用flask应用程序app的名字，通过 app.name 获取，如果你使用扩展插件，建议不要修改此名称，否则创建失败，不使用扩展插件也不建议修改 当有多个装饰器的时候，celery.task一定要在最外层 init代码 123app = create_app(CONFIG)celery = CeleryApp(app.name)celery.conf.update(app.config) 首先创建Flask app的实例app，然后创建Celery的实例celery，这里需要传递一个名称，这个名称会作为celery task的前缀，例如 flask_app.celery_app.task.long_task，long_task是我们定义的任务，你要改创建实例的参数也可以，建议不要修改。这里的CeleryApp是自己编写的，继承Celery的一个类，目的是实现单实例，让其它模块通过CeleryApp创建的实例保持一样，然后调用celery.conf.update更新参数，flask app.config 是继承dict的Config类，这样就把需要的参数配置通过flask配置，作用于celery。 flask大多数的插件做的事情就是在单独的扩展文件中，先不传递参数实例化扩展，然后在创建app的时候初始化它，估计flask_celery也是做差不多的事情，不过实例化Celery必须要先传递参数，现在插件没有在更新了(有一些其他名称的扩展可以支持)，主要还是为了工程化。 这里记录一下扩展包的情况吧，在py3中，有： Flask-Celery：这个其实不是扩展，而是装这个就把Celery相关的给安装了，这个是Celery的作者写的，他也说在4.0版本不再需要了，我也没看出来这个有什么用 Flask-Celery-Helper：这个就是扩展了，导入用flask_celery，不支持4.0 Flask-Celery-py3，Flask-Celery3：好像都是不支持4.0的 Flask-CeleryExt：在文档中写明可以支持4.0了，和大部分扩展使用方法一样，用懒加载的方式实例化 数据序列化 Command Description pickle: 二进制序列化方式；是标准库的一个模块，支持Python的内置数据结构，但是他是Python的专有协议，在celery3.2开始，出于安全考虑，不再采用此方案； json: json支持多种语言，可用于跨语言方案，但好像不支持自定义的类对象； XML: 类似标签语言； msgpack: 二进制的类json序列化方案，但比json的数据结构更小，更快； yaml: yaml表达能力更强，支持的数据类型较json多，但是python客户端的性能不如json; 在自定义对象上，序列化方案我也出现过问题，pickle用了不行，可能就是不支持了，有待解决 使用步骤 celery = Celery(app.name) 创建celery实例 celery.conf.update(app.config) 更新配置 在需要后台运行的任务使用@celery.task 123@celery.taskdef hello_world(): return \"hello_world\" 需要注意的是，被装饰的任务需要调用才会加到任务队列，也就是通过hello_world.delay()调用，在官方的例子中，通过继承的方式，增加 __call__ 方法，内部调用run，这样装饰器@celery.task()便会直接加入任务队列了，不过这样的功能应该是不需要的。 通过 r = hello_world.delay() 方法，返回的对象拥有以下方法： Command Description r.ready() #查看任务状态，返回布尔值，任务执行完成，返回True，否则返回False. r.wait() #等待任务完成,返回任务执行结果，很少使用； r.get(timeout=1) #获取任务执行结果，可以设置等待时间 r.result #任务执行结果. r.state #PENDING,START,SUCCESS，任务当前的状态 r.status #PENDING,START,SUCCESS，任务当前的状态 r.successful #任务成功返回true r.traceback #如果任务抛出了一个异常，你也可以获取原始的回溯信息 装饰器参数`@celery.task()` name：可以显示指定任务的名字； serializer：指定序列化的方法； bind：一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，具体属性可参照 celery--app--task.py 中的Task类，通过self.request.__dict__打印相关属性； base：指定任务的基类，可以定义一个类，继承celery.Task，利用重写或扩展的类接口技术制定需求，例如on_success方法，默认是没有返回值的，就是提供这个钩子让开发者自定义的； 调用任务任务被装饰器装饰后，通过task.delay()，task.apply_async()把任务加入到队列中，send_task()，可以发送未被注册的异步任务，即没有被celery.task装饰的任务 apply_async的参数 Command Description countdown 设置该任务等待一段时间再执行，单位为s； eta 定义任务的开始时间；eta=time.time()+10; expires 设置任务时间，任务在过期时间后还没有执行则被丢弃； retry 如果任务失败后,是否重试;使用true或false，默认为true shadow 重新指定任务的名字str，覆盖其在日志中使用的任务名称； retry_policy 重试策略，为一个字典，各个键值配置：max_retries-最大重试次数，默认为 3 次. interval_start-重试等待的时间间隔秒数，默认为 0 ，表示直接重试不等待. interval_step-每次重试让重试间隔增加的秒数，可以是数字或浮点数，默认为 0.2. interval_max-重试间隔最大的秒数,即通过 interval_step 增大到多少秒之后，就不在增加了，可以是数字或者浮点数，默认为 0.2 . routing_key 自定义路由键； queue 指定发送到哪个队列； exchang 指定发送到哪个交换机； priority 任务队列的优先级，0-9之间； serializer 任务序列化方法；通常不设置； compression 压缩方案，通常有zlib,bzip2 headers 为任务添加额外的消息； link 任务成功执行后的回调方法；是一个signature对象；可以用作关联任务； link_error 任务失败后的回调方法，是一个signature对象； 自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法: 1234567task.apply_async((2,2), compression='zlib', serialize='json', queue='priority.high', routing_key='web.add', priority=0, exchange='web_exchange') 基本配置1234567891011121314151617181920212223242526272829303132333435363738394041424344# 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URLBROKER_URL = 'amqp://username:passwd@host:port/虚拟主机名'# 指定结果的接受地址CELERY_RESULT_BACKEND = 'redis://username:passwd@host:port/db'# 指定任务序列化方式CELERY_TASK_SERIALIZER = 'msgpack' # 指定结果序列化方式CELERY_RESULT_SERIALIZER = 'msgpack'# 任务过期时间,celery任务执行结果的超时时间CELERY_TASK_RESULT_EXPIRES = 60 * 20 # 指定任务接受的序列化类型.CELERY_ACCEPT_CONTENT = [\"msgpack\"] # 任务发送完成是否需要确认，这一项对性能有一点影响 CELERY_ACKS_LATE = True # 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据CELERY_MESSAGE_COMPRESSION = 'zlib' # 规定完成任务的时间CELERYD_TASK_TIME_LIMIT = 5 # 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程# celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目CELERYD_CONCURRENCY = 4 # celery worker 每次去rabbitmq预取任务的数量CELERYD_PREFETCH_MULTIPLIER = 4 # 每个worker执行了多少任务就会死掉，默认是无限的CELERYD_MAX_TASKS_PER_CHILD = 40 # 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中CELERY_DEFAULT_QUEUE = \"default\" # 设置详细的队列CELERY_QUEUES = &#123; \"default\": &#123; # 这是上面指定的默认队列 \"exchange\": \"default\", \"exchange_type\": \"direct\", \"routing_key\": \"default\" &#125;, \"topicqueue\": &#123; # 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列 \"routing_key\": \"topic.#\", \"exchange\": \"topic_exchange\", \"exchange_type\": \"topic\", &#125;, \"task_eeg\": &#123; # 设置扇形交换机 \"exchange\": \"tasks\", \"exchange_type\": \"fanout\", \"binding_key\": \"tasks\", &#125;,&#125; 命令celery worker -A auto_app.celery --loglevel=info 启动Worker 任务状态 Command Description PENDING 任务等待中 STARTED 任务已开始 SUCCESS 任务执行成功 FAILURE 任务执行失败 RETRY 任务将被重试 REVOKED 任务取消 通过 r.get(&#39;status&#39;) == &#39;PENDING&#39; 获取状态 设置任务调度器配置文件: 123456789101112from datetime import timedeltafrom celery.schedules import crontabConfig = dict( CELERYBEAT_SCHEDULE=&#123; 'ptask': &#123; 'task': 'flask_app.celery_app.task.period_task', 'schedule': timedelta(seconds=5), &#125;, &#125;, CELERY_TIMEZONE='Asia/Shanghai') 配置中 schedule 就是间隔执行的时间，这里可以用 datetime.timedelta 或者 crontab，如果定时任务涉及到 datetime 需要在配置中加入时区信息，否则默认是以 utc 为准。例如中国可以加上： CELERY_TIMEZONE = &#39;Asia/Shanghai&#39; task的任务路径不能出错，在启动Worker进程的时候，可以看到task列表，这里指的的定时任务和其对应即可。 启动命令： 需要执行两个进程，一个是Worker进程，用来处理生成的任务，一个就是beat进程，启动任务调度器进程，定时生成任务 celery beat -A auto_app.celery --loglevel=info celery worker -A auto_app.celery --loglevel=info 任务调度会有需要动态添加任务，管理任务的情况，Django框架通过djang-celery实现在管理后台创建，删除，更新任务，它通过自定义调度类来实现，如果有类似的需求，可以参考源码实现 工作流Signature 对象，把任务通过签名的方法传递给其它任务，成为一个子任务 12345In [6]: task = signature(&apos;flask_app.celery_app.task.add&apos;, args=(2, 2), countdown=5)In [7]: taskOut[7]: flask_app.celery_app.task.add(2, 2)In [8]: task.apply_async()Out[8]: &lt;AsyncResult: 0cbe319e-c3f6-48b9-b1e4-6a034711cf3a&gt; from celery import signature 导入signature，可以看到，传递的第一个参数是已经存在的任务，也可以先把add导入，通过 add.subtask((2, 2), countdown=5)，或使用subtask的缩写s，add.s()。 子任务能支持偏函数的方式，利用它实现工作流。 支持原语实现工作流，原语表示由若干条指令组成的，用于完成一定功能的过程 1.chain - 调用链，任务的链式执行，前面的执行结果作为参数传递给后面，直到任务完成 chain 函数接受一个任务的列表，Celery 保证一个 chain 里的子任务会依次执行，在 AsynResult 上执行 get 会得到最后一个任务的返回值。和 link 功能类似，每一个任务执行结果会当作参数传入下一个任务，所以如果你不需要这种特性，采用 immutable signature 来取消。 123456def subtask(): from celery import chain part = add.s(1, 2) | add.s(3) | add.s(5) # or part = (add.s(1, 2), add.s(3), add.s(5)) res = chain(part)() print(res.get()) 2.group - 任务的并发执行 1234def subtask(): from celery import group res = group([add.s(i, i) for i in range(1, 10)])() print(res.get()) group 函数也接受一个任务列表，这些任务会同时加入到任务队列中，且执行顺序没有任何保证。在 AsynResult 上执行 get 会得到一个包含了所有返回值的列表。意参数必须是list对象 chord - 带回调的 group chord 基本功能和 group 类似，只是有一个额外的回调函数。回调函数会在前面的任务全部结束时执行，其参数是一个包含了所有任务返回值的列表。在 AsynResult 上执行 get 会得到回调函数的返回值。 map/starmap - 每个参数都作为任务的参数执行一遍 chunks - 将任务分块 总结在启动Worker进程后，可以看到被装饰的任务已经被列出来了，这说明Celery有读取文件的机制(你可以在任务模块的最外层使用print测试)，被装饰的函数应该要在最外层，而且，创建实例后，再去修改配置，似乎没有生效（在我的测试中是这样的），其实这也符合逻辑，在进程被创建了，却又动态的去修改配置，与之对应的风险也很高。 celery是队列管理工具，真正的队列是Broker，更深入一点要了解RabbitMQ，AMQP协议，一般在celery上关注Worker，可以使用多个Worker，任务的生成使用定时器或触发的机制，任务本身就要由Python来编写，也包括对执行结果的处理。 任务生成，处理有了，还有队列的管理，默认使用名为celery的队列，可以配置队列，比如队列A，队列B，进入A队列的任务优先级要高，会被先处理。可以在启动worker进程的时候指明队列(通过-Q指定队)，这样这个Worker只会处理指定的队列。 后续扩展内容：celery信号，分析任务执行情况。Worker管理，监控和管理celery。","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"python","slug":"python","permalink":"http://www.liuzhidream.com/tags/python/"}]},{"title":"Python-threading","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/Python-threading/Python-threading/","text":"python多线程相关笔记 线程使用标准库threading来创建线程。threading 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可 以创建一个 Thread 对象并将你要执行的对象以 target 参数的形式提供给该对象。虽然python GIL 的存在，导致多线程同一时刻只能有一个线程获得解释器（在py2中，大概执行1000行字节码后，会释放解释器，当线程被阻塞的时候，会让出解释器，释放GIL） 可以通过time.sleep(3)来阻塞线程 一个简单例子： 12345678910111213141516171819202122232425import threading# 计算密集型任务def func(): a = [i for i in range(1111)] print('hello world')t = threading.Thread(target=func)t.start()print('sleep')# 此时创建列表a占用了解释器，先hello world 再 sleep# 计算密集型任务def func(): a = [i for i in range(11111111111)] print('hello world')t = threading.Thread(target=func)t.start()print('sleep')# 这种情况，先打印sleep再是hello world（执行一定的字节码后，释放了解释器） threading的属性和方法 current_thread() # 返回当前线程对象. main_thread() # 返回主线程对象. active_count() # 当前处于alive状态的线程个数. enumerate() # 返回所有活着的线程的列表，不包括已经终止的线程和未开始的线程. get_ident() # 返回当前线程ID，非0整数. 看一个例子： 1234567891011121314151617import threadingdef func(): # a = [i for i in range(1111)] print('current thread = &#123;&#125;'.format(threading.current_thread())) print('main thread = &#123;&#125;'.format(threading.main_thread()), '\"主线程对象\"') print('active count = &#123;&#125;'.format(threading.active_count()), '\"alive\"') print('hello world')t = threading.Thread(target=func)t.start()print('sleep')print('current thread = &#123;&#125;'.format(threading.current_thread()))print('main thread = &#123;&#125;'.format(threading.main_thread()), '\"主线程对象\"')print('active count = &#123;&#125;'.format(threading.active_count()), '\"alive\"') 运行以上代码，每次的执行结果是不一样的，而且是print是线程不安全的。要解释这个问题，需要再了解一些线程相关的概念。 thread实例的属性和方法 name: 只是一个名称标识，可以重名，getName()、setName()来获取、设置这个名词。 ident: 线程ID，它是非0整数。线程启动后才会有ID，否则为None。线程退出，此ID依旧可以访问。此ID可以重复使用。 is_alive(): 返回线程是否活着。 通过threading.Thread() 我们创建了线程类的实例，像面向对象一样，可以有对应的方法，属性 t = threading.Thread(target=func, name=&#39;my_thread&#39;, args=(&#39;1&#39;, ), kwargs={&#39;a&#39;: 2}) start(): 启动线程。每一个线程必须且只能执行该方法一次。 开始线程活动。 对每一个线程对象来说它只能被调用一次，它安排对象在一个另外的单独线程中调用run()方法（而非当前所处线程）。当该方法在同一个线程对象中被调用超过一次时，会引发RuntimeError(运行时错误)。 run(): 运行线程函数。 代表了线程活动的方法。 你可以在子类中重写此方法。标准run()方法调用了传递给对象的构造函数的可调对象作为目标参数，如果有这样的参数的话，顺序和关键字参数分别从args和kargs取得。 start() 后，还会执行run。如果你重写线程类，在调用start和run的时候，加入打印代码，start执行的线程，会派生出子线程，在子线程中去执行run，配合threading.current_thread()可以看到整个过程。 而run只在当前线程中执行。 多线程情况继承Thread类，使用Extender的形式扩展start和run方法，观察执行情况。我们开启两个线程，然后start他们，利用threading.current_thread()获取当前线程，main_thread()返回主线程对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import threadingimport timeimport logginglogging.basicConfig(level=logging.NOTSET)def worker(): count = 0 while True: if count &gt; 5: break time.sleep(1) count += 1 # print(\"worker running\") logging.info(\"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;\".format(threading.current_thread().name, threading.current_thread().ident, threading.main_thread())) # print(threading.current_thread().name, threading.current_thread().ident)class MyThread(threading.Thread): def start(self): print('start~~~~~~~~~~~~~') super().start() def run(self): print('run~~~~~~~~~~~~~~~') super().run()print(threading.main_thread())t = MyThread(name='worker', target=worker)t2 = MyThread(name='not worker', target=worker)t.start()t2.start()t.join()t2.join()# 输出结果# &lt;_MainThread(MainThread, started 4587271616)&gt;# start~~~~~~~~~~~~~# run~~~~~~~~~~~~~~~# start~~~~~~~~~~~~~# run~~~~~~~~~~~~~~~# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:worker 123145369858048 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt;# INFO:root:not worker 123145375113216 主线程：&lt;_MainThread(MainThread, started 4587271616)&gt; 可以看到两个线程交替运行，如果使用print，你跑多次这个结果是不一样的。 打印前可以加入threading.main_thread()，这样可以看到俩个线程都是主线程派生出来的子线程。 换成run()方法后，结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import threadingimport timeimport logginglogging.basicConfig(level=logging.NOTSET)def worker(): count = 0 while True: if count &gt; 5: break time.sleep(1) count += 1 # print(\"worker running\") # print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident) logging.info(\"&#123;&#125; &#123;&#125; 主线程：&#123;&#125;\".format(threading.current_thread().name, threading.current_thread().ident, threading.main_thread()))class MyThread(threading.Thread): def start(self): print('start~~~~~~~~~~~~~') super().start() def run(self): print('run~~~~~~~~~~~~~~~') super().run()t = MyThread(name='worker', target=worker)t2 = MyThread(name='not worker', target=worker)t.run()t2.run()# run~~~~~~~~~~~~~~~# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# run~~~~~~~~~~~~~~~# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt;# INFO:root:MainThread 4705641920 主线程：&lt;_MainThread(MainThread, started 4705641920)&gt; 可以看到，run就是去调用函数，谁来调用呢？当然是当前线程了，可以看到 print(threading.main_thread().name, threading.current_thread().name, threading.current_thread().ident) 打印出来的都是主线程。 没有开新的线程，这就是普通函数调用，所以执行完t1.run()，然后执行t2.run()，这里就不是多线程。 当使用start方法启动线程后，进程内有多个活动的线程并行的工作，就是多线程。 一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程。一个进程至少有一个主线程。其他线程称为工作线程。 线程安全使用print来运行上面的两个例子，本应该是一行行打印，但很多字符串打印在了一起，这说明print函数被打断了，被线程切换打断了。 print函数分两步，第一步打印字符串，第二部换行，就在这之间，发生了线程的切换。 说明print函数不是线程安全函数。 print函数还没执行换行符，就被其它线程打断了，在python3中： def print(self, *args, sep=&#39; &#39;, end=&#39;\\n&#39;, file=None) print变成了函数，结尾默认加‘\\n’，你可以去改变这个参数，比如改成’’, 打印结果就是一行的一串字符 线程安全: 线程执行一段代码，不会产生不确定的结果，那这段代码就是线程安全的。在开发中，我们会使用标准库的logging来，打印信息，这个是线程安全的。 线程daemon线程可以被标识为”Daemon线程”，Daemon线程表明整个Python主程序只有在Daemon子线程运行时可以退出。该属性值继承自父线程，可通过setDaemon()函数设定该值。 daemon线程和non-daemon线程(注：这里的daemon不是Linux中的守护进程)： 进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。 主线程是第一个启动的线程。 父线程：如果线程A中启动了一个线程B，A就是B的父线程。 子线程：B就是A的子线程。 python中构造线程的时候可以设置daemon属性，这个属性必须在start方法之前设置好。 daemon属性：表示线程是否是daemon线程，这个值必须在start()之前设置，否则引发RuntimeError异常。 daemon=False 运行发现子线程依然执行，主线程已经执行完，但是主线程会一直等着子线程执行完daemon=True 运行发现主线程执行完程序立即结束了 实例方法： isDaemon()：是否是daemon线程。setDaemon()：设置为daemon线程，必须在start方法之前设置。 总结: 线程具有一个daemon属性，可以显式设置为True或False，也可以不设置，不设置则取默认值None。 如果不设置daemon，就取当前线程的daemon来设置它。子线程继承父线程的daemon值，作用和设置None一样。 主线程是non-daemon线程，即daemon=False。 从主线程创建的所有线程不设置daemon属性，则默认都是daemon=False，也就是non-daemon线程。 python程序在没有活着的non-daemon线程运行时退出，也就是剩下的只能是daemon线程，主线程才能退出，否则主线程就只能等待。 如果有non-daemon线程的时候，主线程退出时，也不会杀掉所有daemon线程，直到所有non-daemon线程全部结束 如果还有daemon线程，主线程需要退出，会结束所有 daemon线程，退出。 线程创建的时候t = threading.Thread(target=func, daemon=False)这个daemon不设置就是False 子线程也是non-daemon，只要有线程是non-daemon，python程序就不会退出，如果还未执行完成的线程是daemon的，主线程执行完，就会退出，并杀掉所有daemon线程。 Daemon线程会被粗鲁的直接结束，它所使用的资源（已打开文件、数据库事务等）无法被合理的释放。 123456789101112131415import timeimport threadingdef foo(n): for i in range(n): print(i) time.sleep(1)t1 = threading.Thread(target=foo, args=(10,), daemon=True)t1.start()# t1.join() # 设置join.print('Main Thread Exiting') 在这个例子中，子线程开始执行，然后主线程执行了打印，由于主线程执行完成了，而剩下的线程是daemon的，所以程序退出。把daemon = False或者不设置，结果就是打印了Main Thread Exiting后，子线程继续，打印1，2，3….. join 使用了join方法后，daemon线程执行完了，主线程才退出。 join(timeout=None)，是线程的标准方法之一。 一个线程中调用另一个线程的join方法，调用者将被阻塞，直到被调用线程终止。 一个线程可以被join多次。 timeout参数指定调用者等待多久，没有设置超时，就一直等待被调用线程结束。 调用谁的join方法，就是join谁，就要等谁。 把上面例子的 t1.join() # 设置join. 放开，print(&#39;Main Thread Exiting&#39;) 要等子线程执行完成才执行。 join ()方法：主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。 总结： 主要理解daemon join，不做处理的多线程，线程是并发的，daemon控制了主线程是否等待子线程执行完成，join控制了线程是否要组赛，主线程被阻塞了，就不会因为还剩daemon线程退出，因为主线程被阻塞了，他还没有执行完，所以这两个概念是互不冲突的（你可以设置超时时间，超时到了，主线程不再阻塞，就会杀掉daemon线程）。 在主线程中创建了3个线程，3个线程执行了join，就是说主线程要等着3个线程完成才执行，3个线程中的A线程创建了线程a，那么a就是A的子线程，a中join A就要等a执行完成，主线程也被阻塞，在等A，即主线程等A，A等a。 原子性python的大部分操作是原子性的，比如你对列表执行反向，排序，它不会被其它线程打断。 12import disdis.dis(foo) 利用标准库的dis可以看python代码的字节码实现，一般操作由一条指令来完成，那么就是原子性，如果一个操作（对应python的一行或几行代码）需要多个指令（入栈，出栈，调用寄存器等），可能在入栈等某个指令的时候被其它线程打断，出现和预期不一样的效果。 队列标准库queue提供了队列支持，在py2中，通过import Queue来使用队列，在py3中，通过from queue import Queue，py3中，除了Queue类，还增加了queue.LifoQueue（LIFO后进先出队列），queue.PriorityQueue（优先级队列） 实例方法q = queue.Queue(3) # 创建队列，队列最大元素3个，默认为0，此时队列长度没有限制 queue.qsize() 返回队列的大小 queue.empty() 如果队列为空，返回True，反之False queue.full() 如果队列满了，返回True，反之False queue.full 与 maxsize 大小对应 queue.get([block[, timeout]])获取队列，timeout等待时间 queue.get_nowait() 相当queue.get(False) queue.put(item) 写入队列，timeout等待时间 queue.put_nowait(item) 相当queue.put(item, False) queue.task_done() 在完成一项工作之后，queue.task_done()函数向任务已经完成的队列发送一个信号 queue.join() 实际上意味着等到队列为空，再执行别的操作 本地线程不同的线程对内容的修改只在线程内发挥作用，线程之间互相不影响，在flask框架中有使用到 12345678910111213141516171819202122232425import threadingmy_data = threading.local()my_data.number = 42print(my_data.number)log = []def f(): my_data.number = 11 log.append(my_data.number) print(id(my_data.number))thread = threading.Thread(target=f)thread.start()thread.join()print(log)print(my_data.number)print(id(my_data.number))# 42# 4559721904# [11]# 42# 4559722896 同步原语控制多线程同时访问资源，包括互斥锁，信号量，条件变量，事件 以房间为例子举例： 有些房间最多只能容纳一个人。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 还有些房间，可以同时容纳n个人。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 信号量使用信号量做为同步机制，使用with进入上下文管理器，省略了acquire和release，信号量通过计数器来管理，这里计数器初始是3，获取acquire操作，计数器减1，release操作，计数器加1，当计数器为0的时候，阻塞其它线程的操作。 通过执行结果可以看到，创建了5个线程，前3个线程 0，1，2 执行了 acquire操作，使得信号量为0，阻塞了其它线程，通过sleep模拟线程阻塞，等到线程 2 release的时候，线程 3 才执行 acquire 操作，4 线程也是等待 3 线程release后才执行 acquire。 通过使用信号量，实现了只能有3个线程并发，而锁其实就是信号量为1的情况。 1234567891011121314151617181920212223242526272829303132333435import timefrom random import randomfrom threading import Thread, Semaphoresema = Semaphore(3) # 创建信号量def foo(tid): with sema: print(f'&#123;tid&#125; acquire sema') time.sleep(random() * 2) print(f'&#123;tid&#125; release sema')threads = []for i in range(5): t = Thread(target=foo, args=(i,)) threads.append(t) t.start()for i in threads: i.join()# 0 acquire sema# 1 acquire sema# 2 acquire sema# 2 release sema# 3 acquire sema# 3 release sema# 4 acquire sema# 1 release sema# 0 release sema# 4 release sema 总结所以线程的执行结果是有很多因素影响的，在你用默认操作的时候，如果进行了IO密集任务或是CPU密集任务，IO密集在等待时会释放GIL，CPU密集也会执行一定数量的字节码后释放一下GIL，由于线程并发的切换是操作系统控制的，所以有这样的编程需求的时候，务必配合join，daemon等控制程序，不然什么时候切换，这是说不准的。 线程何时切换？一个线程无论何时开始睡眠或等待网络 I/O，其他线程总有机会获取 GIL 执行 Python 代码。这是协同式多任务处理。CPython 也还有抢占式多任务处理。如果一个线程不间断地在 Python 2 中运行 1000 字节码指令，或者不间断地在 Python 3 运行15 毫秒，那么它便会放弃 GIL，而其他线程可以运行。把这想象成旧日有多个线程但只有一个 CPU 时的时间片。 协同式多任务处理当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。 抢占式多任务处理Python线程可以主动释放 GIL，也可以先发制人抓取 GIL 。 让我们回顾下 Python 是如何运行的。你的程序分两个阶段运行。首先，Python文本被编译成一个名为字节码的简单二进制格式。第二，Python解释器的主回路，一个名叫 pyeval_evalframeex() 的函数，流畅地读取字节码，逐个执行其中的指令。当解释器通过字节码时，它会定期放弃GIL，而不需要经过正在执行代码的线程允许，这样其他线程便能运行。默认情况下，检测间隔是1000 字节码。所有线程都运行相同的代码，并以相同的方式定期从他们的锁中抽出。在 Python 3 GIL 的实施更加复杂，检测间隔不是一个固定数目的字节码，而是15 毫秒。然而，对于你的代码，这些差异并不显著。","tags":[{"name":"note","slug":"note","permalink":"http://www.liuzhidream.com/tags/note/"},{"name":"python","slug":"python","permalink":"http://www.liuzhidream.com/tags/python/"}]}]